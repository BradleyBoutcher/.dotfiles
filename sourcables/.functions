logs() {
	docker logs -f $(docker ps --filter name="$1" --format="{{.ID}}")	
}

# Open the Pull Request URL for your current directory's branch (base branch defaults to master)
function openpr() {
  github_url=`git remote -v | awk '/fetch/{print $2}' | sed -Ee 's#(git@|git://)#https://#' -e 's@com:@com/@' -e 's%\.git$%%' | awk '/github/'`;
  branch_name=`git symbolic-ref HEAD | cut -d"/" -f 3,4`;
  pr_url=$github_url"/compare/master..."$branch_name
  open $pr_url;
}

# Run git push and then immediately open the Pull Request URL
function gpr() {
  git push origin HEAD

  if [ $? -eq 0 ]; then
    openpr
  else
    echo 'failed to push commits and open a pull request.';
  fi
}

function oc_login() {
  cluster=$1
  if [[ -z "$2" ]]; then
    env="ci"
  else
    env="$2"
  fi

  summon --provider summon-conjur --yaml="
    OPENSHIFT_URL: !var $env/openshift/$cluster/hostname
    OPENSHIFT_USERNAME: !var $env/openshift/$cluster/username
    OPENSHIFT_PASSWORD: !var $env/openshift/$cluster/password
  " sh -c "oc login \$OPENSHIFT_URL:8443 --insecure-skip-tls-verify=true -u \$OPENSHIFT_USERNAME -p \$OPENSHIFT_PASSWORD"
}

_SUSEconfig () {
	# undefined
	builtin autoload -XUz
}
__function_on_stack () {
	__rvm_string_includes "${FUNCNAME[*]}" "$@" || return $?
}
__function_unset () {
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		unset -f "$1"
	else
		unset "$1"
	fi
}
__go_tool_complete () {
	typeset -a commands build_flags
	commands+=('build[compile packages and dependencies]' 'clean[remove object files]' 'doc[run godoc on package sources]' 'env[print Go environment information]' 'fix[run go tool fix on packages]' 'fmt[run gofmt on package sources]' 'generate[generate Go files by processing source]' 'get[download and install packages and dependencies]' 'help[display help]' 'install[compile and install packages and dependencies]' 'list[list packages]' 'mod[modules maintenance]' 'run[compile and run Go program]' 'test[test packages]' 'tool[run specified go tool]' 'version[print Go version]' 'vet[run go tool vet on packages]') 
	if (( CURRENT == 2 ))
	then
		_values 'go tool commands' ${commands[@]}
		return
	fi
	build_flags=('-a[force reinstallation of packages that are already up-to-date]' '-n[print the commands but do not run them]' '-p[number of parallel builds]:number' '-race[enable data race detection]' '-x[print the commands]' '-work[print temporary directory name and keep it]' '-ccflags[flags for 5c/6c/8c]:flags' '-gcflags[flags for 5g/6g/8g]:flags' '-ldflags[flags for 5l/6l/8l]:flags' '-gccgoflags[flags for gccgo]:flags' '-compiler[name of compiler to use]:name' '-installsuffix[suffix to add to package directory]:suffix' '-tags[list of build tags to consider satisfied]:tags') 
	__go_packages () {
		local gopaths
		declare -a gopaths
		gopaths=("${(s/:/)$(go env GOPATH)}") 
		gopaths+=("$(go env GOROOT)") 
		for p in $gopaths
		do
			_path_files -W "$p/src" -/
		done
	}
	__go_identifiers () {
		compadd $(godoc -templates $ZSH/plugins/golang/templates ${words[-2]} 2> /dev/null)
	}
	case ${words[2]} in
		(doc) _arguments -s -w "-c[symbol matching honors case (paths not affected)]" "-cmd[show symbols with package docs even if package is a command]" "-u[show unexported symbols as well as exported]" "2:importpaths:__go_packages" ":next identifiers:__go_identifiers" ;;
		(clean) _arguments -s -w "-i[remove the corresponding installed archive or binary (what 'go install' would create)]" "-n[print the remove commands it would execute, but not run them]" "-r[apply recursively to all the dependencies of the packages named by the import paths]" "-x[print remove commands as it executes them]" "*:importpaths:__go_packages" ;;
		(fix | fmt | vet) _alternative ':importpaths:__go_packages' ':files:_path_files -g "*.go"' ;;
		(install) _arguments -s -w : ${build_flags[@]} "-v[show package names]" '*:importpaths:__go_packages' ;;
		(get) _arguments -s -w : ${build_flags[@]} ;;
		(build) _arguments -s -w : ${build_flags[@]} "-v[show package names]" "-o[output file]:file:_files" "*:args:{ _alternative ':importpaths:__go_packages' ':files:_path_files -g \"*.go\"' }" ;;
		(test) _arguments -s -w : ${build_flags[@]} "-c[do not run, compile the test binary]" "-i[do not run, install dependencies]" "-v[print test output]" "-x[print the commands]" "-short[use short mode]" "-parallel[number of parallel tests]:number" "-cpu[values of GOMAXPROCS to use]:number list" "-run[run tests and examples matching regexp]:regexp" "-bench[run benchmarks matching regexp]:regexp" "-benchmem[print memory allocation stats]" "-benchtime[run each benchmark until taking this long]:duration" "-blockprofile[write goroutine blocking profile to file]:file" "-blockprofilerate[set sampling rate of goroutine blocking profile]:number" "-timeout[kill test after that duration]:duration" "-cpuprofile[write CPU profile to file]:file:_files" "-memprofile[write heap profile to file]:file:_files" "-memprofilerate[set heap profiling rate]:number" "*:args:{ _alternative ':importpaths:__go_packages' ':files:_path_files -g \"*.go\"' }" ;;
		(list) _arguments -s -w : "-f[alternative format for the list]:format" "-json[print data in json format]" "-compiled[set CompiledGoFiles to the Go source files presented to the compiler]" "-deps[iterate over not just the named packages but also all their dependencies]" "-e[change the handling of erroneous packages]" "-export[set the Export field to the name of a file containing up-to-date export information for the given package]" "-find[identify the named packages but not resolve their dependencies]" "-test[report not only the named packages but also their test binaries]" "-m[list modules instead of packages]" "-u[adds information about available upgrades]" "-versions[set the Module's Versions field to a list of all known versions of that module]:number" "*:importpaths:__go_packages" ;;
		(mod) typeset -a mod_commands
			mod_commands+=('download[download modules to local cache]' 'edit[edit go.mod from tools or scripts]' 'graph[print module requirement graph]' 'init[initialize new module in current directory]' 'tidy[add missing and remove unused modules]' 'vendor[make vendored copy of dependencies]' 'verify[verify dependencies have expected content]' 'why[explain why packages or modules are needed]') 
			if (( CURRENT == 3 ))
			then
				_values 'go mod commands' ${mod_commands[@]} "help[display help]"
				return
			fi
			case ${words[3]} in
				(help) _values 'go mod commands' ${mod_commands[@]} ;;
				(download) _arguments -s -w : "-json[print a sequence of JSON objects standard output]" "*:flags" ;;
				(edit) _arguments -s -w : "-fmt[reformat the go.mod file]" "-module[change the module's path]" "-replace[=old{@v}=new{@v} add a replacement of the given module path and version pair]:name" "-dropreplace[=old{@v}=new{@v} drop a replacement of the given module path and version pair]:name" "-go[={version} set the expected Go language version]:number" "-print[print the final go.mod in its text format]" "-json[print the final go.mod file in JSON format]" "*:flags" ;;
				(graph)  ;;
				(init)  ;;
				(tidy) _arguments -s -w : "-v[print information about removed modules]" "*:flags" ;;
				(vendor) _arguments -s -w : "-v[print the names of vendored]" "*:flags" ;;
				(verify)  ;;
				(why) _arguments -s -w : "-m[treats the arguments as a list of modules and finds a path to any package in each of the modules]" "-vendor[exclude tests of dependencies]" "*:importpaths:__go_packages" ;;
			esac ;;
		(help) _values "${commands[@]}" 'environment[show Go environment variables available]' 'gopath[GOPATH environment variable]' 'packages[description of package lists]' 'remote[remote import path syntax]' 'testflag[description of testing flags]' 'testfunc[description of testing functions]' ;;
		(run) _arguments -s -w : ${build_flags[@]} '*:file:_files -g "*.go"' ;;
		(tool) if (( CURRENT == 3 ))
			then
				_values "go tool" $(go tool)
				return
			fi
			case ${words[3]} in
				([568]g) _arguments -s -w : '-I[search for packages in DIR]:includes:_path_files -/' '-L[show full path in file:line prints]' '-S[print the assembly language]' '-V[print the compiler version]' '-e[no limit on number of errors printed]' '-h[panic on an error]' '-l[disable inlining]' '-m[print optimization decisions]' '-o[file specify output file]:file' '-p[assumed import path for this code]:importpath' '-u[disable package unsafe]' "*:file:_files -g '*.go'" ;;
				([568]l) local O=${words[3]%l} 
					_arguments -s -w : '-o[file specify output file]:file' '-L[search for packages in DIR]:includes:_path_files -/' "*:file:_files -g '*.[ao$O]'" ;;
				(dist) _values "dist tool" banner bootstrap clean env install version ;;
				(*) _files ;;
			esac ;;
	esac
}
__list_remote_all () {
	\typeset _iterator rvm_remote_server_url rvm_remote_server_path
	_iterator="" 
	while __rvm_db "rvm_remote_server_url${_iterator:-}" rvm_remote_server_url
	do
		if __rvm_include_travis_binaries
		then
			__rvm_system_path "" "${_iterator}"
			rvm_debug "__list_remote_all${_iterator:-} $rvm_remote_server_url $rvm_remote_server_path"
			__list_remote_for "${rvm_remote_server_url}" "$rvm_remote_server_path"
		fi
		: $(( _iterator+=1 ))
	done | \command \sort -u | __rvm_version_sort
}
__list_remote_for () {
	__list_remote_for_local "$@" || __list_remote_for_index "$@" || __list_remote_for_s3 "$@" || return $?
}
__list_remote_for_index () {
	if file_exists_at_url "${1}/index.txt"
	then
		rvm_debug "__list_remote_for_index ${1}/index.txt"
		__rvm_curl -s "${1}/index.txt" | GREP_OPTIONS="" \command \grep -E "${1}/${2}/.*\.tar\.(gz|bz2)$"
	elif file_exists_at_url "${1}/${2}/index.txt"
	then
		rvm_debug "__list_remote_for_index ${1}/${2}/index.txt"
		__rvm_curl -s "${1}/${2}/index.txt" | GREP_OPTIONS="" \command \grep -E "${1}/${2}/.*\.tar\.(gz|bz2)$"
	else
		return 1
	fi
	true
}
__list_remote_for_local () {
	\typeset __status1 __status2
	__status1=0 
	__status2=0 
	if [[ -f $rvm_user_path/remote ]]
	then
		__rvm_grep "${1}/${2}" < $rvm_user_path/remote || __status1=$? 
	fi
	__rvm_grep "${1}/${2}" < $rvm_path/config/remote || __status2=$? 
	if (( __status1 || __status2 ))
	then
		return 1
	else
		rvm_debug "__list_remote_for_local found"
	fi
	true
}
__list_remote_for_s3 () {
	curl -ILfs "${1}" | __rvm_grep "Server: AmazonS3" > /dev/null || return $?
	\typeset __tmp_name __iterator __next __local_url
	__iterator=0 
	__next="" 
	__tmp_name="$(
    : ${TMPDIR:=${rvm_tmp_path:-/tmp}}
    mktemp "${TMPDIR}/tmp.XXXXXXXXXXXXXXXXXX"
  )" 
	while [[ __iterator -eq 0 || -n "${__next}" ]]
	do
		__local_url="${1}?prefix=${2}/${__next:+&marker=${__next}}" 
		rvm_debug "__list_remote_for_s3-${__iterator} ${__local_url}"
		__rvm_curl -s "${__local_url}" > "${__tmp_name}${__iterator}"
		GREP_OPTIONS="" \command \grep -oE "<Key>[^<]*</Key>" < "${__tmp_name}${__iterator}" | __rvm_awk -F"[<>]" '{print $3}' > "${__tmp_name}"
		if __rvm_grep "<IsTruncated>true</IsTruncated>" < "${__tmp_name}${__iterator}"
		then
			__next="$(__rvm_tail -n 1 "${__tmp_name}")" 
		else
			__next="" 
		fi
		rm "${__tmp_name}${__iterator}"
		: $(( __iterator+=1 ))
	done
	GREP_OPTIONS="" \command \grep -E "${2}/.*\.tar\.(gz|bz2)$" < "${__tmp_name}" | GREP_OPTIONS="" \command \grep -v -- "-src-" | __rvm_awk "{ print "'"'$1/'"'"\$1 }"
	rm "${__tmp_name}"*
}
__map_tar_excludes () {
	\typeset __exclude_element
	for __exclude_element
	do
		__exclude_elements+=(--exclude "${__exclude_element}") 
	done
}
__rvm_add_once () {
	\typeset IFS
	IFS="|" 
	eval "[[ \"${IFS}\${${1}[*]}${IFS}\" == \*\"${IFS}\${2}${IFS}\"\* ]] || ${1}+=( \"\${2}\" )"
}
__rvm_add_to_path () {
	export PATH
	if (( $# != 2 )) || [[ -z "$2" ]]
	then
		rvm_error "__rvm_add_to_path requires two parameters"
		return 1
	fi
	__rvm_remove_from_path "$2"
	case "$1" in
		(prepend) PATH="$2:$PATH"  ;;
		(append) PATH="$PATH:$2"  ;;
	esac
	if [[ -n "${rvm_user_path_prefix:-}" ]]
	then
		__rvm_remove_from_path "${rvm_user_path_prefix}"
		PATH="${rvm_user_path_prefix}:$PATH" 
	fi
	builtin hash -r
}
__rvm_after_cd () {
	\typeset rvm_hook
	rvm_hook="after_cd" 
	if [[ -n "${rvm_scripts_path:-}" || -n "${rvm_path:-}" ]]
	then
		source "${rvm_scripts_path:-$rvm_path/scripts}/hook"
	fi
}
__rvm_ant () {
	\ant "$@" || return $?
}
__rvm_array_add_or_update () {
	\typeset _array_name _variable _separator _value _local_value
	\typeset -a _array_value_old _array_value_new
	_array_name="$1" 
	_variable="$2" 
	_separator="$3" 
	_value="${4##${_separator}}" 
	_array_value_new=() 
	eval "_array_value_old=( \"\${${_array_name}[@]}\" )"
	case " ${_array_value_old[*]} " in
		(*[[:space:]]${_variable}*) for _local_value in "${_array_value_old[@]}"
			do
				case "${_local_value}" in
					(${_variable}*) _array_value_new+=("${_local_value}${_separator}${_value}")  ;;
					(*) _array_value_new+=("${_local_value}")  ;;
				esac
			done ;;
		(*) _array_value_new=("${_array_value_old[@]}" "${_variable}${_value}")  ;;
	esac
	eval "${_array_name}=( \"\${_array_value_new[@]}\" )"
}
__rvm_array_contains () {
	\typeset _search _iterator
	_search="$1" 
	shift
	for _iterator
	do
		case "${_iterator}" in
			(${_search}) return 0 ;;
		esac
	done
	return 1
}
__rvm_array_prepend_or_ignore () {
	\typeset _array_name _variable _separator _value _prefix _local_value
	\typeset -a _array_value_old _array_value_new
	_array_name="$1" 
	_variable="$2" 
	_separator="$3" 
	_value="$4" 
	_prefix="$5" 
	_array_value_new=() 
	eval "_array_value_old=( \"\${${_array_name}[@]}\" )"
	case " ${_array_value_old[*]} " in
		(*[[:space:]]${_variable}*) for _local_value in "${_array_value_old[@]}"
			do
				case "${_local_value}" in
					(${_variable}*${_prefix}*) rvm_debug "__rvm_array_prepend_or_ignore ${_array_name} ${_local_value}"
						_array_value_new+=("${_local_value}")  ;;
					(${_variable}*) rvm_debug "__rvm_array_prepend_or_ignore ${_array_name} ${_variable}\"${_value}${_separator}${_local_value#${_variable}}\""
						_array_value_new+=("${_variable}${_value}${_separator}${_local_value#${_variable}}")  ;;
					(*) _array_value_new+=("${_local_value}")  ;;
				esac
			done
			eval "${_array_name}=( \"\${_array_value_new[@]}\" )" ;;
	esac
}
__rvm_ask_for () {
	\typeset response
	rvm_warn "$1"
	printf "%b" "(anything other than '$2' will cancel) > "
	if read response && [[ "$2" == "$response" ]]
	then
		return 0
	else
		return 1
	fi
}
__rvm_ask_to_trust () {
	\typeset trusted value anykey _rvmrc _rvmrc_base
	_rvmrc="${1}" 
	_rvmrc_base="$(basename "${_rvmrc}")" 
	if [[ ! -t 0 || -n "$MC_SID" ]] || (( ${rvm_promptless:=0} == 1 ))
	then
		return 2
	fi
	__rvm_file_notice_initial
	trusted=0 
	while (( ! trusted ))
	do
		printf "%b" 'y[es], n[o], v[iew], c[ancel]> '
		builtin read response
		value="$(echo -n "${response}" | \command \tr '[[:upper:]]' '[[:lower:]]' | __rvm_strip)" 
		case "${value:-n}" in
			(v | view) __rvm_display_rvmrc ;;
			(y | yes) trusted=1  ;;
			(n | no) break ;;
			(c | cancel) return 1 ;;
		esac
	done
	if (( trusted ))
	then
		__rvm_trust_rvmrc "$1"
		return 0
	else
		__rvm_untrust_rvmrc "$1"
		return 1
	fi
}
__rvm_automake () {
	\automake "$@" || return $?
}
__rvm_autoreconf () {
	\autoreconf "$@" || return $?
}
__rvm_awk () {
	\awk "$@" || return $?
}
__rvm_become () {
	\typeset string rvm_rvmrc_flag
	string="$1" 
	rvm_rvmrc_flag=0 
	[[ -n "$string" ]] && {
		rvm_ruby_string="$string" 
		rvm_gemset_name="" 
	}
	__rvm_use > /dev/null || return $?
	rvm_ruby_string="${rvm_ruby_string}${rvm_gemset_name:+${rvm_gemset_separator:-'@'}}${rvm_gemset_name:-}" 
	return 0
}
__rvm_calculate_remote_file () {
	rvm_remote_server_url="$( __rvm_db "rvm_remote_server_url${3:-}" )" 
	[[ -n "$rvm_remote_server_url" ]] || {
		rvm_debug "rvm_remote_server_url${3:-} not found"
		return $1
	}
	__rvm_include_travis_binaries || return $1
	__rvm_system_path "" "${3:-}"
	__rvm_ruby_package_file "${4:-}"
	__remote_file="${rvm_remote_server_url}/${rvm_remote_server_path}${rvm_ruby_package_file}" 
}
__rvm_calculate_space_free () {
	__free_space="$( \command \df -Pk "$1" | __rvm_awk 'BEGIN{x=4} /Free/{x=3} $3=="Avail"{x=3} END{print $x}' )" 
	if [[ "${__free_space}" == *M ]]
	then
		__free_space="${__free_space%M}" 
	else
		__free_space="$(( __free_space / 1024 ))" 
	fi
}
__rvm_calculate_space_used () {
	__used_space="$( \command \du -msc "$@" | __rvm_awk 'END {print $1}' )" 
	__used_space="${__used_space%M}" 
}
__rvm_call_with_restored_umask () {
	rvm_umask="$(umask)" 
	if [[ -n "${rvm_stored_umask:-}" ]]
	then
		umask ${rvm_stored_umask}
	fi
	"$@"
	umask "${rvm_umask}"
	unset rvm_umask
}
__rvm_cd () {
	\typeset old_cdpath ret
	ret=0 
	old_cdpath="${CDPATH}" 
	CDPATH="." 
	chpwd_functions="" builtin cd "$@" || ret=$? 
	CDPATH="${old_cdpath}" 
	return $ret
}
__rvm_cd_functions_set () {
	__rvm_do_with_env_before
	if [[ -n "${rvm_current_rvmrc:-""}" && "$OLDPWD" == "$PWD" ]]
	then
		rvm_current_rvmrc="" 
	fi
	__rvm_project_rvmrc >&2 || true
	__rvm_after_cd || true
	__rvm_do_with_env_after
	return 0
}
__rvm_check_pipestatus () {
	for __iterator
	do
		case "${__iterator}" in
			("") true ;;
			(0) true ;;
			(*) return ${__iterator} ;;
		esac
	done
	return 0
}
__rvm_check_rvmrc_trustworthiness () {
	(( ${rvm_trust_rvmrcs_flag:-0} == 0 )) || return 0
	[[ -n "$1" ]] || (( $# > 1 )) || return 1
	\typeset _first _second saveIFS
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		_first=1 
	else
		_first=0 
	fi
	_second=$(( _first + 1 )) 
	saveIFS="$IFS" 
	IFS=$';' 
	\typeset -a trust
	trust=($( __rvm_rvmrc_stored_trust "$1" )) 
	IFS="$saveIFS" 
	if [[ "${trust[${_second}]:-'#'}" == "$(__rvm_checksum_for_contents "$1")" ]]
	then
		[[ "${trust[${_first}]}" == '1' ]] || return $?
	else
		__rvm_ask_to_trust "$@" || return $?
	fi
	true
}
__rvm_checksum_all () {
	[[ -n "${_checksum_md5:-}" && -n "${_checksum_sha512:-}" ]]
}
__rvm_checksum_any () {
	[[ -n "${_checksum_md5:-}" || -n "${_checksum_sha512:-}" ]]
}
__rvm_checksum_calculate_file () {
	rvm_debug "Calculate checksums for file ${1}"
	_checksum_md5="$(    __rvm_md5_calculate      "${1:-}" )" 
	_checksum_sha512="$( __rvm_sha__calculate 512 "${1:-}" )" 
}
__rvm_checksum_for_contents () {
	\typeset __sum
	__sum=$(  echo "$1" | \command \cat - "$1" | __rvm_md5_for_contents   )  || {
		rvm_error "Neither md5 nor md5sum were found in the PATH"
		return 1
	}
	__sum+=$( echo "$1" | \command \cat - "$1" | __rvm_sha256_for_contents )  || {
		rvm_error "Neither sha256sum nor shasum found in the PATH"
		return 1
	}
	echo ${__sum}
}
__rvm_checksum_none () {
	[[ -z "${_checksum_md5:-}" && -z "${_checksum_sha512:-}" ]]
}
__rvm_checksum_read () {
	rvm_debug "Load checksums for $1"
	__rvm_checksum_any && return 0
	\typeset _type _value _name
	\typeset -a _list
	list=() 
	for _name in "$@"
	do
		if [[ "$_name" == *"?"* ]]
		then
			list+=("${_name%\?*}") 
		else
			list+=("$_name") 
		fi
	done
	for _name in "${list[@]}"
	do
		rvm_debug "Searching checksum config files for $_name"
		_checksum_md5="$(      __rvm_db_ "$rvm_path/config/md5"    "$_name" | \command \head -n 1 )" 
		[[ -n "${_checksum_md5:-}" ]] || _checksum_md5="$(    __rvm_db_ "$rvm_user_path/md5"      "$_name" | \command \head -n 1 )" 
		_checksum_sha512="$(   __rvm_db_ "$rvm_path/config/sha512" "$_name" | \command \head -n 1 )" 
		[[ -n "${_checksum_sha512:-}" ]] || _checksum_sha512="$( __rvm_db_ "$rvm_user_path/sha512"   "$_name" | \command \head -n 1 )" 
		__rvm_checksum_any && return 0
	done
	for _name in "${list[@]}"
	do
		if [[ $_name == http*rubinius* ]]
		then
			if [[ -z "${_checksum_md5:-}" ]]
			then
				_checksum_md5="$(__rvm_curl -s -L $_name.md5)" 
			fi
			if [[ -z "${_checksum_sha512:-}" ]]
			then
				_checksum_sha512="$(__rvm_curl -s -L $_name.sha512)" 
			fi
		fi
		__rvm_checksum_any && return 0
	done
	rvm_debug "    ...checksums not found"
	return 1
}
__rvm_checksum_validate_file () {
	rvm_debug "Validating checksums for file ${1}"
	if __rvm_checksum_any
	then
		rvm_debug "    ...checksums found in db"
	else
		rvm_debug "    ...checksums not found in db"
		return 1
	fi
	if [[ -n "${_checksum_md5:-}" ]]
	then
		rvm_debug "Validating md5 checksum"
		if [[ "$(__rvm_md5_calculate "${1:-}")" == "${_checksum_md5:-}" ]]
		then
			rvm_debug "    ...md5 checksum is valid!"
		else
			rvm_debug "    ...md5 checksum is not valid!!!"
			return 2
		fi
	fi
	if [[ -n "${_checksum_sha512:-}" ]]
	then
		rvm_debug "Validating sha15 checksum"
		if [[ "$(__rvm_sha__calculate 512 "${1:-}")" == "${_checksum_sha512:-}" ]]
		then
			rvm_debug "    ...sha512 checksum is valid!"
		else
			rvm_debug "    ...sha512 checksum is not valid!!!"
			return 3
		fi
	fi
	return 0
}
__rvm_checksum_write () {
	[[ -n "${1:-}" ]] || return 1
	__rvm_checksum_any || return 1
	[[ -z "${_checksum_md5:-}" ]] || __rvm_db_ "$rvm_user_path/md5" "${1:-}" "${_checksum_md5:-}"
	[[ -z "${_checksum_sha512:-}" ]] || __rvm_db_ "$rvm_user_path/sha512" "${1:-}" "${_checksum_sha512:-}"
	return 0
}
__rvm_cleanse_variables () {
	__rvm_unset_ruby_variables
	if [[ ${rvm_sticky_flag:-0} -eq 1 ]]
	then
		export rvm_gemset_name
	else
		unset rvm_gemset_name
	fi
	unset rvm_configure_flags rvm_patch_names rvm_make_flags
	unset rvm_env_string rvm_ruby_string rvm_action rvm_error_message rvm_force_flag rvm_debug_flag rvm_delete_flag rvm_summary_flag rvm_json_flag rvm_yaml_flag rvm_file_name rvm_user_flag rvm_system_flag rvm_install_flag rvm_llvm_flag rvm_sticky_flag rvm_rvmrc_flag rvm_gems_flag rvm_docs_flag rvm_ruby_alias rvm_static_flag rvm_archive_extension rvm_hook rvm_ruby_name rvm_remote_flag
	__rvm_load_rvmrc
}
__rvm_cleanup_tmp () {
	if [[ -d "${rvm_tmp_path}/" ]]
	then
		case "${rvm_tmp_path%\/}" in
			(*tmp) __rvm_rm_rf "${rvm_tmp_path}/${1:-$$}*" ;;
		esac
	fi
	true
}
__rvm_cli_autoreload () {
	if [[ ${rvm_reload_flag:-0} -eq 1 ]]
	then
		if [[ -s "$rvm_scripts_path/rvm" ]]
		then
			__rvm_project_rvmrc_lock=0 
			source "$rvm_scripts_path/rvm"
		else
			echo "rvm not found in $rvm_path, please install and run 'rvm reload'"
			__rvm_teardown
		fi
	else
		__rvm_teardown
	fi
}
__rvm_cli_autoupdate () {
	[[ " $* " == *" install "* && " $* " != *" help install "* ]] || [[ " $* " == *" list known "* ]] || return 0
	\typeset online_version version_release
	case "${rvm_autoupdate_flag:-1}" in
		(0|disabled) true ;;
		(1|warn) if __rvm_cli_autoupdate_version_old
			then
				__rvm_cli_autoupdate_warning
			fi ;;
		(2|enabled) if __rvm_cli_autoupdate_version_old
			then
				__rvm_cli_autoupdate_execute || return $?
			fi ;;
	esac
	true
}
__rvm_cli_autoupdate_execute () {
	printf "%b" "Found old RVM ${rvm_version%% *} - updating.\n"
	__rvm_cli_rvm_get "${version_release}" || return $?
	__rvm_cli_rvm_reload
}
__rvm_cli_autoupdate_version_old () {
	online_version="$( __rvm_version_remote )" 
	version_release="$(\command \cat "$rvm_path/RELEASE" 2>/dev/null)" 
	: version_release:"${version_release:=master}"
	if [[ "${online_version}-next" == "${rvm_version%% *}" ]]
	then
		return 1
	fi
	[[ -s "$rvm_path/VERSION" && -n "${online_version:-}" ]] && __rvm_version_compare "${rvm_version%% *}" -lt "${online_version:-}" || return $?
}
__rvm_cli_autoupdate_warning () {
	rvm_warn "Warning, new version of rvm available '${online_version}', you are using older version '${rvm_version%% *}'.
You can disable this warning with:   echo rvm_autoupdate_flag=0 >> ~/.rvmrc
You can enable auto-update with:     echo rvm_autoupdate_flag=2 >> ~/.rvmrc
You can update manually with:        rvm get VERSION                         (e.g. 'rvm get stable')
"
}
__rvm_cli_get_and_execute_installer () {
	__rvm_cli_get_installer_cleanup || return $?
	rvm_log "Downloading https://get.rvm.io"
	__rvm_curl -s https://get.rvm.io -o "${rvm_archives_path}/rvm-installer" || {
		\typeset _ret=$?
		rvm_error "Could not download rvm-installer, please report to https://github.com/rvm/rvm/issues"
		return ${_ret}
	}
	__rvm_cli_get_and_verify_pgp || return $?
	bash "${rvm_archives_path}/rvm-installer" "$@" || {
		\typeset _ret=$?
		rvm_error "Could not update RVM, please report to https://github.com/rvm/rvm/issues"
		return ${_ret}
	}
}
__rvm_cli_get_and_verify_pgp () {
	\typeset rvm_gpg_command
	if rvm_install_gpg_setup
	then
		pgp_signature_url="$( __rvm_curl -sSI https://get.rvm.io | \tr "\r" " " | __rvm_awk '/Location:/{print $2".asc"}' )" 
		rvm_notify "Downloading $pgp_signature_url"
		__rvm_curl -s "${pgp_signature_url}" -o "${rvm_archives_path}/rvm-installer.asc" || return $?
		rvm_notify "Verifying ${rvm_archives_path}/rvm-installer.asc"
		verify_package_pgp "${rvm_archives_path}/rvm-installer" "${rvm_archives_path}/rvm-installer.asc" "$pgp_signature_url" || return $?
	else
		rvm_warn "No GPG software exists to validate rvm-installer, skipping."
	fi
}
__rvm_cli_get_installer_cleanup () {
	[[ -w "${rvm_archives_path}" ]] || {
		rvm_error "Archives path '${rvm_archives_path}' not writable, aborting."
		return 1
	}
	[[ ! -e "${rvm_archives_path}/rvm-installer" ]] || rm -f "${rvm_archives_path}/rvm-installer" || {
		rvm_error "Previous installer '${rvm_archives_path}/rvm-installer' exists and can not be removed, aborting."
		return 2
	}
}
__rvm_cli_install_ruby () {
	(
		if [[ -n "$1" ]]
		then
			\typeset __rubies __installed __missing __search_list
			\typeset -a __search
			__rvm_custom_separated_array __search , "$1"
			__rubies="$1" 
			__search_list="" 
			__rvm_cli_rubies_select || return $?
			if __rvm_cli_rubies_not_installed
			then
				__rvm_run_wrapper manage install "${__rubies}" || return $?
			fi
		else
			rvm_error "Can not use or install 'all' rubies. You can get a list of installable rubies with 'rvm list known'."
			false
		fi
	)
}
__rvm_cli_load_rvmrc () {
	if (( ${rvm_ignore_rvmrc:=0} == 0 ))
	then
		[[ -n "${rvm_stored_umask:-}" ]] || export rvm_stored_umask=$(umask) 
		rvm_rvmrc_files=("/etc/rvmrc" "$HOME/.rvmrc") 
		if [[ -n "${rvm_prefix:-}" ]] && [[ ! "$HOME/.rvmrc" -ef "${rvm_prefix}/.rvmrc" ]]
		then
			rvm_rvmrc_files+=("${rvm_prefix}/.rvmrc") 
		fi
		for rvmrc in "${rvm_rvmrc_files[@]}"
		do
			if [[ -f "$rvmrc" ]]
			then
				if __rvm_grep '^\s*rvm .*$' "$rvmrc" > /dev/null 2>&1
				then
					printf "%b" "
Error:
        $rvmrc is for rvm settings only.
        rvm CLI may NOT be called from within $rvmrc.
        Skipping the loading of $rvmrc"
					return 1
				else
					source "$rvmrc"
				fi
			fi
		done
		unset rvm_rvmrc_files
	fi
}
__rvm_cli_posix_check () {
	if __rvm_has_opt "posix"
	then
		echo "RVM can not be run with \`set -o posix\`, please turn it off and try again."
		return 100
	fi
}
__rvm_cli_rubies_not_installed () {
	if (( ${rvm_force_flag:-0} == 0 )) && __installed="$(
      __rvm_list_strings | __rvm_grep -E "${__search_list}"
    )"  && [[ -n "${__installed}" ]]
	then
		rvm_warn "Already installed ${__installed//|/,}.
To reinstall use:

    rvm reinstall ${__installed//|/,}
"
		return 2
	fi
	true
}
__rvm_cli_rubies_select () {
	\typeset __ruby
	for __ruby in "${__search[@]}"
	do
		rvm_ruby_string="${__ruby}" 
		__rvm_select && if [[ -n "$rvm_ruby_string" ]]
		then
			__search_list+="^$rvm_ruby_string\$|" 
		else
			rvm_error "Could not detect ruby version/name for installation '${__ruby}', please be more specific."
			return 1
		fi
	done
	__search_list="${__search_list%|}" 
}
__rvm_cli_rvm_get () {
	case "$1" in
		([0-9]*.[0-9]*.[0-9]*) rvm_warn "
Hi there, it looks like you have requested updating rvm to version $1,
if your intention was ruby installation use instead: rvm install $1
" ;;
	esac
	case "$1" in
		(stable|master|head|branch|latest|latest-*|[0-9]*.[0-9]*.[0-9]*) __rvm_cli_get_and_execute_installer "$@" || return $?
			\typeset -x rvm_hook
			rvm_hook="after_update" 
			source "${rvm_scripts_path:-"$rvm_path/scripts"}/hook"
			rvm_reload_flag=1  ;;
		(*) rvm_help get ;;
	esac
}
__rvm_cli_rvm_reload () {
	__rvm_project_rvmrc_lock=0 
	rvm_reload_flag=1 
	source "${rvm_scripts_path:-${rvm_path}/scripts}/rvm"
}
__rvm_cli_version_check () {
	\typeset disk_version
	disk_version="$( __rvm_version_installed )" 
	if [[ -s "$rvm_path/VERSION" && "${rvm_version:-}" != "${disk_version:-}" && " $* " != *" reload "* ]]
	then
		if (( ${rvm_auto_reload_flag:-0} ))
		then
			__rvm_cli_rvm_reload
		else
			rvm_warn "RVM version <notify>${disk_version}</notify> is installed, yet version <error>${rvm_version}</error> is loaded.

Please open a new shell or run one of the following commands:

    <code>rvm reload</code>
    <code>echo rvm_auto_reload_flag=1 >> ~/.rvmrc</code> <comment># OR for auto reload with msg</comment>
    <code>echo rvm_auto_reload_flag=2 >> ~/.rvmrc</code> <comment># OR for silent auto reload</comment>
"
			return 1
		fi
	fi
}
__rvm_conditionally_add_bin_path () {
	[[ ":${PATH}:" == *":${rvm_bin_path}:"* ]] || {
		if [[ "${rvm_ruby_string:-"system"}" == "system" && -z "$GEM_HOME" ]]
		then
			PATH="$PATH:${rvm_bin_path}" 
		else
			PATH="${rvm_bin_path}:$PATH" 
		fi
	}
}
__rvm_conditionally_do_with_env () {
	if (( __rvm_env_loaded > 0 ))
	then
		"$@"
	else
		__rvm_do_with_env "$@"
	fi
}
__rvm_cp () {
	\cp "$@" || return $?
}
__rvm_curl () {
	(
		\typeset curl_path
		if [[ "${_system_name} ${_system_version}" == "Solaris 10" ]] && ! __rvm_which curl > /dev/null 2>&1
		then
			curl_path=/opt/csw/bin/ 
		else
			curl_path="" 
		fi
		__rvm_which ${curl_path}curl > /dev/null 2>&1 || {
			rvm_error "RVM requires 'curl'. Install 'curl' first and try again."
			return 200
		}
		\typeset -a __flags
		__flags=(--fail --location) 
		if [[ -n "${rvm_curl_flags[*]}" ]]
		then
			__flags+=("${rvm_curl_flags[@]}") 
		else
			__flags+=(--max-redirs 10 --max-time 1800) 
		fi
		[[ "$*" == *"--max-time"* ]] || [[ "$*" == *"--connect-timeout"* ]] || [[ "${__flags[*]}" == *"--connect-timeout"* ]] || __flags+=(--connect-timeout 30 --retry-delay 2 --retry 3) 
		if [[ -n "${rvm_proxy:-}" ]]
		then
			__flags+=(--proxy "${rvm_proxy:-}") 
		fi
		__rvm_curl_output_control
		unset curl
		__rvm_debug_command ${curl_path}curl "${__flags[@]}" "$@" || return $?
	)
}
__rvm_curl_output_control () {
	if (( ${rvm_quiet_curl_flag:-0} == 1 ))
	then
		__flags+=("--silent" "--show-error") 
	elif [[ " $*" == *" -s"* || " $*" == *" --silent"* ]]
	then
		[[ " $*" == *" -S"* || " $*" == *" -sS"* || " $*" == *" --show-error"* ]] || {
			__flags+=("--show-error") 
		}
	fi
}
__rvm_current_gemset () {
	\typeset current_gemset
	current_gemset="${GEM_HOME:-}" 
	current_gemset="${current_gemset##*${rvm_gemset_separator:-@}}" 
	if [[ "${current_gemset}" == "${GEM_HOME:-}" ]]
	then
		echo ''
	else
		echo "${current_gemset}"
	fi
}
__rvm_custom_separated_array () {
	\typeset IFS
	IFS=$2 
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		eval "$1+=( \${=3} )"
	else
		eval "$1+=( \$3 )"
	fi
}
__rvm_date () {
	\date "$@" || return $?
}
__rvm_db () {
	\typeset value key variable
	key="${1:-}" 
	variable="${2:-}" 
	value="" 
	if [[ -f "$rvm_user_path/db" ]]
	then
		value="$( __rvm_db_ "$rvm_user_path/db"   "$key" )" 
	fi
	if [[ -z "$value" && -f "$rvm_path/config/db" ]]
	then
		value="$( __rvm_db_ "$rvm_path/config/db" "$key" )" 
	fi
	[[ -n "$value" ]] || return 1
	if [[ -n "$variable" ]]
	then
		eval "$variable='$value'"
	else
		echo "$value"
	fi
	true
}
__rvm_db_ () {
	\typeset __db __key __value
	__db="$1" 
	__key="${2%%\?*}" 
	shift 2
	__value="$*" 
	case "${__value}" in
		(unset|delete) __rvm_db_remove "${__db}" "${__key}" ;;
		("") __rvm_db_get "${__db}" "${__key}" ;;
		(*) __rvm_db_add "${__db}" "${__key}" "${__value}" ;;
	esac
}
__rvm_db_add () {
	\typeset __dir="${1%/*}"
	if [[ -f "${1}" ]]
	then
		__rvm_db_remove "${1}" "${2}"
	elif [[ ! -d "${__dir}" ]]
	then
		mkdir -p "${__dir}"
	fi
	printf "%b=%b\n" "$2" "$3" >> "$1"
}
__rvm_db_get () {
	if [[ -f "$1" ]]
	then
		__rvm_sed -n -e "\#^$2=# { s#^$2=##;; p; }" -e '/^$/d' < "$1"
	else
		echo -n ""
	fi
}
__rvm_db_remove () {
	if [[ -f "$1" ]]
	then
		__rvm_sed -e "\#^$2=# d" -e '/^$/d' "$1" > "$1.new"
		\command \mv -f "$1.new" "$1"
	fi
}
__rvm_db_system () {
	\typeset __key __message
	for __key in "${_system_name}_${_system_version}_$1" "${_system_name}_$1" "$1"
	do
		if __rvm_db "${__key}_error" __message
		then
			rvm_error "${__message}"
		fi
		if __rvm_db "${__key}_warn" __message
		then
			rvm_warn "${__message}"
		fi
		if __rvm_db "${__key}" "$2"
		then
			return 0
		fi
	done
	true
}
__rvm_debug_command () {
	rvm_debug "Running($#): $*"
	"$@" || return $?
}
__rvm_detect_debian_major_version_from_codename () {
	case $_system_version in
		(buster*) _system_version="10"  ;;
		(stretch*) _system_version="9"  ;;
		(jessie*) _system_version="8"  ;;
		(wheezy*) _system_version="7"  ;;
		(squeeze*) _system_version="6"  ;;
		(lenny*) _system_version="5"  ;;
		(etch*) _system_version="4"  ;;
		(sarge*) _system_version="3"  ;;
		(woody*) _system_version="3"  ;;
		(potato*) _system_version="2"  ;;
		(slink*) _system_version="2"  ;;
		(hamm*) _system_version="2"  ;;
	esac
}
__rvm_detect_system () {
	unset _system_type _system_name _system_version _system_arch
	export _system_type _system_name _system_version _system_arch
	_system_info="$(command uname -a)" 
	_system_type="unknown" 
	_system_name="unknown" 
	_system_name_lowercase="unknown" 
	_system_version="unknown" 
	_system_arch="$(command uname -m)" 
	case "$(command uname)" in
		(Linux|GNU*) source "$rvm_scripts_path/functions/detect/system_name/lsb_release"
			source "$rvm_scripts_path/functions/detect/system_name/os_release"
			_system_type="Linux" 
			if [[ -f /etc/lsb-release ]] && __rvm_detect_system_from_lsb_release
			then
				:
			elif [[ -f /etc/os-release ]] && __rvm_detect_system_from_os_release
			then
				:
			elif [[ -f /etc/altlinux-release ]]
			then
				_system_name="Arch" 
				_system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)" 
			elif [[ -f /etc/SuSE-release ]]
			then
				_system_name="SuSE" 
				_system_version="$( \command \awk -F'=' '{gsub(/ /,"")} $1~/VERSION/ {version=$2} $1~/PATCHLEVEL/ {patch=$2} END {print version"."patch}' < /etc/SuSE-release )" 
			elif [[ -f /etc/devuan_version ]]
			then
				_system_name="Devuan" 
				_system_version="$(\command \cat /etc/devuan_version | \command \awk -F. '{print $1}' | head -n 1)" 
				_system_arch="$( dpkg --print-architecture )" 
			elif [[ -f /etc/sabayon-release ]]
			then
				_system_name="Sabayon" 
				_system_version="$(\command \cat /etc/sabayon-release | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)" 
			elif [[ -f /etc/gentoo-release ]]
			then
				_system_name="Gentoo" 
				_system_version="base-$(\command \cat /etc/gentoo-release | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)" 
			elif [[ -f /etc/arch-release ]]
			then
				_system_name="Arch" 
				_system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)" 
			elif [[ -f /etc/fedora-release ]]
			then
				_system_name="Fedora" 
				_system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9]+' /etc/fedora-release | head -n 1)" 
			elif [[ -f /etc/oracle-release ]]
			then
				_system_name="Oracle" 
				_system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/oracle-release  | \command \awk -F. '{print $1}' | head -n 1)" 
			elif [[ -f /etc/redhat-release ]]
			then
				_system_name="$( GREP_OPTIONS="" \command \grep -Eo 'CentOS|PCLinuxOS|ClearOS|Mageia|Scientific|ROSA Desktop|OpenMandriva' /etc/redhat-release 2>/dev/null | \command \head -n 1 | \command \sed "s/ //" )" 
				_system_name="${_system_name:-CentOS}" 
				_system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/redhat-release  | \command \awk -F. 'NR==1{print $1}' | head -n 1)" 
				_system_arch="$( uname -m )" 
			elif [[ -f /etc/centos-release ]]
			then
				_system_name="CentOS" 
				_system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/centos-release  | \command \awk -F. '{print $1}' | head -n 1)" 
			elif [[ -f /etc/debian_version ]]
			then
				_system_name="Debian" 
				_system_version="$(\command \cat /etc/debian_version | \command \awk -F. '{print $1}' | head -n 1)" 
				_system_arch="$( dpkg --print-architecture )" 
				__rvm_detect_debian_major_version_from_codename
			elif [[ -f /proc/devices ]] && GREP_OPTIONS="" \command \grep -Eo "synobios" /proc/devices > /dev/null
			then
				_system_type="BSD" 
				_system_name="Synology" 
				_system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)" 
			elif [[ "$(command uname -o)" == "Android" ]]
			then
				_system_name="Termux" 
				_system_version="$(command uname -r)" 
			else
				_system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)" 
			fi ;;
		(SunOS) _system_type="SunOS" 
			_system_name="Solaris" 
			_system_version="$(command uname -v)" 
			_system_arch="$(command isainfo -k)" 
			if [[ "${_system_version}" == joyent* ]]
			then
				_system_name="SmartOS" 
				_system_version="${_system_version#* }" 
			elif [[ "${_system_version}" == omnios* ]]
			then
				_system_name="OmniOS" 
				_system_version="${_system_version#* }" 
			elif [[ "${_system_version}" == oi* || "${_system_version}" == illumos* ]]
			then
				_system_name="OpenIndiana" 
				_system_version="${_system_version#* }" 
			elif [[ "${_system_version}" == Generic* ]]
			then
				_system_version="10" 
			elif [[ "${_system_version}" == *11* ]]
			then
				_system_version="11" 
			fi ;;
		(FreeBSD) _system_type="BSD" 
			_system_name="FreeBSD" 
			_system_version="$(command uname -r)" 
			_system_version="${_system_version%%-*}"  ;;
		(OpenBSD) _system_type="BSD" 
			_system_name="OpenBSD" 
			_system_version="$(command uname -r)"  ;;
		(DragonFly) _system_type="BSD" 
			_system_name="DragonFly" 
			_system_version="$(command uname -r)" 
			_system_version="${_system_version%%-*}"  ;;
		(NetBSD) _system_type="BSD" 
			_system_name="NetBSD" 
			_system_version_full="$(command uname -r)" 
			_system_version="$(echo ${_system_version_full} | \command \awk -F. '{print $1"."$2}')"  ;;
		(Darwin) _system_type="Darwin" 
			_system_name="OSX" 
			_system_version="$(sw_vers -productVersion | \command \awk -F. '{print $1"."$2}')"  ;;
		(CYGWIN*) _system_type="Windows" 
			_system_name="Cygwin"  ;;
		(MINGW*) _system_type="Windows" 
			_system_name="Mingw"  ;;
		(*) return 1 ;;
	esac
	_system_type="${_system_type//[ \/]/_}" 
	_system_name="${_system_name//[ \/]/_}" 
	_system_name_lowercase="$(echo ${_system_name} | \command \tr '[A-Z]' '[a-z]')" 
	_system_version="${_system_version//[ \/]/_}" 
	_system_arch="${_system_arch//[ \/]/_}" 
	_system_arch="${_system_arch/amd64/x86_64}" 
	_system_arch="${_system_arch/i[123456789]86/i386}" 
}
__rvm_detect_system_override () {
	\typeset _var
	for _var in system_type system_name system_name_lowercase system_version system_arch
	do
		__rvm_db ${_var} _${_var}
	done
}
__rvm_display_rvmrc () {
	__rvm_file_notice_display_pre
	__rvm_wait_anykey "(( press a key to review the ${_rvmrc_base} file ))"
	printf "%b" "${rvm_warn_clr}"
	command cat -v "${_rvmrc}"
	printf "%b" "${rvm_reset_clr}"
	__rvm_file_notice_display_post
}
__rvm_do_with_env () {
	\typeset result
	__rvm_do_with_env_before
	"$@"
	result=$? 
	__rvm_do_with_env_after
	return ${result:-0}
}
__rvm_do_with_env_after () {
	__rvm_teardown
}
__rvm_do_with_env_before () {
	if [[ -n "${rvm_scripts_path:-}" || -n "${rvm_path:-}" ]]
	then
		source "${rvm_scripts_path:-"$rvm_path/scripts"}/initialize"
		__rvm_setup
	fi
}
__rvm_dotted () {
	set +x
	\typeset flush
	if (( $# ))
	then
		printf "%b" "${rvm_notify_clr:-}$*${rvm_reset_clr:-}"
	fi
	if __rvm_awk '{fflush;}' <<< EO 2> /dev/null
	then
		flush=fflush 
	else
		flush=flush 
	fi
	awk -v go_back="$( tput cub1 2>/dev/null || true)" '
  BEGIN{
    spin[0]="|"go_back;
    spin[1]="/"go_back;
    spin[2]="-"go_back;
    spin[3]="\\"go_back }
  {
    if ((NR-1)%(10)==9)
      printf ".";
    else
      if (go_back!="") printf spin[(NR-1)%4];
    '${flush}' }
  END{
    print "." }
  '
}
__rvm_ensure_has_environment_files () {
	\typeset file_name variable value environment_id __path __gem_home
	__gem_home="${rvm_ruby_gem_home}" 
	file_name="${__gem_home}/environment" 
	__path="" 
	if [[ "${__gem_home##*@}" != "global" ]]
	then
		__path+="${__gem_home}/bin:" 
	fi
	__path+="${rvm_ruby_global_gems_path}/bin:${rvm_ruby_home}/bin" 
	\command \rm -f "$file_name"
	\command \mkdir -p "${__gem_home}/wrappers" "${rvm_environments_path}" "${rvm_wrappers_path}"
	printf "%b" "export PATH=\"${__path}:\$PATH\"\n" > "$file_name"
	for variable in GEM_HOME GEM_PATH MY_RUBY_HOME IRBRC MAGLEV_HOME RBXOPT RUBY_VERSION
	do
		eval "value=\${${variable}:-""}"
		if [[ -n "$value" ]]
		then
			printf "export %b='%b'\n" "${variable}" "${value}" >> "$file_name"
		else
			printf "unset %b\n" "${variable}" >> "$file_name"
		fi
	done
	environment_id="${__gem_home##*/}" 
	[[ -L "${rvm_environments_path}/${environment_id}" ]] || {
		if [[ -f "${rvm_environments_path}/${environment_id}" ]]
		then
			rm -rf "${rvm_environments_path}/${environment_id}"
		fi
		ln -nfs "${__gem_home}/environment" "${rvm_environments_path}/${environment_id}"
	}
	ln -nfs "${__gem_home}/wrappers" "$rvm_wrappers_path/${environment_id}"
	return 0
}
__rvm_ensure_is_a_function () {
	if [[ ${rvm_reload_flag:=0} == 1 ]] || ! is_a_function rvm
	then
		for script in functions/version functions/selector cd functions/cli cli override_gem
		do
			if [[ -f "$rvm_scripts_path/$script" ]]
			then
				source "$rvm_scripts_path/$script"
			else
				printf "%b" "WARNING:
        Could not source '$rvm_scripts_path/$script' as file does not exist.
        RVM will likely not work as expected.\n"
			fi
		done
	fi
}
__rvm_env_file_notice_display_post () {
	__rvm_table "Viewing of ${_rvmrc} complete." <<TEXT
Trusting an ${_rvmrc_base} file means that whenever you cd into this directory, RVM will export environment variables from ${_rvmrc_base}.
Note that if the contents of the file change, you will be re-prompted to review the file and adjust its trust settings. You may also change the trust settings manually at any time with the 'rvm rvmrc' command.
TEXT
}
__rvm_env_file_notice_initial () {
	__rvm_table "NOTICE" <<TEXT
RVM has encountered a new or modified ${_rvmrc_base} file in the current directory, environment variables from this file will be exported and therefore may influence your shell.

Examine the contents of this file carefully to be sure the contents are safe before trusting it!
Do you wish to trust '${_rvmrc}'?
Choose v[iew] below to view the contents
TEXT
}
__rvm_env_print () {
	environment_file_path="$rvm_environments_path/$(__rvm_env_string)" 
	if [[ "$rvm_path_flag" == "1" || "$*" == *"--path"* ]]
	then
		echo "$environment_file_path"
	elif [[ "$rvm_cron_flag" == "1" || "$*" == *"--cron"* ]]
	then
		\command \cat "$environment_file_path" | __rvm_grep -Eo "[^ ]+=[^;]+" | __rvm_sed -e 's/\$PATH/'"${PATH//\//\\/}"'/' -e 's/\${PATH}/'"${PATH//\//\\/}"'/'
	else
		\command \cat "$environment_file_path"
	fi
}
__rvm_env_string () {
	\typeset _string
	_string="${GEM_HOME:-}" 
	_string="${_string##*/}" 
	printf "%b" "${_string:-system}\n"
}
__rvm_expand_ruby_string () {
	\typeset string current_ruby
	string="$1" 
	case "${string:-all}" in
		(all) __rvm_list_strings | \command \tr ' ' "\n" ;;
		(all-gemsets) __rvm_list_gemset_strings ;;
		(default-with-rvmrc | rvmrc) "$rvm_scripts_path/tools" path-identifier "$PWD" ;;
		(all-rubies | rubies) __rvm_list_strings ;;
		(current-ruby | gemsets) current_ruby="$(__rvm_env_string)" 
			current_ruby="${current_ruby%@*}" 
			rvm_silence_logging=1 "$rvm_scripts_path/gemsets" list strings | __rvm_sed "s/ (default)//; s/^/$current_ruby${rvm_gemset_separator:-@}/ ; s/@default// ;" ;;
		(current) __rvm_env_string ;;
		(aliases) __rvm_awk -F= '{print $string}' < "$rvm_path/config/alias" ;;
		(*) __rvm_ruby_strings_exist $( echo "$string" | \command \tr "," "\n" | __rvm_strip ) ;;
	esac
}
__rvm_export () {
	\typeset name
	name=${1%%\=*} 
	builtin export rvm_old_$name=${!name}
	export "$@"
	return $?
}
__rvm_file_env_check_unload () {
	if (( ${#rvm_saved_env[@]} > 0 ))
	then
		__rvm_set_env "" "${rvm_saved_env[@]}"
	fi
	rvm_saved_env=() 
}
__rvm_file_load_env () {
	\typeset -a __sed_commands
	__sed_commands=() 
	if [[ -n "${2:-}" ]]
	then
		__sed_commands+=(-e "/^$2/ !d" -e "s/^$2//") 
	else
		__sed_commands+=(-e "/^#/ d" -e "/^$/ d") 
	fi
	__rvm_read_lines __file_env_variables <( { cat "$1"; echo ""; } | __rvm_sed "${__sed_commands[@]}" )
}
__rvm_file_load_env_and_trust () {
	[[ -f "$1" ]] || return 0
	__rvm_file_load_env "$1" "${2:-}"
	if (( ${#__file_env_variables[@]} == 0 )) || __rvm_check_rvmrc_trustworthiness "$1"
	then
		true
	else
		rvm_debug "Envirionment variables variables from '$1' wont be loaded because of lack of trust (status=$?)."
		__file_env_variables=() 
	fi
}
__rvm_file_notice_display_post () {
	case "${_rvmrc}" in
		(*/.rvmrc) __rvm_rvmrc_notice_display_post ;;
		(*) __rvm_env_file_notice_display_post ;;
	esac
}
__rvm_file_notice_display_pre () {
	__rvm_table <<TEXT
The contents of the ${_rvmrc_base} file will now be displayed.
After reading the file, you will be prompted again for 'yes or no' to set the trust level for this particular version of the file.

Note: You will be re-prompted each time the ${_rvmrc_base} file's contents change
changes, and may change the trust setting manually at any time.
TEXT
}
__rvm_file_notice_initial () {
	case "${_rvmrc}" in
		(*/.rvmrc) __rvm_rvmrc_notice_initial ;;
		(*) __rvm_env_file_notice_initial ;;
	esac
}
__rvm_file_set_env () {
	__rvm_file_env_check_unload
	__rvm_set_env "rvm_saved_env" "${__file_env_variables[@]}"
}
__rvm_find () {
	\find "$@" || return $?
}
__rvm_find_first_file () {
	\typeset _first_file _variable_first_file __file_enum
	_first_file="" 
	_variable_first_file="$1" 
	shift
	for __file_enum in "$@"
	do
		if [[ -f "$__file_enum" ]]
		then
			eval "$_variable_first_file=\"\$__file_enum\""
			return 0
		fi
	done
	eval "$_variable_first_file=\"\""
	return 1
}
__rvm_fix_group_permissions () {
	if \umask -S | __rvm_grep 'g=rw' > /dev/null
	then
		chmod -R g+rwX "$@"
	fi
}
__rvm_fix_path_from_gem_path () {
	[[ -n "${GEM_PATH:-}" ]] || return 0
	export PATH
	\typeset IFS _iterator_path
	\typeset -a _gem_path _new_path
	IFS=: 
	_gem_path=() 
	_new_path=() 
	__rvm_custom_separated_array _gem_path : "${GEM_PATH}"
	for _iterator_path in "${_gem_path[@]}"
	do
		_new_path+=("${_iterator_path}/bin") 
	done
	_new_path+=("${MY_RUBY_HOME:-${GEM_HOME/gems/rubies}}/bin") 
	_new_path+=("${rvm_bin_path}") 
	PATH="${_new_path[*]}:$PATH" 
	builtin hash -r
}
__rvm_fix_selected_ruby () {
	\typeset __ret=0
	if (( $# ))
	then
		"$@" || __ret=$? 
	fi
	[[ -d "$GEM_HOME" && -d "$MY_RUBY_HOME" ]] || {
		if [[ -d ${MY_RUBY_HOME%/*}/defaul ]]
		then
			__rvm_use default
		else
			__rvm_use system
		fi
	}
}
__rvm_fold () {
	if fold -s -w 10 <<< bla > /dev/null
	then
		fold -s -w $1
	else
		fold -w $1
	fi
}
__rvm_gemset_handle_default () {
	rvm_gemset_name="${rvm_gemset_separator:-@}${rvm_gemset_name:-}${rvm_gemset_separator:-@}" 
	rvm_gemset_name="${rvm_gemset_name/${rvm_gemset_separator:-@}default${rvm_gemset_separator:-@}/}" 
	rvm_gemset_name="${rvm_gemset_name//${rvm_gemset_separator:-@}/}" 
}
__rvm_gemset_pristine () {
	__rvm_log_command "gemset.pristine-$1" "Making gemset $1 pristine" __rvm_with "$1" gemset_pristine
}
__rvm_gemset_select () {
	__rvm_gemset_select_only && __rvm_gemset_select_validation || return $?
}
__rvm_gemset_select_cli () {
	__rvm_gemset_select_cli_validation && __rvm_gemset_select || return $?
}
__rvm_gemset_select_cli_validation () {
	\typeset orig_gemset
	if ! builtin command -v gem > /dev/null
	then
		rvm_log "'gem' command not found, cannot select a gemset."
		return 0
	fi
	orig_gemset="${rvm_gemset_name:-}" 
	__rvm_gemset_handle_default
	if [[ -z "${rvm_gemset_name:-}" && "$orig_gemset" != "default" && ${rvm_sticky_flag:-0} -eq 1 ]]
	then
		if [[ -n "${rvm_ruby_gem_home:-}" ]]
		then
			rvm_gemset_name="$rvm_ruby_gem_home" 
		elif [[ -n "${GEM_HOME:-}" ]]
		then
			rvm_gemset_name="$GEM_HOME" 
		fi
		rvm_gemset_name="${rvm_gemset_name##*/}" 
		rvm_gemset_name="${rvm_gemset_name#*${rvm_gemset_separator:-"@"}}" 
	fi
	if [[ -z "${rvm_ruby_string:-}" && -n "${GEM_HOME:-}" && -n "${GEM_HOME%@*}" ]]
	then
		rvm_ruby_string="${GEM_HOME%@*}" 
		rvm_ruby_string="${rvm_ruby_string##*/}" 
	fi
	if [[ -z "${rvm_ruby_string:-}" ]]
	then
		rvm_error "Gemsets can not be used with non rvm controlled rubies (currently)."
		return 3
	fi
}
__rvm_gemset_select_only () {
	rvm_ruby_gem_home="${rvm_gems_path:-"$rvm_path/gems"}/$rvm_ruby_string" 
	: rvm_ignore_gemsets_flag:${rvm_ignore_gemsets_flag:=0}:
	if (( rvm_ignore_gemsets_flag ))
	then
		rvm_ruby_global_gems_path="${rvm_ruby_gem_home}" 
		rvm_ruby_gem_path="${rvm_ruby_gem_home}" 
		rvm_gemset_name="" 
	else
		rvm_ruby_global_gems_path="${rvm_ruby_gem_home}${rvm_gemset_separator:-"@"}global" 
		__rvm_gemset_handle_default
		[[ -z "$rvm_gemset_name" ]] || rvm_ruby_gem_home="${rvm_ruby_gem_home}${rvm_gemset_separator:-"@"}${rvm_gemset_name}" 
		if [[ "$rvm_gemset_name" == "global" ]]
		then
			rvm_ruby_gem_path="${rvm_ruby_gem_home}" 
		else
			rvm_ruby_gem_path="${rvm_ruby_gem_home}:${rvm_ruby_global_gems_path}" 
		fi
	fi
	if [[ -n "${rvm_gemset_name}" ]]
	then
		rvm_env_string="${rvm_ruby_string}@${rvm_gemset_name}" 
	else
		rvm_env_string=${rvm_ruby_string} 
	fi
	true
}
__rvm_gemset_select_validation () {
	if [[ ! -d "${rvm_ruby_gem_home}" ]]
	then
		if (( ${rvm_gemset_create_on_use_flag:=0} == 0 && ${rvm_create_flag:=0} == 0 && ${rvm_delete_flag:=0} == 0 ))
		then
			rvm_expected_gemset_name="${rvm_gemset_name}" 
			rvm_gemset_name="" 
			__rvm_gemset_select_only
			return 2
		fi
	elif (( ${rvm_delete_flag:=0} == 1 ))
	then
		return 4
	fi
	case "${rvm_gemset_name}" in
		(*/*) rvm_error "Gemsets can not contain path separator '/'."
			return 5 ;;
		(*:*) rvm_error "Gemsets can not contain PATH separator ':'."
			return 5 ;;
	esac
	\typeset rvm_ruby_gem_home_254
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		rvm_ruby_gem_home_254="${rvm_ruby_gem_home[0,254]}" 
	else
		rvm_ruby_gem_home_254="${rvm_ruby_gem_home:0:254}" 
	fi
	if [[ "${rvm_ruby_gem_home}" != "${rvm_ruby_gem_home_254}" ]]
	then
		rvm_error "Gemset gem home to long ${#rvm_ruby_gem_home}."
		return 6
	fi
}
__rvm_gemset_use () {
	if [[ "$(__rvm_env_string)" == "system" ]]
	then
		rvm_error "System ruby is not controlled by RVM, but you can use it with 'rvm automount', read more: 'rvm help mount'."
		return 2
	elif __rvm_gemset_select_cli
	then
		rvm_log "Using $rvm_ruby_string with gemset ${rvm_gemset_name:-default}"
		__rvm_use
	elif [[ -n "${rvm_expected_gemset_name}" ]]
	then
		__rvm_gemset_use_ensure
	else
		rvm_error "Gemset was not given.\n  Usage:\n    rvm gemset use <gemsetname>\n"
		return 1
	fi
}
__rvm_gemset_use_ensure () {
	if [[ ! -d "$rvm_ruby_gem_home" ]] || [[ -n "${rvm_expected_gemset_name}" && ! -d "${rvm_ruby_gem_home%@*}@${rvm_expected_gemset_name}" ]]
	then
		if (( ${rvm_gemset_create_on_use_flag:=0} == 1 || ${rvm_create_flag:=0} == 1 ))
		then
			gemset_create "${rvm_expected_gemset_name:-${rvm_gemset_name:-}}"
		else
			rvm_error "Gemset '${rvm_expected_gemset_name:-${rvm_gemset_name:-}}' does not exist, 'rvm $rvm_ruby_string do rvm gemset create ${rvm_expected_gemset_name:-${rvm_gemset_name:-}}' first, or append '--create'."
			return 2
		fi
	fi
}
__rvm_get_user_shell () {
	case "${_system_type}:${_system_name}" in
		(Linux:*|SunOS:*|BSD:*|Windows:Cygwin) __shell="$( getent passwd $USER )"  || {
				rvm_error "Error checking user shell via getent ... something went wrong, report a bug."
				return 2
			}
			echo "${__shell##*:}" ;;
		(Windows:Mingw) __shell="$( echo $SHELL )"  || {
				rvm_error "Error checking user shell from echo $SHELL ... something went wrong, report a bug."
				return 2
			}
			echo "${__shell##*:}" ;;
		(Darwin:*) \typeset __version
			__version="$(dscl localhost -read "/Search/Users/$USER" UserShell)"  || {
				rvm_error "Error checking user shell via dscl ... something went wrong, report a bug."
				return 3
			}
			echo ${__version#*: } ;;
		(*) rvm_error "Do not know how to check user shell on '$(command uname)'."
			return 1 ;;
	esac
}
__rvm_grep () {
	GREP_OPTIONS="" \command \grep "$@" || return $?
}
__rvm_has_opt () {
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		setopt | GREP_OPTIONS="" \command \grep "^${1:-}$" > /dev/null 2>&1 || return $?
	elif [[ -n "${KSH_VERSION:-}" ]]
	then
		set +o | GREP_OPTIONS="" \command \grep "-o ${1:-}$" > /dev/null 2>&1 || return $?
	elif [[ -n "${BASH_VERSION:-}" ]]
	then
		[[ ":${SHELLOPTS:-}:" == *":${1:-}:"* ]] || return $?
	else
		return 1
	fi
}
__rvm_include_travis_binaries () {
	if [[ $rvm_remote_server_url == *"travis"* && $TRAVIS != true && $_system_name_lowercase == "osx" ]]
	then
		rvm_debug "Travis binaries for OSX are not movable and can't be used outside of Travis environment. Skip that source."
		return 1
	fi
	return 0
}
__rvm_initial_gemsets_create () {
	__rvm_initial_gemsets_setup "$1" && __rvm_initial_gemsets_create_gemsets
}
__rvm_initial_gemsets_create_gemsets () {
	gemset_create "global" && __rvm_with "${rvm_ruby_string}@global" __rvm_remove_without_gems && gemset_create ""
}
__rvm_initial_gemsets_create_without_rubygems () {
	__rvm_rubygems_create_link "$1" && __rvm_initial_gemsets_create_gemsets
}
__rvm_initial_gemsets_setup () {
	__rvm_log_command "chmod.bin" "$rvm_ruby_string - #making binaries executable" __rvm_set_executable "$rvm_ruby_home/bin"/* && __rvm_rubygems_create_link "$1" && (
		rvm_ruby_binary="${1:-$rvm_ruby_home/bin/ruby}" rubygems_setup ${rvm_rubygems_version:-latest}
	)
}
__rvm_initialize () {
	true ${rvm_scripts_path:="$rvm_path/scripts"}
	export rvm_scripts_path
	source "$rvm_scripts_path/base"
	__rvm_conditionally_add_bin_path
	export PATH
	[[ -d "${rvm_tmp_path:-/tmp}" ]] || command mkdir -p "${rvm_tmp_path}"
	return 0
}
__rvm_join_array () {
	\typeset IFS
	IFS="$2" 
	eval "$1=\"\${$3[*]}\""
}
__rvm_libtoolize () {
	\libtoolize "$@" || return $?
}
__rvm_lines_with_gems () {
	\typeset -a __gems_to_add
	__gems_to_add=() 
	case "${1}" in
		(global) __rvm_custom_separated_array __gems_to_add " " "${rvm_with_gems:-}" ;;
		(default) __rvm_custom_separated_array __gems_to_add " " "${rvm_with_default_gems:-}" ;;
		(*) return 0 ;;
	esac
	(( ${#__gems_to_add[@]} )) || return 0
	\typeset __gem __version
	for __gem in "${__gems_to_add[@]}"
	do
		__version="${__gem#*=}" 
		__gem="${__gem%%=*}" 
		if [[ "${__gem}" == "${__version}" ]]
		then
			lines+=("${__gem}") 
		else
			lines+=("${__gem} -v ${__version}") 
		fi
	done
}
__rvm_lines_without_comments () {
	__rvm_remove_from_array lines "#*|+( )" "${lines[@]}"
}
__rvm_lines_without_gems () {
	[[ -n "${rvm_without_gems}" ]] || return 0
	\typeset -a __gems_to_remove
	__gems_to_remove=() 
	__rvm_custom_separated_array __gems_to_remove " " "${rvm_without_gems}"
	(( ${#__gems_to_remove[@]} )) || return 0
	\typeset __gem
	for __gem in "${__gems_to_remove[@]}"
	do
		__rvm_remove_from_array lines "${__gem}|${__gem% *} *" "${lines[@]}"
	done
}
__rvm_list_gems () {
	\typeset __checks __names
	__checks="${1:-}" 
	shift || true
	__names="$*" 
	if [[ -n "${__names}" ]]
	then
		__checks="%w{${__names}}.include?(gem.name)${__checks:+" && ( ${__checks} )"}" 
	fi
	if [[ -n "${__checks}" ]]
	then
		__checks="if ${__checks}" 
	fi
	rvm_debug "gem list check: ${__checks}"
	ruby -rrubygems -e "
    Gem::Specification.each{|gem|
      puts \"#{gem.name} #{gem.version}\" ${__checks}
    }
  " 2> /dev/null || gem list $@ | __rvm_sed '/\*\*\*/ d ; /^$/ d; s/ (/,/; s/, /,/g; s/)//;' | __rvm_awk -F ',' '{for(i=2;i<=NF;i++) print $1" "$i }'
}
__rvm_list_gemset_strings () {
	\typeset all_rubies ruby_name gemset
	all_rubies="$(__rvm_list_strings | tr "\n" ":")" 
	for gemset in "${rvm_gems_path:-"$rvm_path/gems"}"/*
	do
		case "$gemset" in
			(*/\*|@*|doc|cache|system) continue ;;
		esac
		ruby_name="${gemset%%@*}" 
		ruby_name="${ruby_name##*/}" 
		case ":$all_rubies" in
			(*:${ruby_name}:*) true ;;
			(*) continue ;;
		esac
		echo "${gemset##*/}"
	done | sort
	return 0
}
__rvm_list_known_strings () {
	__rvm_sed -e 's/#.*$//g' -e 's#\[##g' -e 's#\]##g' < "$rvm_path/config/known" | sort -r | uniq
	return $?
}
__rvm_list_strings () {
	__rvm_find "$rvm_rubies_path" -mindepth 1 -maxdepth 1 -type d | __rvm_awk -F'/' '{print $NF}'
}
__rvm_load_environment () {
	\typeset __hook
	if [[ -f "$rvm_environments_path/$1" ]]
	then
		unset GEM_HOME GEM_PATH
		__rvm_remove_rvm_from_path
		__rvm_conditionally_add_bin_path
		\. "$rvm_environments_path/$1"
		rvm_hook="after_use" 
		if [[ -n "${rvm_scripts_path:-}" || -n "${rvm_path:-}" ]]
		then
			source "${rvm_scripts_path:-$rvm_path/scripts}/hook"
		fi
		builtin hash -r
	else
		__rvm_use "$1"
	fi
}
__rvm_load_project_config () {
	rvm_debug "__rvm_load_project_config $1"
	\typeset __gemfile _bundle_install
	\typeset -a __file_env_variables
	__file_env_variables=() 
	__gemfile="" 
	rvm_previous_environment="$(__rvm_env_string)" 
	: rvm_autoinstall_bundler_flag:${rvm_autoinstall_bundler_flag:=0}
	case "$1" in
		(*/.rvmrc) __rvmrc_warning_display_for_rvmrc "$1"
			if __rvm_check_rvmrc_trustworthiness "$1"
			then
				__rvm_remove_rvm_from_path
				__rvm_conditionally_add_bin_path
				rvm_current_rvmrc="$1" 
				__rvm_ensure_is_a_function
				unset GEM_HOME GEM_PATH
				rvm_ruby_string="${rvm_previous_environment/system/default}" rvm_action=use source "$1" || return $?
			else
				return $?
			fi ;;
		(*/.versions.conf) __rvm_ensure_is_a_function
			rvm_current_rvmrc="$1" 
			rvm_ruby_string="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^ruby=/ {s/ruby=//;p;}' | tail -n 1 )" 
			[[ -n "${rvm_ruby_string}" ]] || return 2
			rvm_gemset_name="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^ruby-gemset=/ {s/ruby-gemset=//;p;}' | tail -n 1 )" 
			rvm_create_flag=1 __rvm_use || return 3
			__rvm_file_load_env_and_trust "$1" "env-"
			_bundle_install="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^ruby-bundle-install=/ {s/ruby-bundle-install=//;p;}' )" 
			if [[ -n "${_bundle_install}" ]]
			then
				if [[ -f "${_bundle_install}" ]]
				then
					__gemfile="${_bundle_install}" 
				else
					__gemfile="${1%/*}/Gemfile" 
				fi
			fi ;;
		(*/Gemfile) __rvm_ensure_is_a_function
			rvm_current_rvmrc="$1" 
			rvm_ruby_string="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^#ruby=/ {s/#ruby=//;p;}' | tail -n 1 )" 
			[[ -n "${rvm_ruby_string}" ]] || {
				rvm_ruby_string="$(
          \command \tr -d '\r' <"$1" |
          __rvm_sed -n "s/[[:space:]]+rescue[[:space:]]+nil$//; /^\s*ruby[[:space:](]/ {s/^\s*ruby//; s/[[:space:]()'\"]//g; p;}" |
          \tail -n 1
        )" 
				[[ -n "${rvm_ruby_string}" ]] || return 2
				rvm_ruby_string="${rvm_ruby_string%%\#*}" 
				rvm_ruby_string="${rvm_ruby_string/,:engine=>/-}" 
				rvm_ruby_string="${rvm_ruby_string/,engine:/-}" 
				rvm_ruby_string="${rvm_ruby_string/,:engine_version=>[^,]*/}" 
				rvm_ruby_string="${rvm_ruby_string/,engine_version:[^,]*/}" 
				rvm_ruby_string="${rvm_ruby_string/,:patchlevel=>/-p}" 
				rvm_ruby_string="${rvm_ruby_string/,patchlevel:/-p}" 
			}
			rvm_gemset_name="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^#ruby-gemset=/ {s/#ruby-gemset=//;p;}' | tail -n 1 )" 
			if [[ -z "${rvm_gemset_name:-}" && -f "${1%/*}/.ruby-gemset" ]]
			then
				rvm_gemset_name="$( \command \tr -d '\r' <"${1%/*}/.ruby-gemset" )" 
			fi
			__rvmrc_warning_display_for_Gemfile "$1"
			rvm_create_flag=1 __rvm_use || return 3
			__rvm_file_load_env_and_trust "$1" "#ruby-env-"
			__gemfile="$1"  ;;
		(*/.ruby-version|*/.rbfu-version|*/.rbenv-version) __rvm_ensure_is_a_function
			rvm_current_rvmrc="$1" 
			rvm_ruby_string="$( \command \tr -d '\r' <"$1" )" 
			if [[ -z "${rvm_ruby_string}" ]]
			then
				return 2
			fi
			if [[ -f "${1%/*}/.ruby-gemset" ]]
			then
				rvm_gemset_name="$( \command \tr -d '\r' <"${1%/*}/.ruby-gemset" )" 
			else
				rvm_gemset_name="" 
			fi
			rvm_create_flag=1 __rvm_use || return 3
			__rvm_file_load_env_and_trust "${1%/*}/.ruby-env"
			__rvm_file_load_env_and_trust "${1%/*}/.rbenv-vars"
			__gemfile="${1%/*}/Gemfile"  ;;
		(*) rvm_error "Unsupported file format for '$1'"
			return 1 ;;
	esac
	__rvm_file_set_env
	if [[ "${rvm_autoinstall_bundler_flag:-0}" == 1 && -n "${__gemfile:-}" && -f "${__gemfile:-}" ]]
	then
		__rvm_which bundle > /dev/null 2>&1 || gem install --remote bundler
		bundle install --gemfile="${__gemfile}" | __rvm_grep -vE '^Using|Your bundle is complete'
	fi
}
__rvm_load_rvmrc () {
	\typeset _file
	\typeset -a rvm_rvmrc_files
	if (( ${rvm_ignore_rvmrc:=0} == 1 ))
	then
		return 0
	fi
	[[ -n "${rvm_stored_umask:-}" ]] || export rvm_stored_umask=$(umask) 
	rvm_rvmrc_files=("/etc/rvmrc" "$HOME/.rvmrc") 
	if [[ -n "${rvm_prefix:-}" ]] && ! [[ "$HOME/.rvmrc" -ef "${rvm_prefix}/.rvmrc" ]]
	then
		rvm_rvmrc_files+=("${rvm_prefix}/.rvmrc") 
	fi
	for _file in "${rvm_rvmrc_files[@]}"
	do
		if [[ -s "$_file" ]]
		then
			if __rvm_grep '^\s*rvm .*$' "$_file" > /dev/null 2>&1
			then
				rvm_error "
$_file is for rvm settings only.
rvm CLI may NOT be called from within $_file.
Skipping the loading of $_file
"
				return 1
			else
				source "$_file"
			fi
		fi
	done
	return 0
}
__rvm_log_command () {
	\typeset name message _command_start _command_name
	\typeset -a _command
	name="${1:-}" 
	message="${2:-}" 
	shift 2
	_command=("$@") 
	_command_start="$1" 
	while (( $# )) && [[ "$1" == *"="* ]]
	do
		shift
	done
	_command_name="$1" 
	[[ "${_command_start}" != *"="* ]] || _command=("env" "${_command[@]}") 
	if __function_on_stack __rvm_log_command_internal
	then
		__rvm_log_command_simple "$@" || return $?
	else
		__rvm_log_command_internal "$@" || return $?
	fi
}
__rvm_log_command_caclulate_log_file_name () {
	[[ -n "${rvm_log_timestamp:-}" ]] || __rvm_log_command_caclulate_log_timestamp
	[[ -n "${rvm_log_filesystem:-}" ]] || __rvm_log_command_caclulate_log_filesystem
	[[ -n "${rvm_log_namelen:-}" ]] || __rvm_log_command_caclulate_log_namelen
	name="${name//[ \/]/_}" 
	_log="${rvm_log_path}/${rvm_log_timestamp}${rvm_ruby_string:+_}${rvm_ruby_string:-}/${name}" 
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		_log="${_log[0,${rvm_log_namelen}]}.log" 
	else
		_log="${_log:0:${rvm_log_namelen}}.log" 
	fi
}
__rvm_log_command_caclulate_log_filesystem () {
	export rvm_log_filesystem="$(
    __rvm_mount 2>/dev/null | __rvm_awk -v rvm_path=$rvm_path '
      BEGIN{longest=""; fstype=""}
      {if (index(rvm_path,$3)==1 && length($3)>length(longest)){longest=$3; fstype=$5}}
      END{print fstype}
    '
  )" 
	rvm_debug "Log filesystem: ${rvm_log_filesystem}"
}
__rvm_log_command_caclulate_log_namelen () {
	case "${rvm_log_filesystem}" in
		(ecryptfs) export rvm_log_namelen=138  ;;
		(*) export rvm_log_namelen=250  ;;
	esac
	rvm_debug "Log max name length: ${rvm_log_namelen}"
}
__rvm_log_command_caclulate_log_timestamp () {
	export rvm_log_timestamp="$(__rvm_date "+%s")" 
	rvm_debug "Log prefix: ${rvm_log_path}/${rvm_log_timestamp}${rvm_ruby_string:+_}${rvm_ruby_string:-}/"
}
__rvm_log_command_debug () {
	printf "%b" "[$(__rvm_date +'%Y-%m-%d %H:%M:%S')] ${_command_name}\n"
	if is_a_function "${_command_name}"
	then
		\typeset -f "${_command_name}"
	fi
	printf "%b" "current path: $PWD\n"
	env | __rvm_grep -E '^GEM_HOME=|^GEM_PATH=|^PATH='
	printf "%b" "command(${#_command[@]}): ${_command[*]}\n"
}
__rvm_log_command_internal () {
	\typeset _log
	(( ${rvm_niceness:-0} == 0 )) || _command=(nice -n $rvm_niceness "${_command[@]}") 
	__rvm_log_command_caclulate_log_file_name
	rvm_debug "Log file: ${_log}"
	[[ -d "${_log%\/*}" ]] || \command \mkdir -p "${_log%\/*}"
	[[ -f "${_log}" ]] || \command \rm -f "${_log}"
	__rvm_log_command_debug | tee "${_log}" | rvm_debug_stream
	__rvm_log_dotted "${_log}" "$message" "${_command[@]}" || {
		\typeset result=$?
		\typeset __show_lines="${rvm_show_log_lines_on_error:-0}"
		rvm_error "Error running '${_command[*]}',"
		case "${__show_lines}" in
			(0) rvm_error "please read ${_log}" ;;
			(all) rvm_error "content of log ${_log}"
				cat "${_log}" >&6 ;;
			(*) rvm_error "showing last ${__show_lines} lines of ${_log}"
				tail -n "${__show_lines}" "${_log}" >&6 ;;
		esac
		return ${result}
	}
}
__rvm_log_command_simple () {
	__rvm_log_command_debug
	rvm_log "$message"
	"$@" || return $?
}
__rvm_log_dotted () {
	\typeset __log_file __message __iterator __result __local_rvm_trace_flag
	__log_file="$1" 
	__message="$2" 
	shift 2
	__result=0 
	__local_rvm_trace_flag=${rvm_trace_flag:-0} 
	if (( ${rvm_trace_flag:-0} ))
	then
		{
			set -x
			"$@" 2>&1 | tee -a "${__log_file}"
			__rvm_check_pipestatus ${PIPESTATUS[@]} ${pipestatus[@]} || __result=$? 
			(( __local_rvm_trace_flag > 0 )) || set +x
		} >&2
	elif [[ -n "${ZSH_VERSION:-}" ]]
	then
		rvm_log "${__message} - please wait"
		{
			set -x
			"$@" > "${__log_file}" 2>&1 || __result=$? 
			(( __local_rvm_trace_flag > 0 )) || set +x
		} 2> /dev/null
	else
		{
			set -x
			"$@" 2>&1 | tee -a "${__log_file}" | __rvm_dotted "${__message}"
			__rvm_check_pipestatus ${PIPESTATUS[@]} ${pipestatus[@]} || __result=$? 
			(( __local_rvm_trace_flag > 0 )) || set +x
		} 2> /dev/null
	fi
	return $__result
}
__rvm_ls () {
	\command \ls "$@" || return $?
}
__rvm_make () {
	\make "$@" || return $?
}
__rvm_md5_calculate () {
	rvm_debug "Calculate md5 checksum for $@"
	\typeset _sum
	if builtin command -v md5 > /dev/null 2>&1
	then
		_sum=$(md5 "$@") 
		echo ${_sum##* }
		return 0
	elif builtin command -v md5sum > /dev/null 2>&1
	then
		_sum=$(md5sum "$@") 
		echo ${_sum%% *}
		return 0
	elif builtin command -v gmd5sum > /dev/null 2>&1
	then
		_sum=$(gmd5sum "$@") 
		echo ${_sum%% *}
		return 0
	else
		for _path in /usr/gnu/bin /opt/csw/bin /sbin /bin /usr/bin /usr/sbin
		do
			if [[ -x "${_path}/md5" ]]
			then
				_sum=$(${_path}/md5 "$@") 
				echo ${_sum##* }
				return 0
			elif [[ -x "${_path}/md5sum" ]]
			then
				_sum=$(${_path}/md5sum "$@") 
				echo ${_sum%% *}
				return 0
			elif [[ -x "${_path}/gmd5sum" ]]
			then
				_sum=$(${_path}/gmd5sum "$@") 
				echo ${_sum%% *}
				return 0
			fi
		done
	fi
	rvm_error "Neither of md5sum, md5, gmd5sum found in the PATH"
	return 1
}
__rvm_md5_for_contents () {
	if builtin command -v md5 > /dev/null
	then
		md5 | __rvm_awk '{print $1}'
	elif builtin command -v md5sum > /dev/null
	then
		md5sum | __rvm_awk '{print $1}'
	elif builtin command -v openssl > /dev/null
	then
		openssl md5 | __rvm_awk '{print $1}'
	else
		return 1
	fi
	true
}
__rvm_mount () {
	\mount "$@" || return $?
}
__rvm_nuke_rvm_variables () {
	unset rvm_head_flag $(env | __rvm_awk -F= '/^rvm_/{print $1" "}')
}
__rvm_package_create () {
	rvm_debug __rvm_package_create:$#: "$@"
	case "$1" in
		(*.tar.bz2) if [[ -z "${3:-}" ]]
			then
				__rvm_tar cjf "$1" "$2"
			else
				__rvm_tar cjf "$1" -C "$2" "$3"
			fi ;;
		(*.tar.gz | *.tgz) if [[ -z "${3:-}" ]]
			then
				__rvm_tar czf "$1" "$2"
			else
				__rvm_tar czf "$1" -C "$2" "$3"
			fi ;;
		(*) return 199 ;;
	esac
}
__rvm_package_extract () {
	rvm_debug __rvm_package_extract:$#: "$@"
	\typeset __extract_src __extract_target __tempdir __path __file __return
	__extract_src="$1" 
	__extract_target="$2" 
	shift 2
	__return=0 
	__tempdir="$( TMPDIR="${rvm_tmp_path}" mktemp -d -t rvm-tmp.XXXXXXXXX )" 
	__rvm_package_extract_run "$__extract_src" "$__tempdir" "$@" || __return=$? 
	if (( __return == 0 ))
	then
		for __path in "$__tempdir"/*
		do
			__file="${__path##*/}" 
			if [[ -n "${__file}" && -e "$__extract_target/${__file}" ]]
			then
				\command \rm -rf "$__extract_target/${__file}" || __return=$? 
			fi
			\command \mv -f "${__path}" "$__extract_target/" || __return=$? 
		done
	fi
	if [[ -n "$__tempdir" ]]
	then
		\command \rm -rf "$__tempdir"
	fi
	return $__return
}
__rvm_package_extract_run () {
	\typeset __extract_run_src __extract_run_target __exclude_elements
	__extract_run_src="$1" 
	__extract_run_target="$2" 
	shift 2
	__exclude_elements=() 
	if [[ " ${rvm_tar_options:-} " != *" --no-same-owner "* ]] && __rvm_tar --help 2>&1 | __rvm_grep -- --no-same-owner > /dev/null
	then
		rvm_tar_options="${rvm_tar_options:-}${rvm_tar_options:+ }--no-same-owner" 
	fi
	[[ -d "$__extract_run_target" ]] || mkdir -p "$__extract_run_target"
	case "$__extract_run_src" in
		(*.zip) unzip -q -o "$__extract_run_src" -d "$__extract_run_target" ;;
		(*.tar.bz2) __map_tar_excludes "$@"
			if [[ -n "$ZSH_VERSION" ]]
			then
				__rvm_tar "${__exclude_elements[@]}" -xjf "$__extract_run_src" -C "$__extract_run_target" ${=rvm_tar_options:-}
			else
				__rvm_tar "${__exclude_elements[@]}" -xjf "$__extract_run_src" -C "$__extract_run_target" ${rvm_tar_options:-}
			fi ;;
		(*.tar.gz | *.tgz) __map_tar_excludes "$@"
			if [[ -n "$ZSH_VERSION" ]]
			then
				__rvm_tar "${__exclude_elements[@]}" -xzf "$__extract_run_src" -C "$__extract_run_target" ${=rvm_tar_options:-}
			else
				__rvm_tar "${__exclude_elements[@]}" -xzf "$__extract_run_src" -C "$__extract_run_target" ${rvm_tar_options:-}
			fi ;;
		(*) return 199 ;;
	esac && __rvm_fix_group_permissions "$__extract_run_target"/* || return $?
}
__rvm_package_list () {
	rvm_debug __rvm_package_list:$#: "$@"
	case "$1" in
		(*.zip) unzip -Z -1 "$1" ;;
		(*.tar.bz2) __rvm_tar tjf "$1" ;;
		(*.tar.gz | *.tgz) __rvm_tar tzf "$1" ;;
		(*) return 199 ;;
	esac
}
__rvm_pager_or_cat_v () {
	eval "${PAGER:-\command \cat} '$1'"
}
__rvm_parse_args () {
	\typeset _string
	export rvm_ruby_string
	rvm_action="${rvm_action:-""}" 
	rvm_parse_break=0 
	if [[ " $* " == *" --trace "* ]]
	then
		echo "$@"
		__rvm_print_headline
	fi
	while [[ -n "$next_token" ]]
	do
		rvm_token="$next_token" 
		if (( $# > 0 ))
		then
			next_token="$1" 
			shift
		else
			next_token="" 
		fi
		case "$rvm_token" in
			([0-9a-zA-ZuU]* | @*) case "$rvm_token" in
					(use) rvm_action="$rvm_token" 
						rvm_verbose_flag=1 
						__rvm_file_env_check_unload
						if [[ -n "${next_token:-}" && ! -d "${next_token:-}" && "${next_token:-}" != "-"* && "${next_token:-}" != "@"* ]]
						then
							rvm_ruby_interpreter="$next_token" 
							rvm_ruby_string="$next_token" 
							rvm_ruby_strings="$next_token" 
							next_token="${1:-}" 
							(( $# == 0 )) || shift
						elif [[ -z "${next_token:-}" ]] && __rvm_project_dir_check .
						then
							__rvm_rvmrc_tools try_to_read_ruby . || __rvm_parse_args_error_finding_project_file
						fi ;;
					(install | uninstall | reinstall | try_install) export ${rvm_token}_flag=1
						rvm_action=$rvm_token  ;;
					(gemset) rvm_action=$rvm_token 
						rvm_ruby_args=() 
						__rvm_parse_args_find_known_flags rvm_ruby_args "$next_token" "$@"
						: rvm_ruby_args:${#rvm_ruby_args[@]}:${rvm_ruby_args[*]}:
						next_token="${rvm_ruby_args[__array_start]}" 
						rvm_gemset_name="${rvm_ruby_args[__array_start+1]}" 
						case "${next_token:-help}" in
							(help) true ;;
							(use|delete) [[ "delete" != "$next_token" ]] || rvm_delete_flag=1 
								[[ "use" != "$next_token" ]] || rvm_action+="_$next_token" 
								case "$rvm_gemset_name" in
									(*${rvm_gemset_separator:-"@"}*) rvm_ruby_string="${rvm_gemset_name%%${rvm_gemset_separator:-"@"}*}" 
										rvm_gemset_name="${rvm_gemset_name##*${rvm_gemset_separator:-"@"}}" 
										if [[ "${rvm_ruby_string:-""}" != "${rvm_gemset_name:-""}" ]]
										then
											rvm_ruby_string="$rvm_ruby_string${rvm_gemset_separator:-"@"}$rvm_gemset_name" 
										fi
										rvm_ruby_gem_home="$rvm_ruby_gem_home${rvm_gemset_separator:-"@"}$rvm_gemset_name"  ;;
									("") rvm_error "Gemset was not given.\n  Usage:\n    rvm gemset $rvm_gemset_name <gemsetname>\n"
										return 1 ;;
								esac ;;
						esac
						rvm_parse_break=1  ;;
					(gemdir | gempath | gemhome) rvm_ruby_args=("$rvm_token") 
						rvm_action="gemset" 
						rvm_gemdir_flag=1 
						if [[ "system" == "$next_token" ]]
						then
							rvm_system_flag=1 
							next_token="${1:-}" 
							(( $# == 0 )) || shift
						fi
						if [[ "user" == "$next_token" ]]
						then
							rvm_user_flag=1 
							next_token="${1:-}" 
							(( $# == 0 )) || shift
						fi ;;
					(pkg) rvm_action="$rvm_token" 
						__rvm_parse_args_find_known_flags rvm_ruby_args "$next_token" "$@"
						rvm_parse_break=1  ;;
					(do | exec) if [[ -z "$next_token" ]]
						then
							rvm_action="error" 
							rvm_error_message="'rvm $rvm_token' must be followed by arguments." 
							break
						fi
						rvm_action="do" 
						rvm_ruby_args=("$next_token" "$@") 
						rvm_parse_break=1  ;;
					(gem | rake | ruby) [[ "$rvm_token" == "ruby" ]] && case $rvm_action in
							(install | reinstall | use | remove) rvm_ruby_string=ruby 
								rvm_ruby_strings=ruby 
								continue ;;
						esac
						rvm_action=error 
						rvm_error_message="Please note that \`rvm $rvm_token ...\` was removed, try \`$rvm_token $next_token $*\` or \`rvm all do $rvm_token $next_token $*\` instead."  ;;
					(fetch | version | remote_version | reset | debug | reload | update | monitor | notes | implode | seppuku | env | unexport | automount | prepare) rvm_action=$rvm_token  ;;
					(doctor) rvm_action=notes  ;;
					(mount) rvm_action=$rvm_token 
						while [[ -n "${next_token:-}" ]] && [[ -x "${next_token:-}" || -d "${next_token:-}" || "${next_token:-}" == http* || "${next_token:-}" == *tar.bz2 || "${next_token:-}" == *tar.gz ]]
						do
							rvm_ruby_args=("$next_token" "${rvm_ruby_args[@]}") 
							next_token="${1:-}" 
							(( $# == 0 )) || shift
						done ;;
					(rm | remove) rvm_action="remove" 
						rvm_remove_flag=1  ;;
					(rtfm | RTFM | rvmrc | help | inspect | list | ls | info | strings | get | current | docs | alias | rubygems | cleanup | tools | disk-usage | snapshot | repair | migrate | downgrade | upgrade | cron | group | switch | which | config-get | requirements | autolibs | osx-ssl-certs | fix-permissions) case "$rvm_token" in
							(downgrade) rvm_action="upgrade"  ;;
							(ls) rvm_action="list"  ;;
							(RTFM) rvm_action="rtfm"  ;;
							(*) rvm_action="$rvm_token"  ;;
						esac
						rvm_ruby_args=() 
						__rvm_parse_args_find_known_flags rvm_ruby_args "$next_token" "$@"
						rvm_parse_break=1  ;;
					(user) rvm_action="tools" 
						rvm_ruby_args=("$rvm_token" "$next_token" "$@") 
						rvm_parse_break=1  ;;
					(load-rvmrc) rvm_action="rvmrc" 
						rvm_ruby_args=("load" "$next_token" "$@") 
						rvm_parse_break=1  ;;
					(specs | tests) rvm_action="rake" 
						rvm_ruby_args=("${rvm_token/%ss/s}")  ;;
					(export) if [[ -n "$next_token" ]]
						then
							\typeset -a ___args
							___args=("$next_token" "$@") 
							rvm_export_args="${___args[*]}" 
							rvm_action="export" 
							rvm_parse_break=1 
						else
							rvm_action="error" 
							rvm_error_message="rvm export must be followed by a NAME=VALUE argument" 
						fi ;;
					(alt*) rvm_action="help" 
						rvm_ruby_args=("alt.md") 
						rvm_parse_break=1  ;;
					(wrapper) rvm_action="wrapper" 
						rvm_ruby_args=("$next_token" "$@") 
						rvm_parse_break=1  ;;
					(in) rvm_token="${next_token}" 
						next_token="${1:-}" 
						(( $# == 0 )) || shift
						export rvm_in_flag="$rvm_token" 
						__rvm_project_dir_check "$rvm_token" && __rvm_rvmrc_tools try_to_read_ruby $rvm_token || __rvm_parse_args_error_finding_project_file ;;
					(usage) rvm_action="deprecated" 
						rvm_error_message="This command has been deprecated. Use ${rvm_notify_clr:-}rvm help${rvm_error_clr:-} instead." 
						rvm_parse_break=1  ;;
					(*,*) rvm_ruby_strings="$rvm_token" 
						[[ -n "${rvm_action:-""}" ]] || rvm_action="ruby"  ;;
					(${rvm_gemset_separator:-"@"}*) rvm_action="${rvm_action:-use}" 
						rvm_gemset_name="${rvm_token#${rvm_gemset_separator:-"@"}}" 
						rvm_ruby_string="${rvm_ruby_string:-${GEM_HOME##*/}}" 
						rvm_ruby_string="${rvm_ruby_string%%${rvm_gemset_separator:-"@"}*}" 
						rvm_ruby_strings="${rvm_ruby_string}${rvm_gemset_separator:-"@"}${rvm_gemset_name}"  ;;
					(*${rvm_gemset_separator:-"@"}*) rvm_verbose_flag=1 
						rvm_action="${rvm_action:-use}" 
						rvm_gemset_name="${rvm_token/*${rvm_gemset_separator:-"@"}/}" 
						rvm_ruby_string="$rvm_token" 
						rvm_ruby_strings="$rvm_token"  ;;
					(*+*) rvm_action="${rvm_action:-use}" 
						rvm_ruby_alias="${rvm_token/*+/}" 
						rvm_ruby_string="${rvm_token/+*/}" 
						rvm_ruby_strings="$rvm_ruby_string"  ;;
					(*-* | +([0-9]).+([0-9])*) rvm_verbose_flag=1 
						rvm_action="${rvm_action:-use}" 
						rvm_ruby_string="$rvm_token" 
						rvm_ruby_strings="$rvm_token"  ;;
					(opal* | jruby* | ree* | macruby* | rbx* | rubinius* | mruby | ironruby* | default* | maglev* | topaz* | truffleruby* | ruby* | system | default | all) rvm_action="${rvm_action:-use}" 
						rvm_ruby_interpreter="$rvm_token" 
						rvm_ruby_string="$rvm_token" 
						rvm_ruby_strings="$rvm_token"  ;;
					(kiji* | tcs* | jamesgolick*) rvm_error_message="The $rvm_token was removed from RVM, use: rvm install ruby-head-<name> --url https://github.com/github/ruby.git --branch 2.1" 
						rvm_action="error"  ;;
					(old) case "${rvm_action:-action-missing}" in
							(remove) rvm_ruby_strings="old:${next_token:-}" 
								next_token="${1:-}" 
								(( $# == 0 )) || shift ;;
							(action-missing) rvm_error_message="what do you want to do with old rubies? rvm can only remove old rubies." 
								rvm_action="error"  ;;
							(*) rvm_error_message="rvm can not $rvm_action old rubies, rvm can only remove old rubies." 
								rvm_action="error"  ;;
						esac ;;
					(*.rb) rvm_ruby_args=("$rvm_token") 
						rvm_ruby_file="$rvm_token" 
						if [[ -z "${rvm_action:-""}" || "$rvm_action" == "use" ]]
						then
							rvm_action="ruby" 
						fi ;;
					(*.gems) rvm_file_name="${rvm_token}"  ;;
					("") rvm_action="error" 
						rvm_error_message="Unrecognized command line argument(s): $@"  ;;
					(*) if [[ "gemset" == "$rvm_action" ]]
						then
							rvm_gemset_name="${rvm_token/.gems/}" 
							rvm_file_name="$rvm_gemset_name.gems" 
						elif [[ -f "$rvm_rubies_path/$rvm_token" || -L "$rvm_rubies_path/$rvm_token" ]]
						then
							rvm_ruby_string=$rvm_token 
							rvm_ruby_strings="$rvm_token" 
							rvm_action="${rvm_action:-use}" 
						elif [[ -d "$rvm_token" ]] || __rvm_project_dir_check "$rvm_token"
						then
							__rvm_rvmrc_tools try_to_read_ruby $rvm_token || __rvm_parse_args_error_finding_project_file
						else
							rvm_action="error" 
							rvm_error_message="Unrecognized command line argument: $rvm_token" 
						fi ;;
				esac ;;
			(-*) case "$rvm_token" in
					(-S) rvm_action="ruby" 
						rvm_ruby_args=("$rvm_token" "$next_token" "$@") 
						rvm_parse_break=1  ;;
					(-e) rvm_action="ruby" 
						IFS="\n" 
						rvm_ruby_args=("$rvm_token" "'$next_token $@'") 
						IFS=" " 
						rvm_parse_break=1  ;;
					(-v | --version) if [[ -z "$next_token" ]]
						then
							rvm_action="version" 
						else
							rvm_ruby_version="$next_token" 
							next_token="${1:-}" 
							(( $# == 0 )) || shift
						fi ;;
					(-n | --name) rvm_ruby_name="$next_token" 
						next_token="${1:-}" 
						(( $# == 0 )) || shift ;;
					(--branch) rvm_ruby_repo_branch="$next_token" 
						next_token="${1:-}" 
						(( $# == 0 )) || shift
						rvm_disable_binary_flag=1  ;;
					(--tag) rvm_ruby_repo_tag="$next_token" 
						next_token="${1:-}" 
						(( $# == 0 )) || shift
						rvm_disable_binary_flag=1  ;;
					(--repository | --repo | --url) rvm_ruby_repo_url="$next_token" 
						next_token="${1:-}" 
						(( $# == 0 )) || shift
						rvm_disable_binary_flag=1  ;;
					(-r | --remote | --binary | --latest-binary) rvm_remote_flag=1 
						if [[ "$rvm_token" == "--latest-binary" ]]
						then
							rvm_fuzzy_flag=1 
						fi
						while [[ -n "${next_token:-}" ]] && [[ "${next_token:-}" == http* || "${next_token:-}" == *tar.bz2 || "${next_token:-}" == *tar.gz || "${next_token:-}" == *":"* ]]
						do
							rvm_ruby_args=("${rvm_ruby_args[@]}" "$next_token") 
							next_token="${1:-}" 
							(( $# == 0 )) || shift
						done ;;
					(--ree-options) if [[ -n "$next_token" ]]
						then
							__rvm_custom_separated_array rvm_ree_options , "${next_token}"
							next_token="${1:-}" 
							(( $# == 0 )) || shift
						else
							rvm_action="error" 
							rvm_error_message="--ree-options *must* be followed by... well... comma,separated,list,of,options." 
						fi ;;
					(--patches | --patch) __rvm_custom_separated_array rvm_patch_names , "$next_token"
						next_token="${1:-}" 
						(( $# == 0 )) || shift
						rvm_patch_original_pwd="$PWD" 
						rvm_disable_binary_flag=1  ;;
					(--arch | --archflags) rvm_architectures+=("${next_token#-arch }") 
						next_token="${1:-}" 
						(( $# == 0 )) || shift
						rvm_disable_binary_flag=1  ;;
					(--with-arch=*) rvm_architectures+=("${rvm_token#--with-arch=}") 
						rvm_disable_binary_flag=1  ;;
					(--32 | --64) rvm_architectures+=("${rvm_token#--}") 
						rvm_disable_binary_flag=1  ;;
					(--universal) rvm_architectures+=("32" "64") 
						rvm_disable_binary_flag=1  ;;
					(--bin) rvm_bin_path="$next_token" 
						next_token="${1:-}" 
						(( $# == 0 )) || shift ;;
					(--rdoc | --yard) rvm_docs_type="$rvm_token" 
						rvm_docs_type ;;
					(-f | --file) rvm_action="ruby" 
						rvm_ruby_file="$next_token" 
						next_token="${1:-}" 
						(( $# == 0 )) || shift ;;
					(--passenger | --editor) rvm_warn "NOTE: ${rvm_token} flag is deprecated, RVM now automatically generates wrappers" ;;
					(-h | --help) rvm_action=help  ;;
					(-l | --level) rvm_ruby_patch_level="p$next_token" 
						next_token="${1:-}" 
						(( $# == 0 )) || shift ;;
					(--sha | --make | --make-install) rvm_token=${rvm_token#--} 
						rvm_token=${rvm_token//-/_} 
						export "rvm_ruby_${rvm_token}"="$next_token"
						next_token="${1:-}" 
						rvm_disable_binary_flag=1 
						(( $# == 0 )) || shift ;;
					(--nice | --sdk | --autoconf-flags | --proxy) rvm_token=${rvm_token#--} 
						rvm_token=${rvm_token//-/_} 
						export "rvm_${rvm_token}"="$next_token"
						next_token="${1:-}" 
						(( $# == 0 )) || shift ;;
					(--disable-llvm | --disable-jit) rvm_llvm_flag=0  ;;
					(--enable-llvm | --enable-jit) rvm_llvm_flag=1  ;;
					(--install) rvm_install_on_use_flag=1  ;;
					(--autolibs=*) export rvm_autolibs_flag="${rvm_token#*=}"  ;;
					(--color=*) rvm_pretty_print_flag=${rvm_token#--color=}  ;;
					(--pretty) rvm_pretty_print_flag=auto  ;;
					(--1.8 | --1.9 | --2.0 | --2.1 | --18 | --19 | --20 | --21) rvm_token=${rvm_token#--} 
						rvm_token=${rvm_token//\./} 
						export "rvm_${rvm_token}_flag"=1
						rvm_disable_binary_flag=1  ;;
					(--rvmrc | --versions-conf | --ruby-version) rvm_token=${rvm_token#--} 
						rvm_token=${rvm_token//-/_} 
						export rvm_rvmrc_flag="${rvm_token}"  ;;
					(--list-missing-packages) export rvm_list_missing_packages_flag=1 
						export rvm_quiet_flag=1  ;;
					(--list-undesired-packages) export rvm_list_undesired_packages_flag=1 
						export rvm_quiet_flag=1  ;;
					(--list-installed-packages) export rvm_list_installed_packages_flag=1 
						export rvm_quiet_flag=1  ;;
					(--list-all-packages) export rvm_list_missing_packages_flag=1 
						export rvm_list_undesired_packages_flag=1 
						export rvm_list_installed_packages_flag=1 
						export rvm_quiet_flag=1  ;;
					(--head | --static | --self | --gem | --reconfigure | --default | --force | --export | --summary | --latest | --yaml | --json | --archive | --shebang | --path | --cron | --tail | --delete | --verbose | --import | --sticky | --create | --gems | --docs | --skip-autoreconf | --force-autoconf | --auto-dotfiles | --autoinstall-bundler | --disable-binary | --ignore-gemsets | --skip-gemsets | --debug | --quiet | --silent | --skip-openssl | --fuzzy | --quiet-curl | --skip-pristine | --dynamic-extensions) rvm_token=${rvm_token#--} 
						rvm_token=${rvm_token//-/_} 
						export "rvm_${rvm_token}_flag"=1 ;;
					(--no-docs) rvm_token=${rvm_token#--no-} 
						rvm_token=${rvm_token//-/_} 
						export "rvm_${rvm_token}_flag"=0 ;;
					(--auto) export "rvm_auto_dotfiles_flag"=1
						rvm_warn "Warning, --auto is deprecated in favor of --auto-dotfiles." ;;
					(--rubygems) rvm_token=${rvm_token#--} 
						rvm_token=${rvm_token//-/_} 
						export "rvm_${rvm_token}_version"="$next_token"
						next_token="${1:-}" 
						(( $# == 0 )) || shift ;;
					(--dump-environment | --max-time) rvm_token=${rvm_token#--} 
						rvm_token=${rvm_token//-/_} 
						export "rvm_${rvm_token}_flag"="$next_token"
						next_token="${1:-}" 
						(( $# == 0 )) || shift ;;
					(--verify-downloads) rvm_token=${rvm_token#--} 
						rvm_token=${rvm_token//-/_} 
						export "rvm_${rvm_token}_flag_cli"="$next_token"
						next_token="${1:-}" 
						(( $# == 0 )) || shift ;;
					(--clang) export CC=clang 
						export CXX=clang++ 
						rvm_disable_binary_flag=1  ;;
					(-M) if [[ -n "$next_token" ]]
						then
							__rvm_custom_separated_array rvm_make_flags , "${next_token}"
							next_token="${1:-}" 
							(( $# == 0 )) || shift
							rvm_disable_binary_flag=1 
						else
							rvm_action="error" 
							rvm_error_message="--make *must* be followed by make flags." 
						fi ;;
					(-j) if [[ -n "$next_token" ]]
						then
							rvm_make_flags+=(-j$next_token) 
							next_token="${1:-}" 
							(( $# == 0 )) || shift
						else
							rvm_action="error" 
							rvm_error_message="-j *must* be followed by an integer (normally the # of CPU's in your machine)." 
						fi ;;
					(--with-rubies) rvm_ruby_strings="$next_token" 
						next_token="${1:-}" 
						(( $# == 0 )) || shift ;;
					(-C | --configure) if [[ -n "$next_token" ]]
						then
							__rvm_custom_separated_array rvm_configure_flags , "${next_token}"
							next_token="${1:-}" 
							(( $# == 0 )) || shift
							rvm_disable_binary_flag=1 
						else
							rvm_action="error" 
							rvm_error_message="--configure *must* be followed by configure flags." 
						fi ;;
					(-E | --env) if [[ -n "$next_token" ]]
						then
							__rvm_custom_separated_array rvm_configure_env , "${next_token}"
							next_token="${1:-}" 
							(( $# == 0 )) || shift
							rvm_disable_binary_flag=1 
						else
							rvm_action="error" 
							rvm_error_message="--configure *must* be followed by configure flags." 
						fi ;;
					(--movable) rvm_movable_flag=1 
						rvm_disable_binary_flag=1  ;;
					(--with-* | --without-* | --enable-* | --disable-*) rvm_configure_flags+=("$rvm_token") 
						rvm_disable_binary_flag=1  ;;
					(--trace) export rvm_trace_flag=1 
						if [[ -n "${BASH_VERSION:-}" ]]
						then
							export PS4="+ \$(__rvm_date \"+%s.%N\" 2>/dev/null) \${BASH_SOURCE##\${rvm_path:-}} : \${FUNCNAME[0]:+\${FUNCNAME[0]}()}  \${LINENO} > " 
						elif [[ -n "${ZSH_VERSION:-}" ]]
						then
							export PS4="+ %* %F{red}%x:%I %F{green}%N:%i%F{white} %_" 
						fi
						set -o xtrace ;;
					(--) if [[ "${rvm_action}" == *install ]]
						then
							rvm_configure_flags+=("$next_token" "$@") 
						else
							rvm_ruby_args=("$next_token" "$@") 
						fi
						rvm_disable_binary_flag=1 
						rvm_parse_break=1  ;;
					(*) rvm_action="error" 
						rvm_error_message="Unrecognized command line flag: '$rvm_token'"  ;;
				esac ;;
			(*) if [[ -d "$rvm_token" ]] || __rvm_project_dir_check "$rvm_token"
				then
					__rvm_rvmrc_tools try_to_read_ruby "$rvm_token" || __rvm_parse_args_error_finding_project_file
				else
					rvm_action="error" 
					rvm_error_message="Unrecognized command line argument(s): '$rvm_token $@'" 
				fi ;;
		esac
		if [[ -z "${rvm_action:-""}" && -n "${rvm_ruby_string:-""}" ]]
		then
			rvm_action="use" 
		fi
		if [[ "error" == "${rvm_action:-""}" || ${rvm_parse_break:-0} -eq 1 || -n "${rvm_error_message:-""}" ]]
		then
			break
		fi
	done
	: rvm_ruby_args:${#rvm_ruby_args[@]}:${rvm_ruby_args[*]}:
	if [[ -n "${rvm_error_message:-""}" ]]
	then
		if [[ "${rvm_action}" == "deprecated" ]]
		then
			rvm_error "$rvm_error_message"
		else
			rvm_error "$rvm_error_message"
			rvm_out "Run \`rvm help\` to see usage information"
		fi
		unset rvm_error_message
		return 1
	fi
}
__rvm_parse_args_error_finding_project_file () {
	unset RVM_PROJECT_PATH
	case $? in
		(101) true ;;
		(*) rvm_error_message="Could not determine which Ruby to use; $rvm_token should contain .rvmrc or .versions.conf or .ruby-version or .rbfu-version or .rbenv-version, or an appropriate line in Gemfile."  ;;
	esac
	rvm_action="error" 
}
__rvm_parse_args_find_known_flags () {
	\typeset _args_array_name _temp_var
	\typeset -a _new_args
	_args_array_name="$1" 
	(( $# == 0 )) || shift
	_new_args=() 
	while (( $# ))
	do
		case "$1" in
			(--verify-downloads) export "rvm_verify_downloads_flag_cli"="${2:-}"
				shift ;;
			(--force|--verbose|--debug|--quiet|--silent|--create) export "rvm_${1#--}_flag=1" ;;
			(--only-path) _temp_var="${1#--}" 
				export "rvm_${_temp_var//-/_}_flag=1" ;;
			(--32|--64) rvm_architectures+=("${1#--}") 
				rvm_disable_binary_flag=1  ;;
			(--universal) rvm_architectures+=("32" "64") 
				rvm_disable_binary_flag=1  ;;
			(--patches|--patch) __rvm_custom_separated_array rvm_patch_names , "${2:-}"
				rvm_patch_original_pwd="$PWD" 
				rvm_disable_binary_flag=1 
				shift ;;
			(--autolibs=*) export rvm_autolibs_flag="${1#*=}"  ;;
			(--) shift
				_new_args+=("$@") 
				shift $# ;;
			(*) _new_args+=("$1")  ;;
		esac
		(( $# == 0 )) || shift
	done
	eval "${_args_array_name}+=( \"\${_new_args[@]}\" )"
}
__rvm_parse_gems_args () {
	\typeset gem="${*%%;*}"
	if __rvm_string_match "$gem" "*.gem$"
	then
		gem_name="$(basename "${gem/.gem/}" |  __rvm_awk -F'-' '{$NF=NULL;print}')" 
		gem_version="$(basename "${gem/.gem/}" |  __rvm_awk -F'-' '{print $NF}' )" 
	else
		gem_name="${gem/ */}" 
		case "$gem" in
			(*--version*) gem_version=$(
          echo "$gem" | __rvm_sed -e 's#.*--version[=]*[ ]*##' | __rvm_awk '{print $1}'
        )  ;;
			(*-v*) gem_version=$(
          echo "$gem" | __rvm_sed -e 's#.*-v[=]*[ ]*##' | __rvm_awk '{print $1}'
        )  ;;
		esac
	fi
}
__rvm_patch () {
	\patch "$@" || return $?
}
__rvm_path_match_gem_home_check () {
	(( ${rvm_silence_path_mismatch_check_flag:-0} == 0 )) || return 0
	if [[ -n "${GEM_HOME:-}" ]]
	then
		case "$PATH:" in
			($GEM_HOME/bin:*) true ;;
			(*:$GEM_HOME/bin:*) __rvm_path_match_gem_home_check_warning "is not at first place" ;;
			(*) __rvm_path_match_gem_home_check_warning "is not available" ;;
		esac
	else
		\typeset __path_to_ruby
		if __path_to_ruby="$( builtin command -v ruby 2>/dev/null )"  && [[ "${__path_to_ruby}" == "${rvm_path}"* ]]
		then
			__path_to_ruby="${__path_to_ruby%/bin/ruby}" 
			__path_to_ruby="${__path_to_ruby##*/}" 
			__rvm_path_match_gem_home_check_warning_missing "${__path_to_ruby}"
		fi
	fi
}
__rvm_path_match_gem_home_check_warn () {
	rvm_warn "Warning! PATH is not properly set up, $1.
         <log>Usually this is caused by shell initialization files. Search for <code>PATH=...</code> entries.
         You can also re-add RVM to your profile by running: <code>rvm get stable --auto-dotfiles</code>
         To fix it temporarily in this shell session run: <code>rvm use $2</code>
         To ignore this error add <code>rvm_silence_path_mismatch_check_flag=1</code> to your <code>~/.rvmrc</code> file."
}
__rvm_path_match_gem_home_check_warning () {
	__rvm_path_match_gem_home_check_warn "$GEM_HOME/bin $1" "${GEM_HOME##*/}"
}
__rvm_path_match_gem_home_check_warning_missing () {
	__rvm_path_match_gem_home_check_warn "\$GEM_HOME is not set" "$1"
}
__rvm_print_headline () {
	rvm_log "Ruby enVironment Manager ${rvm_version} $(__rvm_version_copyright)
"
}
__rvm_project_dir_check () {
	\typeset _found_file path_to_check variable variable_default
	\typeset -a _valid_files
	path_to_check="$1" 
	variable="${2:-}" 
	variable_default="${3:-}" 
	_valid_files=("$path_to_check" "$path_to_check/.rvmrc" "$path_to_check/.versions.conf" "$path_to_check/.ruby-version" "$path_to_check/.rbfu-version" "$path_to_check/.rbenv-version" "$path_to_check/Gemfile") 
	__rvm_find_first_file _found_file "${_valid_files[@]}" || true
	if [[ ! -s "$_found_file" || "${_found_file}" == "$HOME/.rvmrc" ]]
	then
		_found_file="" 
	elif [[ "${_found_file##*/}" == "Gemfile" ]] && ! __rvm_grep "^#ruby=" "$_found_file" > /dev/null && ! __rvm_grep -E "^\s*ruby" "$_found_file" > /dev/null
	then
		_found_file="" 
	fi
	if [[ -n "$variable" ]]
	then
		eval "$variable=\"\${_found_file:-$variable_default}\""
	fi
	if [[ -n "${_found_file:-$variable_default}" ]]
	then
		RVM_PROJECT_PATH="${_found_file:-$variable_default}" 
		RVM_PROJECT_PATH="${RVM_PROJECT_PATH%/*}" 
	else
		\typeset __result=$?
		unset RVM_PROJECT_PATH
		return $__result
	fi
}
__rvm_project_rvmrc () {
	export __rvm_project_rvmrc_lock
	: __rvm_project_rvmrc_lock:${__rvm_project_rvmrc_lock:=0}
	: __rvm_project_rvmrc_lock:$((__rvm_project_rvmrc_lock+=1))
	if (( __rvm_project_rvmrc_lock > 1 ))
	then
		return 0
	fi
	\typeset working_dir found_file rvm_trustworthiness_result save_PATH
	working_dir="${1:-"$PWD"}" 
	save_PATH="${PATH}" 
	while :
	do
		if [[ -z "$working_dir" || "$HOME" == "$working_dir" || "${rvm_prefix:-}" == "$working_dir" || "$working_dir" == "." ]]
		then
			if (( ${rvm_project_rvmrc_default:-0} >= 1 ))
			then
				rvm_previous_environment=default 
			fi
			if [[ -n "${rvm_previous_environment:-""}" ]] && (( ${rvm_project_rvmrc_default:-0} < 2 ))
			then
				__rvm_load_environment "$rvm_previous_environment"
			fi
			__rvm_file_env_check_unload
			unset rvm_current_rvmrc rvm_previous_environment
			break
		else
			if __rvm_project_dir_check "$working_dir" found_file
			then
				rvm_trustworthiness_result=0 
				if [[ "${found_file}" != "${rvm_current_rvmrc:-""}" ]]
				then
					__rvm_conditionally_do_with_env __rvm_load_project_config "${found_file}" || {
						rvm_trustworthiness_result=$? 
						PATH="${save_PATH}" 
						unset RVM_PROJECT_PATH
					}
				fi
				unset __rvm_project_rvmrc_lock
				return "$rvm_trustworthiness_result"
			else
				working_dir="${working_dir%/*}" 
			fi
		fi
	done
	unset __rvm_project_rvmrc_lock
	return 1
}
__rvm_read_lines () {
	\typeset IFS
	IFS="
" 
	if [[ "${2:--}" == "-" ]]
	then
		eval "$1=( \$( \command \cat - ) )"
	else
		eval "$1=( \$( \command \cat \"\${2:--}\" ) )"
	fi
}
__rvm_readlink () {
	\readlink "$@" || return $?
}
__rvm_readlink_deep () {
	eval "
    while [[ -n \"\${$1}\" && -L \"\${$1}\" ]]
    do $1=\"\$(__rvm_readlink \"\${$1}\")\"
    done
  "
}
__rvm_record_install () {
	[[ -n "$1" ]] || return
	\typeset recorded_ruby_name rvm_install_record_file
	recorded_ruby_name="$( "$rvm_scripts_path/tools" strings "$1" )" 
	rvm_install_record_file="$rvm_user_path/installs" 
	[[ -f "$rvm_install_record_file" ]] || \command \touch "$rvm_install_record_file"
	__rvm_sed_i "$rvm_install_record_file" -e "/^$recorded_ruby_name/d"
	printf "%b" "$recorded_ruby_name -- ${rvm_configure_flags[*]}\n" >> "$rvm_install_record_file"
}
__rvm_record_ruby_configs () {
	\typeset __dir
	for __dir in "$rvm_path/rubies/"*
	do
		if [[ ! -L "${__dir}" && ! -s "${__dir}/config" && -x "${__dir}/bin/ruby" ]]
		then
			__rvm_ruby_config_save "${__dir}/bin/ruby" "${__dir}/config" || {
				\typeset string="${__dir##*/}"
				rvm_error "    Can not save config data for ruby: '${string}', most likely it is broken installation and you can:
    - try fix it: 'rvm reinstall ${string}', OR:
    - remove  it: 'rvm uninstall ${string} --gems'"
			}
		fi
	done
}
__rvm_recorded_install_command () {
	\typeset recorded_ruby_name
	recorded_ruby_name="$( "$rvm_scripts_path/tools" strings "$1" )" 
	recorded_ruby_name=${recorded_ruby_name%%${rvm_gemset_seperator:-"@"}*} 
	[[ -n "$recorded_ruby_name" ]] || return 1
	if [[ -s "$rvm_user_path/installs" ]] && __rvm_grep "^$recorded_ruby_name " "$rvm_user_path/installs" > /dev/null 2>&1
	then
		__rvm_grep "^$recorded_ruby_name " "$rvm_user_path/installs" | \command \head -n 1
	else
		return 1
	fi
}
__rvm_remote_extension () {
	case "$1" in
		(*.tar.*) rvm_remote_extension="tar${1##*tar}"  ;;
		(jruby-*) rvm_remote_extension="tar.gz"  ;;
		(*) rvm_remote_extension="tar.bz2"  ;;
	esac
	[[ "$2" != "-" ]] || printf "%b" "${rvm_remote_extension}"
}
__rvm_remote_server_path () {
	\typeset _iterator
	_iterator="" 
	while ! __rvm_remote_server_path_single 0 1 "${_iterator}" "${1:-}"
	do
		: $(( _iterator+=1 ))
	done
}
__rvm_remote_server_path_single () {
	\typeset __remote_file
	__rvm_calculate_remote_file "$@" || return $?
	if [[ -z "${__remote_file:-}" ]]
	then
		rvm_debug "No remote file name found"
		return $1
	elif file_exists_at_url "${__remote_file}"
	then
		rvm_debug "Remote file exists ${__remote_file}"
		printf "%b" "$( __rvm_db "rvm_remote_server_verify_downloads${3:-}" ):${__remote_file}"
	elif [[ -f "${rvm_archives_path}/${rvm_ruby_package_file##*/}" && "${rvm_ruby_package_file##*/}" == *bin-* ]]
	then
		rvm_debug "Cached file exists ${__remote_file}"
		printf "%b" "$( __rvm_db "rvm_remote_server_verify_downloads${3:-}" ):${rvm_archives_path}/${rvm_ruby_package_file##*/}"
	else
		rvm_debug "Remote file does not exist ${__remote_file}"
		return $2
	fi
}
__rvm_remove_broken_symlinks () {
	if [[ ! -e "$1" && -L "$1" ]]
	then
		__rvm_rm_rf "$1"
	fi
}
__rvm_remove_from_array () {
	\typeset _array_name _iterator _search
	\typeset -a _temp_array
	_array_name="$1" 
	_search="$2" 
	shift 2
	_temp_array=() 
	for _iterator
	do
		__rvm_string_match "$_iterator" "$_search" || _temp_array+=("$_iterator") 
	done
	eval "$_array_name=( \"\${_temp_array[@]}\" )"
}
__rvm_remove_from_path () {
	export PATH
	\typeset _value
	_value="${1//+(\/)//}" 
	if [[ $_value == "/*" ]]
	then
		return
	fi
	while [[ "$PATH" == *"//"* ]]
	do
		PATH="${PATH/\/\///}" 
	done
	while [[ "$PATH" == *"/:"* ]]
	do
		PATH="${PATH/\/:/:}" 
	done
	if __rvm_string_match ":$PATH:" "*:${_value}:*"
	then
		\typeset -a _path
		_path=() 
		__rvm_custom_separated_array _path : "${PATH}"
		__rvm_remove_from_array _path "${_value}" "${_path[@]}"
		__rvm_join_array PATH : _path
	fi
}
__rvm_remove_install_record () {
	\typeset recorded_ruby_name rvm_install_record_file
	recorded_ruby_name="$( "$rvm_scripts_path/tools" strings "$1" )" 
	rvm_install_record_file="$rvm_user_path/installs" 
	if [[ -s "$rvm_install_record_file" ]]
	then
		__rvm_sed_i "$rvm_install_record_file" -e "/^$recorded_ruby_name/d"
	fi
}
__rvm_remove_rvm_from_path () {
	\typeset local_rvm_path
	__rvm_remove_from_path "${rvm_path%/}/*"
	__rvm_remove_from_path "${rvm_gems_path%/}/*"
	__rvm_remove_from_path "${rvm_bin_path}"
	while local_rvm_path="$( __rvm_which rvm 2>/dev/null )" 
	do
		__rvm_remove_from_path "${local_rvm_path%/*}"
	done
	builtin hash -r
}
__rvm_remove_without_gems () {
	[[ -n "${rvm_without_gems}" ]] || return 0
	\typeset -a __gems_to_remove __extra_flags
	__rvm_read_lines __gems_to_remove <(
    GEM_PATH="$GEM_HOME" __rvm_list_gems "" "${rvm_without_gems}"
  )
	(( ${#__gems_to_remove[@]} )) || return 0
	__extra_flags=() 
	if __rvm_version_compare "$(\command \gem --version)" -ge 2.1.0
	then
		__extra_flags+=(--abort-on-dependent) 
	fi
	\typeset __gem __name __version
	for __gem in "${__gems_to_remove[@]}"
	do
		__name="${__gem% *}" 
		__version="${__gem##* }" 
		__rvm_log_command "gem.uninstall.${__name}-${__version}" "$rvm_ruby_string - #uninstalling gem ${__name}-${__version}" \command \gem uninstall "${__name}" -v "${__version}" -x "${__extra_flags[@]}" || true
	done
}
__rvm_replace_colors () {
	\typeset ___text
	___text="${1//<error>/$rvm_error_clr}" 
	___text="${___text//<warn>/$rvm_warn_clr}" 
	___text="${___text//<debug>/$rvm_debug_clr}" 
	___text="${___text//<notify>/$rvm_notify_clr}" 
	___text="${___text//<code>/$rvm_code_clr}" 
	___text="${___text//<comment>/$rvm_comment_clr}" 
	___text="${___text//<log>/$rvm_reset_clr}" 
	___text="${___text//<\/error>/$rvm_reset_clr}" 
	___text="${___text//<\/warn>/$rvm_reset_clr}" 
	___text="${___text//<\/debug>/$rvm_reset_clr}" 
	___text="${___text//<\/notify>/$rvm_reset_clr}" 
	___text="${___text//<\/code>/$rvm_reset_clr}" 
	___text="${___text//<\/comment>/$rvm_reset_clr}" 
	___text="${___text//<\/log>/$rvm_reset_clr}" 
	printf "%b" "${___text}$rvm_reset_clr"
}
__rvm_require () {
	[[ -f "$1" ]] && source "$1"
}
__rvm_reset_rvmrc_trust () {
	if [[ "$1" == all ]]
	then
		echo "" > "${rvm_user_path:-${rvm_path}/user}/rvmrcs"
	else
		__rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" "delete" > /dev/null 2>&1
	fi
}
__rvm_rm_rf () {
	__rvm_rm_rf_verbose "$@"
}
__rvm_rm_rf_verbose () {
	\typeset target
	target="${1%%+(/|.)}" 
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		\builtin setopt extendedglob
	elif [[ -n "${BASH_VERSION:-}" ]]
	then
		\builtin shopt -s extglob
	else
		rvm_error "What the heck kind of shell are you running here???"
	fi
	case "${target}" in
		(*(/|.)@(|/Applications|/Developer|/Guides|/Information|/Library|/Network|/System|/User|/Users|/Volumes|/backups|/bdsm|/bin|/boot|/cores|/data|/dev|/etc|/home|/lib|/lib64|/mach_kernel|/media|/misc|/mnt|/net|/opt|/private|/proc|/root|/sbin|/selinux|/srv|/sys|/tmp|/usr|/var)) rvm_debug "__rvm_rm_rf target is not valid - can not remove"
			return 1 ;;
		(*) if [[ -z "${target}" ]]
			then
				rvm_debug "__rvm_rm_rf target not given"
				return 1
			elif [[ -d "${target}" ]]
			then
				\command \rm -rf "${target}" || {
					\typeset ret=$?
					rvm_debug "__rvm_rm_rf error removing target dir '${target}'."
					return $ret
				}
			elif [[ -f "${target}" || -L "${target}" ]]
			then
				\command \rm -f "${target}" || {
					\typeset ret=$?
					rvm_debug "__rvm_rm_rf error removing target file/link '${target}'."
					return $ret
				}
			else
				rvm_debug "__rvm_rm_rf already gone: $*"
			fi ;;
	esac
	true
}
__rvm_ruby_config_get () {
	\typeset variable_name ruby_path
	variable_name="$1" 
	ruby_path="${2:-$rvm_ruby_home/bin/ruby}" 
	__rvm_string_match "$ruby_path" "*mruby*" && return
	case "${variable_name:---all}" in
		(--all) "$ruby_path" -rrbconfig -e 'puts RbConfig::CONFIG.sort.map{|k,v| "#{k}: #{v}" }' 2> /dev/null || return $? ;;
		(*) "$ruby_path" -rrbconfig -e 'puts RbConfig::CONFIG["'"$variable_name"'"]' 2> /dev/null || return $? ;;
	esac
}
__rvm_ruby_config_save () {
	\typeset ruby_path
	ruby_path="${1:-$rvm_ruby_home/bin/ruby}" 
	case "$ruby_path" in
		(*/mruby*) __rvm_ruby_config_save_mruby "${2:-${ruby_path%%/bin/ruby}/config}" ;;
		(*) __rvm_ruby_config_save_generic "$2" ;;
	esac
}
__rvm_ruby_config_save_generic () {
	\typeset config_path default_config_path
	default_config_path="#{RbConfig::CONFIG[\"prefix\"]}/config" 
	config_path="${1:-$default_config_path}" 
	"$ruby_path" -rrbconfig -e '\
    File.open("'"$config_path"'","w") { |file|
      RbConfig::CONFIG.sort.each{|key,value|
        file.write("#{key.gsub(/\.|-/,"_")}=\"#{value.to_s.gsub("$","\\$")}\"\n")
      }
    }
  ' > /dev/null 2>&1
}
__rvm_ruby_config_save_mruby () {
	echo "target_cpu=\"$_system_arch\"" > "$1"
}
__rvm_ruby_package_file () {
	case "$1" in
		(*.tar.*) rvm_ruby_package_file="/$1"  ;;
		(rbx* | rubinius*) rvm_ruby_package_file="/${1//rbx/rubinius}.$(__rvm_remote_extension "$1" -)"  ;;
		(jruby-head) rvm_ruby_package_file="/jruby-head.$(__rvm_remote_extension "$1" -)"  ;;
		(jruby*) \typeset __version
			__version="$(
        rvm_ruby_string="$1"
        rvm_remote_flag=0 __rvm_ruby_string
        echo "$rvm_ruby_version"
      )" 
			rvm_ruby_package_file="/${__version}/jruby-dist-${__version}-bin.$(__rvm_remote_extension "$1" -)"  ;;
		("") rvm_ruby_package_file=""  ;;
		(ruby* | mruby*) rvm_ruby_package_file="/$1.$(__rvm_remote_extension "$1" -)"  ;;
		(*) rvm_ruby_package_file="/ruby-$1.$(__rvm_remote_extension "$1" -)"  ;;
	esac
}
__rvm_ruby_string () {
	true ${rvm_head_flag:=0} ${rvm_delete_flag:=0}
	rvm_expanding_aliases='' 
	true "${rvm_ruby_version:=}" "${rvm_gemset_name:=}" "${rvm_ruby_interpreter:=}" "${rvm_ruby_version:=}" "${rvm_ruby_tag:=}" "${rvm_ruby_patch_level:=}" "${rvm_ruby_revision:=}" ${rvm_gemset_separator:="@"} "${rvm_ruby_string:=}" ${rvm_expanding_aliases:=0} ${rvm_head_flag:=0}
	if [[ "$rvm_ruby_string" == *"${rvm_gemset_separator}"* ]]
	then
		rvm_gemset_name="${rvm_ruby_string/*${rvm_gemset_separator}/}" 
		rvm_ruby_string="${rvm_ruby_string/${rvm_gemset_separator}*/}" 
	fi
	if (( rvm_expanding_aliases == 0 )) && [[ -n "${rvm_ruby_string}" && "$rvm_ruby_string" != "system" ]]
	then
		if [[ -f "$rvm_path/config/known_aliases" && -s "$rvm_path/config/known_aliases" ]] && expanded_alias_name="$(__rvm_db_ "$rvm_path/config/known_aliases" "$rvm_ruby_string")"  && [[ -n "$expanded_alias_name" ]]
		then
			rvm_ruby_string="$expanded_alias_name" 
		fi
	fi
	if (( rvm_expanding_aliases == 0 )) && [[ -n "${rvm_ruby_string}" && "$rvm_ruby_string" != "system" ]]
	then
		if [[ -f "$rvm_path/config/alias" && -s "$rvm_path/config/alias" ]] && expanded_alias_name="$(__rvm_db_ "$rvm_path/config/alias" "$rvm_ruby_string")"  && [[ -n "$expanded_alias_name" ]]
		then
			rvm_ruby_string="$expanded_alias_name" 
		elif [[ "$rvm_ruby_string" == default ]]
		then
			rvm_ruby_string="system" 
		fi
		if [[ "$rvm_ruby_string" == *"${rvm_gemset_separator}"* ]]
		then
			rvm_gemset_name="${rvm_ruby_string/*${rvm_gemset_separator}/}" 
			rvm_ruby_string="${rvm_ruby_string/${rvm_gemset_separator}*/}" 
		fi
	fi
	if [[ -n "$gemset_name" ]]
	then
		rvm_gemset_name="$gemset_name" 
		rvm_sticky_flag=1 
	fi
	__rvm_ruby_string_parse || return $?
	__rvm_ruby_string_find
	detected_rvm_ruby_name="${rvm_ruby_name:-}" 
	rvm_ruby_name="" 
	true
}
__rvm_ruby_string_autodetect () {
	if [[ -z "${rvm_ruby_version:-}" && "${rvm_ruby_interpreter}" != "ext" && "${rvm_ruby_interpreter}" != "system" ]] && (( ${rvm_head_flag:=0} == 0 ))
	then
		if (( ${rvm_fuzzy_flag:-0} == 1 ))
		then
			rvm_ruby_version="$(
        __rvm_list_strings |
        __rvm_grep "^${rvm_ruby_interpreter}-.*${rvm_ruby_name:-}" |
        __rvm_awk -F- '{print $2}' |
        __rvm_version_sort |
        __rvm_tail -n 1
      )" 
		fi
		rvm_ruby_version="${rvm_ruby_version:-"$(
      __rvm_db "${rvm_ruby_interpreter}_version"
    )"}" 
	fi
	if (( ${rvm_head_flag:=0} )) && [[ "${rvm_ruby_interpreter}" == "ruby" ]] && __rvm_version_compare "${rvm_ruby_version}" -ge 2.1
	then
		__rvm_take_n rvm_ruby_version 2 .
	fi
	rvm_ruby_string="${rvm_ruby_interpreter}${rvm_ruby_version:+-}${rvm_ruby_version:-}" 
	if [[ "${rvm_ruby_interpreter}" == "ext" ]]
	then
		true
	elif [[ "${rvm_head_flag:=0}" == "1" || -n "${rvm_ruby_sha:-}" || -n "${rvm_ruby_tag:-}" || -n "${rvm_ruby_repo_tag:-}" ]]
	then
		if [[ "${rvm_head_flag:=0}" == "1" ]]
		then
			rvm_ruby_string="${rvm_ruby_string}-head" 
		fi
		if [[ -n "${rvm_ruby_sha:-}" ]]
		then
			rvm_ruby_string="${rvm_ruby_string}-s${rvm_ruby_sha}" 
		elif [[ -n "${rvm_ruby_repo_tag:-}" ]]
		then
			rvm_ruby_string="${rvm_ruby_string}-tag${rvm_ruby_repo_tag}" 
		elif [[ -n "${rvm_ruby_tag:-}" ]]
		then
			rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_tag}" 
		fi
		if [[ ! -d "${rvm_rubies_path}/${rvm_ruby_string}" ]] && (( ${rvm_fuzzy_flag:-0} == 1 ))
		then
			\typeset new_ruby_string
			new_ruby_string="$(
        __rvm_list_strings |
        __rvm_grep "^${rvm_ruby_string}.*${rvm_ruby_name:-}" |
        __rvm_version_sort |
        __rvm_tail -n 1
      )" 
			rvm_ruby_string="${new_ruby_string:-$rvm_ruby_string}" 
		fi
	elif [[ -n "${rvm_ruby_revision:-}" ]]
	then
		rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_revision}" 
	elif [[ -n "${rvm_ruby_patch_level:-}" ]]
	then
		rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_patch_level}" 
	elif [[ -n "${rvm_ruby_user_tag:-}" ]]
	then
		rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_user_tag}" 
	else
		if (( ${rvm_fuzzy_flag:-0} == 1 )) && [[ "${rvm_ruby_interpreter}" == "ruby" || "${rvm_ruby_interpreter}" == "ree" ]]
		then
			rvm_ruby_patch_level="$(
        __rvm_list_strings |
        __rvm_grep "^${rvm_ruby_interpreter}-${rvm_ruby_version}-.*${rvm_ruby_name:-}" |
        __rvm_awk -F- '{print $3}' |
        __rvm_version_sort |
        __rvm_tail -n 1
      )" 
		fi
		[[ -n "${rvm_ruby_patch_level:-""}" ]] || __rvm_db_system "${rvm_ruby_interpreter}_${rvm_ruby_version}_patch_level" rvm_ruby_patch_level
		if [[ -n "${rvm_ruby_patch_level:-""}" ]]
		then
			rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_patch_level}" 
		fi
	fi
	true
}
__rvm_ruby_string_find () {
	if __rvm_ruby_string_installed
	then
		true
	elif __rvm_ruby_string_remotely_available
	then
		true
	else
		__rvm_ruby_string_autodetect
		case "${rvm_ruby_string}" in
			(ruby-+([1-9])|ruby-+([1-9]).+([0-9])|ruby-1.+([1-9]).+([0-9])|jruby-[19]*) __rvm_ruby_string_latest && __rvm_ruby_string_parse_ || return $? ;;
		esac
	fi
	if [[ -n "${rvm_ruby_name:-}" && ! "${rvm_ruby_string}" == *"-${rvm_ruby_name}" ]]
	then
		rvm_ruby_string="${rvm_ruby_string}${rvm_ruby_name:+-}${rvm_ruby_name:-}" 
	fi
}
__rvm_ruby_string_fuzzy () {
	\typeset new_ruby_string __search
	__search="${rvm_ruby_string}" 
	if [[ -n "${rvm_ruby_name:-}" ]]
	then
		__search="${__search%${rvm_ruby_name:-}}.*${rvm_ruby_name:-}" 
	fi
	new_ruby_string="$(
    __rvm_list_strings |
    __rvm_grep "${__search//\./\\.}" |
    __rvm_version_sort |
    __rvm_tail -n 1
  )" 
	if [[ -n "${new_ruby_string}" ]]
	then
		rvm_ruby_string="${new_ruby_string}" 
	else
		return $?
	fi
}
__rvm_ruby_string_fuzzy_remote () {
	\typeset new_ruby_string __search
	__search="${rvm_ruby_string}" 
	if [[ -n "${rvm_ruby_name:-}" ]]
	then
		__search="${__search%${rvm_ruby_name:-}}.*${rvm_ruby_name:-}" 
	fi
	new_ruby_string="$(
    __list_remote_all |
    __rvm_awk -F/ '{ x=$NF;
      gsub(".tar.*","",x);
      gsub("jruby-bin","jruby",x);
      gsub("rubinius","rbx",x);
      print x}' |
    __rvm_version_sort |
    __rvm_awk '
BEGIN{found=""; any=""}
/^'"${__search}"'$/ {found=$1}
/^'"${__search}"'/ {any=$1}
END{if (found) print found; else if (any) print any;}
'
  )" 
	rvm_ruby_string="${new_ruby_string:-$rvm_ruby_string}" 
}
__rvm_ruby_string_installed () {
	\typeset __ruby_inst_dir="$rvm_rubies_path/${rvm_ruby_string}"
	if [[ -n "${rvm_ruby_name:-}" && ! "${rvm_ruby_string}" == *"-${rvm_ruby_name}" ]]
	then
		__ruby_inst_dir="${__ruby_inst_dir}-${rvm_ruby_name}" 
	fi
	[[ -n "$rvm_ruby_interpreter" && -n "${rvm_ruby_string}" && -d "${__ruby_inst_dir}" ]] && [[ -z "${rvm_gemset_name}" || ${rvm_create_flag:-0} -eq 1 || -d "${__ruby_inst_dir}${rvm_gemset_separator}${rvm_gemset_name}" ]]
}
__rvm_ruby_string_latest () {
	\typeset check_ruby_string new_ruby_string
	check_ruby_string="" 
	if [[ -n "${rvm_ruby_interpreter}" ]]
	then
		check_ruby_string+="${rvm_ruby_interpreter}-" 
	fi
	if [[ -n "${rvm_ruby_version}" ]]
	then
		check_ruby_string+="${rvm_ruby_version//\./\.}.*" 
	fi
	if [[ -n "${rvm_ruby_patch_level}" ]]
	then
		check_ruby_string+="${rvm_ruby_patch_level//\./\.}.*" 
	fi
	if [[ -z "${check_ruby_string}" ]]
	then
		check_ruby_string="$rvm_ruby_string" 
	fi
	new_ruby_string="$(
    \command \cat "$rvm_path/config/known_strings" |
    __rvm_grep "${check_ruby_string}" |
    __rvm_version_sort |
    __rvm_tail -n 1
  )" 
	if [[ -n "${new_ruby_string}" ]]
	then
		rvm_ruby_string="${new_ruby_string}" 
	else
		rvm_error "Unknown ruby string (do not know how to handle): $rvm_ruby_string."
		return 1
	fi
}
__rvm_ruby_string_parse () {
	__rvm_ruby_string_parse_ || true
	if (( ${rvm_fuzzy_flag:-0} == 1 )) && [[ ! -d "${rvm_rubies_path}/${rvm_ruby_string}" ]]
	then
		if (( ${rvm_remote_flag:-0} == 1 ))
		then
			__rvm_ruby_string_fuzzy || __rvm_ruby_string_fuzzy_remote || return $?
		else
			__rvm_ruby_string_fuzzy || true
		fi
	fi
	__rvm_ruby_string_parse_ || return $?
	if [[ -z "${rvm_ruby_interpreter}" ]]
	then
		rvm_error "Unknown ruby interpreter version (do not know how to handle): $rvm_ruby_string."
		return 1
	fi
}
__rvm_ruby_string_parse_ () {
	\typeset ruby_string gemset_name expanded_alias_name repo_url branch_name ruby_name tag_name
	ruby_string="${rvm_ruby_string:-}" 
	gemset_name="${rvm_gemset_name:-}" 
	repo_url="${rvm_ruby_repo_url:-}" 
	branch_name="${rvm_ruby_repo_branch:-}" 
	ruby_name="${rvm_ruby_name:-}" 
	tag_name="${rvm_ruby_repo_tag:-}" 
	__rvm_unset_ruby_variables
	rvm_ruby_repo_url="${repo_url:-}" 
	rvm_ruby_repo_branch="${branch_name:-}" 
	rvm_ruby_name="$ruby_name" 
	rvm_ruby_repo_tag="${rvm_ruby_repo_tag:-}" 
	export rvm_head_flag=0 
	if [[ -z "${ruby_string}" || "${ruby_string}" == "current" ]]
	then
		if [[ "${GEM_HOME:-}" == *"${rvm_gems_path}"* ]]
		then
			ruby_string="${GEM_HOME##*\/}" 
			ruby_string="${ruby_string/%${rvm_gemset_separator:-"@"}*}" 
		else
			ruby_string="system" 
		fi
	fi
	strings=() 
	__rvm_custom_separated_array strings - "${ruby_string}"
	rvm_ruby_string="${ruby_string}" 
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		setopt LOCAL_OPTIONS KSH_GLOB
	fi
	for string in ${strings[@]}
	do
		case "$string" in
			(head) rvm_ruby_patch_level="" 
				rvm_ruby_revision="" 
				rvm_ruby_tag="" 
				rvm_head_flag=1  ;;
			(system) rvm_ruby_interpreter="system" 
				rvm_ruby_patch_level="" 
				rvm_ruby_tag="" 
				rvm_ruby_revision="" 
				rvm_ruby_version="" 
				rvm_gemset_name="" 
				rvm_head_flag=0 
				return 0 ;;
			(ext|external) rvm_ruby_interpreter="ext" 
				rvm_ruby_patch_level="" 
				rvm_ruby_tag="" 
				rvm_ruby_revision="" 
				rvm_ruby_version="" 
				rvm_head_flag=0 
				rvm_ruby_name="${ruby_string:-${rvm_ruby_string}}" 
				rvm_ruby_name="${rvm_ruby_name#*-}" 
				break ;;
			(nightly|weekly|monthly) case "${rvm_ruby_interpreter}" in
					(rbx|rubinius) rvm_ruby_patch_level="$string"  ;;
					(*) rvm_ruby_version="$string"  ;;
				esac
				rvm_nightly_flag=1  ;;
			(nightly*|weekly*|monthly*) case "${rvm_ruby_interpreter}" in
					(rbx|rubinius) rvm_ruby_patch_level="$string"  ;;
					(*) rvm_ruby_version="$string"  ;;
				esac ;;
			(preview*) rvm_ruby_patch_level="$string"  ;;
			(rc[0-9]*) rvm_ruby_patch_level="$string"  ;;
			(+([0-9]).+([0-9]).[0-9]*) rvm_ruby_version="${string}" 
				rvm_ruby_revision="" 
				rvm_ruby_tag=""  ;;
			([0-9][0-9]*) case "${rvm_ruby_interpreter:-""}" in
					(ree) rvm_ruby_patch_level="$string" 
						rvm_ruby_revision=""  ;;
					(maglev) rvm_ruby_version="$string" 
						rvm_ruby_revision="" 
						rvm_ruby_patch_level=""  ;;
					(*) rvm_ruby_version="${string}" 
						rvm_ruby_revision="" 
						rvm_ruby_tag=""  ;;
				esac ;;
			([0-9]*) rvm_ruby_version="${string}" 
				rvm_ruby_revision="" 
				rvm_ruby_tag=""  ;;
			(p[0-9]*) rvm_ruby_patch_level="$string"  ;;
			(r[0-9]*) rvm_ruby_patch_level="" 
				rvm_ruby_revision="$string"  ;;
			(s[0-9a-zA-ZuU]*) rvm_ruby_revision="" 
				rvm_ruby_sha="${string#s}"  ;;
			(tag[0-9]) rvm_ruby_repo_tag="$string"  ;;
			(tv[0-9]*|t[0-9]*) rvm_ruby_patch_level="" 
				rvm_ruby_revision="" 
				rvm_ruby_tag="$string"  ;;
			(m[0-9]*) rvm_ruby_mode="$string"  ;;
			(u[0-9a-zA-ZuU]*) rvm_ruby_patch_level="" 
				rvm_ruby_revision="" 
				rvm_ruby_tag="" 
				rvm_ruby_patch="" 
				rvm_ruby_user_tag="$string"  ;;
			(b[0-9]*) rvm_ruby_repo_branch="${string}" 
				rvm_head_flag=1  ;;
			(rubinius) rvm_ruby_interpreter="rbx"  ;;
			(opal|ruby|rbx|jruby|macruby|ree|maglev|ironruby|mruby|topaz|truffleruby) rvm_ruby_interpreter="$string"  ;;
			([a-zA-ZuU]*([0-9a-zA-ZuU]|_)) rvm_ruby_name="$string"  ;;
			(*) rvm_ruby_string="${ruby_string:-}" 
				return 0 ;;
		esac
	done
	if [[ -z "${rvm_ruby_interpreter}" && -n "${rvm_ruby_version}" ]]
	then
		case "${rvm_ruby_version}" in
			(1.[5-7]*|9*) rvm_ruby_interpreter=jruby  ;;
			(1.[8-9]*|2*) rvm_ruby_interpreter=ruby  ;;
		esac
		if [[ -n "${rvm_ruby_interpreter}" ]]
		then
			rvm_ruby_string="${rvm_ruby_interpreter}-${rvm_ruby_string}" 
		fi
	fi
	true
}
__rvm_ruby_string_paths_under () {
	\typeset __search_path part parts IFS
	IFS=" " 
	__search_path="${1%/}" 
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		parts=(${=rvm_ruby_string//-/ }) 
	else
		parts=(${rvm_ruby_string//-/ }) 
	fi
	echo "$__search_path"
	for part in "${parts[@]}"
	do
		__search_path="$__search_path/$part" 
		echo "$__search_path"
	done
}
__rvm_ruby_string_remotely_available () {
	(( ${rvm_remote_flag:-0} == 1 )) && [[ -n "$rvm_ruby_interpreter" && -n "${rvm_ruby_string}" ]] && __rvm_remote_server_path "${rvm_ruby_string}" > /dev/null
}
__rvm_ruby_strings_exist () {
	for rvm_ruby_string in ${@//,/ }
	do
		rvm_gemset_name="" 
		rvm_verbose_flag=0 __rvm_use "${rvm_ruby_string}" > /dev/null 2>&1 || return $?
		true rvm_gemset_name:${rvm_gemset_name:=${rvm_expected_gemset_name}}
		printf "%b" "${rvm_ruby_string}${rvm_gemset_name:+@}${rvm_gemset_name:-}\n"
	done
	unset rvm_ruby_string
}
__rvm_rubygems_create_link () {
	\typeset ruby_lib_gem_path
	\command \mkdir -p "$rvm_ruby_gem_home/bin"
	rubygems_detect_ruby_lib_gem_path "${1:-ruby}" || return 0
	if [[ -L "$ruby_lib_gem_path" && -w "$ruby_lib_gem_path" ]]
	then
		rm -rf "$ruby_lib_gem_path"
	fi
	if [[ -e "$rvm_ruby_global_gems_path" && ! -L "$rvm_ruby_global_gems_path" ]]
	then
		rm -rf "$rvm_ruby_global_gems_path"
	fi
	[[ -d "$ruby_lib_gem_path" ]] || \command \mkdir -p "$ruby_lib_gem_path"
	if [[ -w "$ruby_lib_gem_path" ]]
	then
		[[ -L "$rvm_ruby_global_gems_path" ]] || ln -fs "$ruby_lib_gem_path" "$rvm_ruby_global_gems_path"
	else
		[[ -d "$rvm_ruby_global_gems_path" ]] || \command \mkdir -p "$rvm_ruby_global_gems_path"
	fi
	\command \mkdir -p "$rvm_ruby_global_gems_path/bin"
}
__rvm_run_wrapper () {
	(
		file="$1" 
		action="${2:-}" 
		shift 2
		rubies_string="${1:-}" 
		args=($@) 
		source "$rvm_scripts_path"/base
		source "$rvm_scripts_path"/$file
	)
}
__rvm_rvmrc_key () {
	printf "%b" "$1" | \command \tr '[#/.=()]' _
	return $?
}
__rvm_rvmrc_match_all () {
	[[ "${1:-}" == "all" || "${1:-}" == "all.rvmrcs" || "${1:-}" == "allGemfiles" ]]
}
__rvm_rvmrc_notice_display_post () {
	__rvm_table "Viewing of ${_rvmrc} complete." <<TEXT
Trusting an ${_rvmrc_base} file means that whenever you cd into this directory, RVM will run this ${_rvmrc_base} shell script.
Note that if the contents of the file change, you will be re-prompted to review the file and adjust its trust settings. You may also change the trust settings manually at any time with the 'rvm rvmrc' command.
TEXT
}
__rvm_rvmrc_notice_initial () {
	__rvm_table "NOTICE" <<TEXT
RVM has encountered a new or modified ${_rvmrc_base} file in the current directory, this is a shell script and therefore may contain any shell commands.

Examine the contents of this file carefully to be sure the contents are safe before trusting it!
Do you wish to trust '${_rvmrc}'?
Choose v[iew] below to view the contents
TEXT
}
__rvm_rvmrc_stored_trust () {
	[[ -f "$1" ]] || return 1
	__rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" || return $?
}
__rvm_rvmrc_stored_trust_check () {
	\typeset _first _second _rvmrc _rvmrc_base
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		_first=1 
	else
		_first=0 
	fi
	_second=$(( _first + 1 )) 
	_rvmrc="${1}" 
	_rvmrc_base="$(basename "${_rvmrc}")" 
	if [[ -f "$_rvmrc" ]]
	then
		saveIFS=$IFS 
		IFS=$';' 
		trust=($(__rvm_rvmrc_stored_trust "$_rvmrc")) 
		IFS=$saveIFS 
		if [[ "${trust[${_second}]:-'#'}" != "$(__rvm_checksum_for_contents "$_rvmrc")" ]]
		then
			echo "The '$_rvmrc' contains unreviewed changes."
			return 1
		elif [[ "${trust[${_first}]}" == '1' ]]
		then
			echo "The '$_rvmrc' is currently trusted."
			return 0
		elif [[ "${trust[${_first}]}" == '0' ]]
		then
			echo "The '$_rvmrc' is currently untrusted."
			return 1
		else
			echo "The trustiworthiness of '$_rvmrc' is currently unknown."
			return 1
		fi
	else
		echo "There is no '$_rvmrc'"
		return 1
	fi
}
__rvm_rvmrc_to () {
	case "${1:-help}" in
		(.ruby-version|ruby-version) __rvm_rvmrc_to_ruby_version || return $? ;;
		(help) rvm_help rvmrc to
			return 0 ;;
		(*) rvm_error_help "Unknown subcommand '$1'" rvmrc to
			return 1 ;;
	esac
}
__rvm_rvmrc_to_ruby_version () {
	(
		[[ -s "$PWD/.rvmrc" ]] || {
			rvm_error "No .rvmrc to convert"
			return 2
		}
		__rvm_load_project_config "$PWD/.rvmrc" || {
			rvm_error "Could not load .rvmrc"
			return 3
		}
		__rvm_set_ruby_version
		\command \rm .rvmrc || {
			rvm_error "Could not remove .rvmrc"
			return 4
		}
	)
}
__rvm_rvmrc_tools () {
	\typeset rvmrc_action rvmrc_warning_action rvmrc_path saveIFS trust rvmrc_ruby
	rvmrc_action="$1" 
	(( $# )) && shift || true
	if [[ "${rvmrc_action}" == "warning" ]]
	then
		rvmrc_warning_action="${1:-}" 
		(( $# )) && shift || true
	fi
	if [[ "${rvmrc_action}" == "create" ]]
	then
		rvmrc_ruby="${1:-${GEM_HOME##*/}}" 
		rvmrc_path="$(__rvm_cd "$PWD" >/dev/null 2>&1; pwd)/${2:-.rvmrc}" 
	elif [[ "$1" == ".rvmrc" ]]
	then
		rvmrc_path="$PWD/.rvmrc" 
	elif [[ "${rvmrc_action}" == "to" || "${rvmrc_action}" == "warning" ]] || [[ -n "${1:-}" ]]
	then
		rvmrc_path="$1" 
	else
		rvmrc_path="$PWD/.rvmrc" 
	fi
	if [[ "${rvmrc_action}" == "to" || "${rvmrc_action}" == "warning" || "${rvmrc_action}" == "create" ]] || __rvm_rvmrc_match_all "${rvmrc_path:-}"
	then
		true
	else
		__rvm_project_dir_check "${rvmrc_path}" rvmrc_path "${rvmrc_path}/.rvmrc"
	fi
	rvmrc_path="${rvmrc_path//\/\///}" 
	rvmrc_path="${rvmrc_path%/}" 
	case "$rvmrc_action" in
		(warning) __rvmrc_warning "${rvmrc_warning_action:-}" "$rvmrc_path" || return $? ;;
		(to) __rvm_rvmrc_to "$rvmrc_path" || return $? ;;
		(create) (
				rvm_create_flag=1 __rvm_use "${rvmrc_ruby}"
				case "${rvmrc_path}" in
					(*/.rvmrc|*/--rvmrc) __rvm_set_rvmrc ;;
					(*/.ruby-version|*/--ruby-version) __rvm_set_ruby_version ;;
					(*/.versions.conf|*/--versions-conf) __rvm_set_versions_conf ;;
					(*) rvm_error "Unrecognized project file format."
						return 1 ;;
				esac
			) ;;
		(reset) __rvm_reset_rvmrc_trust "$rvmrc_path" && rvm_log "Reset trust for $rvmrc_path" || rvm_error "Reset trust for $rvmrc_path - failed" ;;
		(trust) __rvm_trust_rvmrc "$rvmrc_path" && rvm_log "Marked $rvmrc_path as trusted" || rvm_error "Marked $rvmrc_path as trusted - failed" ;;
		(untrust) __rvm_untrust_rvmrc "$rvmrc_path" && rvm_log "Marked $rvmrc_path as untrusted" || rvm_error "Marked $rvmrc_path as untrusted - failed" ;;
		(trusted) __rvm_rvmrc_stored_trust_check "$rvmrc_path" || return $? ;;
		(is_trusted) __rvm_rvmrc_stored_trust_check "$rvmrc_path" > /dev/null ;;
		(load) rvm_current_rvmrc="" rvm_trust_rvmrcs_flag=1 __rvm_project_rvmrc "${rvmrc_path%/.rvmrc}" ;;
		(try_to_read_ruby) __rvm_rvmrc_tools_try_to_read_ruby "$@" || return $? ;;
		(*) rvm_error "Usage: rvm rvmrc {trust,untrust,trusted,load,reset,is_trusted,try_to_read_ruby,create}"
			return 1 ;;
	esac
	return $?
}
__rvm_rvmrc_tools_read_ruby () {
	\typeset __result
	\typeset -a rvmrc_tools_read_ruby
	rvmrc_tools_read_ruby=() 
	__rvm_save_variables rvmrc_tools_read_ruby rvm_current_rvmrc result current_result rvm_token next_token rvm_action _string
	rvm_current_rvmrc="" 
	rvm_action="${rvm_action:-use}" rvm_trust_rvmrcs_flag=1 __rvm_project_rvmrc "$rvmrc_path" > /dev/null && rvm_ruby_string="${GEM_HOME##*/}"  && rvm_ruby_strings="$rvm_ruby_string"  || __result=101 
	__rvm_set_env "" "${rvmrc_tools_read_ruby[@]}"
	return ${__result:-0}
}
__rvm_rvmrc_tools_try_to_read_ruby () {
	case "$rvmrc_path" in
		(*/.rvmrc) if [[ -n "${rvm_trust_rvmrcs_flag:-}" ]]
			then
				export rvm_trust_rvmrcs_flag
			fi
			rvmrc_path="$(cd "$(dirname "$rvmrc_path")"; pwd)/.rvmrc" 
			__rvm_rvmrc_tools is_trusted "$(dirname "$rvmrc_path")" .rvmrc || (
				rvm_promptless=1 __rvm_project_rvmrc "$rvmrc_path" > /dev/null 2>&1
			)
			if __rvm_rvmrc_tools is_trusted "$(dirname "$rvmrc_path")" .rvmrc
			then
				__rvm_rvmrc_tools_read_ruby "$@" || return $?
			else
				return 1
			fi ;;
		(*) __rvm_rvmrc_tools_read_ruby "$@" || return $? ;;
	esac
}
__rvm_save_variables () {
	\typeset __save_to __key
	__save_to="$1" 
	shift
	for __key in "$@"
	do
		eval "${__save_to}+=( \"\${__key}=\${${__key}}\" )"
	done
}
__rvm_sed () {
	\sed "$@" || return $?
}
__rvm_sed_i () {
	\typeset _filename _executable _user
	[[ -n "${1:-}" ]] || {
		rvm_debug "no file given for __rvm_sed_i"
		return 0
	}
	_filename="$1" 
	shift
	if [[ -x "${_filename}" ]]
	then
		_executable=true 
	fi
	_user="$( __rvm_statf "%u:%g" "%u:%g" "${_filename}" )" 
	{
		__rvm_sed "$@" < "${_filename}" > "${_filename}.new" && \command \mv -f "${_filename}.new" "${_filename}"
	} 2>&1 | rvm_debug_stream
	if [[ -n "${_executable:-}" && ! -x "${_filename}" ]]
	then
		chmod +x "${_filename}"
	fi
	if [[ "$_user" != "$( __rvm_statf "%u:%g" "%u:%g" "${_filename}" )" ]]
	then
		chown "$_user" "${_filename}"
	fi
}
__rvm_select () {
	true ${rvm_gemset_name:=}
	__rvm_select_set_variable_defaults && __rvm_select_detect_ruby_string "${1:-}" && __rvm_ruby_string && __rvm_select_after_parse || return $?
}
__rvm_select_after_parse () {
	__rvm_select_interpreter_variables && __rvm_select_version_variables && __rvm_select_default_variables || return $?
	[[ "system" == "$rvm_ruby_interpreter" ]] || __rvm_gemset_select || return $result
	rvm_ruby_selected_flag=1 
}
__rvm_select_default_variables () {
	if [[ "${rvm_ruby_interpreter}" != ext ]]
	then
		rvm_ruby_package_name="${rvm_ruby_package_name:-${rvm_ruby_string//-n*}}" 
	fi
	rvm_ruby_home="$rvm_rubies_path/$rvm_ruby_string" 
	rvm_ruby_binary="$rvm_ruby_home/bin/ruby" 
	rvm_ruby_irbrc="$rvm_ruby_home/.irbrc" 
}
__rvm_select_detect_ruby_string () {
	rvm_ruby_string="${1:-${rvm_ruby_string:-${rvm_env_string:-}}}" 
	if [[ -z "${rvm_ruby_string:-}" ]]
	then
		rvm_ruby_string="${rvm_ruby_interpreter:-}" 
		rvm_ruby_string="${rvm_ruby_string:-}${rvm_ruby_version:+-}${rvm_ruby_version:-}" 
		rvm_ruby_string="${rvm_ruby_string:-}${rvm_ruby_patch_level:+-}${rvm_ruby_patch_level:-}" 
		rvm_ruby_string="${rvm_ruby_string:-}${rvm_ruby_revision:+-}${rvm_ruby_revision:-}" 
		if [[ -n "${rvm_ruby_name:-}" ]]
		then
			rvm_ruby_name="$rvm_ruby_string-$rvm_ruby_name" 
		fi
	fi
}
__rvm_select_interpreter_common () {
	rvm_ruby_interpreter="${1}" 
	rvm_ruby_version="head" 
	rvm_ruby_patch_level="" 
	export rvm_head_flag=1 
	rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "${1}_repo_url")}" 
	rvm_ruby_url=$rvm_ruby_repo_url 
	rvm_ruby_configure="" 
	rvm_ruby_make="" 
	rvm_ruby_make_install="" 
}
__rvm_select_interpreter_current () {
	ruby_binary="$(builtin command -v ruby)" 
	if (( $? == 0)) && __rvm_string_match "$ruby_binary" "*rvm*"
	then
		rvm_ruby_string="$(dirname "$ruby_binary" | __rvm_xargs dirname | __rvm_xargs basename)" 
	else
		rvm_ruby_interpreter="system" 
	fi
}
__rvm_select_interpreter_default () {
	true
}
__rvm_select_interpreter_ext () {
	if [[ -z "${rvm_ruby_name:-${detected_rvm_ruby_name:-}}" ]]
	then
		rvm_error "External ruby name was not specified!"
		return 1
	fi
}
__rvm_select_interpreter_ironruby () {
	rvm_ruby_patch_level="" 
	if (( ${rvm_head_flag:=0} == 1 ))
	then
		rvm_ruby_version="head" 
		rvm_ruby_package_name="${rvm_ruby_string}" 
		rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "ironruby_repo_url")}" 
		rvm_ruby_url="${rvm_ruby_repo_url:-$(__rvm_db "ironruby_repo_url")}" 
		rvm_disable_binary_flag=1 
	else
		rvm_archive_extension="zip" 
		rvm_ruby_version=${rvm_ruby_version:-"$(__rvm_db "ironruby_version")"} 
		rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}" 
		rvm_ruby_package_file="${rvm_ruby_interpreter}-${rvm_ruby_version}.${rvm_archive_extension}" 
		rvm_ruby_url="$(__rvm_db "ironruby_${rvm_ruby_version}_url")" 
	fi
	export rvm_ruby_version rvm_ruby_string rvm_ruby_package_name rvm_ruby_repo_url rvm_ruby_url rvm_archive_extension
	true
}
__rvm_select_interpreter_jruby () {
	rvm_ruby_patch_level="" 
	rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "jruby_repo_url")}" 
	rvm_ruby_url="${rvm_ruby_repo_url:-$(__rvm_db "jruby_repo_url")}" 
	if (( ${rvm_head_flag:=0} == 1 ))
	then
		(( ${rvm_remote_flag:-0} == 1 )) || rvm_disable_binary_flag=1 
		rvm_ruby_version="head" 
	else
		if (( ${rvm_18_flag:-0} || ${rvm_19_flag:-0} || ${rvm_20_flag:-0} || ${#rvm_patch_names[@]} ))
		then
			rvm_disable_binary_flag=1 
		fi
		rvm_ruby_version="${rvm_ruby_version:-"$(__rvm_db "jruby_version")"}" 
		rvm_ruby_tag="${rvm_ruby_tag:-${rvm_ruby_version}}" 
	fi
	alias jruby_ng="jruby --ng"
	alias jruby_ng_server="jruby --ng-server"
	true
}
__rvm_select_interpreter_macruby () {
	if [[ "Darwin" == "${_system_type}" ]]
	then
		rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}" 
		if (( ${rvm_head_flag:=0} == 1 ))
		then
			rvm_ruby_version="" 
			rvm_ruby_tag="" 
			rvm_ruby_revision="head" 
			__rvm_db "macruby_repo_url" "rvm_ruby_repo_url"
			rvm_ruby_url="$rvm_ruby_repo_url" 
			rvm_disable_binary_flag=1 
		elif [[ "${rvm_ruby_version:-}" == *"nightly"* ]]
		then
			__rvm_select_macruby_nightly
		elif [[ -n "${rvm_ruby_version:-}" ]]
		then
			__rvm_db "macruby_${rvm_ruby_version}_url" "rvm_ruby_url"
			[[ -n "${rvm_ruby_url:-}" ]] || __rvm_db "macruby_url" "rvm_ruby_url"
			rvm_ruby_package_name="MacRuby%20${rvm_ruby_version}.zip" 
			rvm_ruby_package_file="$rvm_ruby_package_name" 
			rvm_ruby_url="$rvm_ruby_url/$rvm_ruby_package_name" 
		else
			__rvm_db "macruby_version" "rvm_ruby_version"
			__rvm_db "macruby_url" "rvm_ruby_url"
			rvm_ruby_package_name="MacRuby%20${rvm_ruby_version}.zip" 
			rvm_ruby_package_file="$rvm_ruby_package_name" 
			rvm_ruby_url="$rvm_ruby_url/$rvm_ruby_package_name" 
		fi
		rvm_ruby_patch_level="" 
	else
		rvm_error "MacRuby can only be installed on a Darwin OS."
	fi
	true
}
__rvm_select_interpreter_maglev () {
	rvm_ruby_patch_level="" 
	maglev_url="$(__rvm_db "maglev_url")" 
	system="${_system_type}" 
	if [[ "$MACHTYPE" == x86_64-apple-darwin* ]]
	then
		arch="i386" 
	else
		arch="${_system_arch}" 
	fi
	if (( ${rvm_head_flag:=0} == 1 )) || [[ "$rvm_ruby_version" == "head" ]]
	then
		rvm_head_flag=1 
		rvm_ruby_version="head" 
		rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "maglev_repo_url")}" 
		rvm_ruby_url="${rvm_ruby_repo_url:-$(__rvm_db "maglev_repo_url")}" 
		rvm_gemstone_version=$(
      __rvm_curl -s https://raw.githubusercontent.com/MagLev/maglev/master/version.txt |
        __rvm_grep "^GEMSTONE" | cut -f2 -d-
    ) 
		rvm_gemstone_package_file="GemStone-${rvm_gemstone_version}.${system}-${arch}" 
		rvm_disable_binary_flag=1 
	else
		rvm_ruby_package_file="MagLev-${rvm_ruby_version}" 
		rvm_ruby_version="${rvm_ruby_version:-"$(__rvm_db "maglev_version")"}" 
		rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}" 
		rvm_ruby_url="${rvm_ruby_url:-"$maglev_url/${rvm_ruby_package_file}.${rvm_archive_extension}"}" 
		rvm_gemstone_version=$(
      __rvm_curl -s https://raw.githubusercontent.com/MagLev/maglev/MagLev-${rvm_ruby_version}/version.txt |
        __rvm_grep "^GEMSTONE" | cut -f2 -d-
    ) 
		rvm_gemstone_package_file="GemStone-${rvm_gemstone_version}.${system}-${arch}" 
	fi
	export MAGLEV_HOME="$rvm_ruby_home" 
	export GEMSTONE_GLOBAL_DIR=$MAGLEV_HOME 
	rvm_gemstone_url="$maglev_url/${rvm_gemstone_package_file}.${rvm_archive_extension}" 
	true
}
__rvm_select_interpreter_missing () {
	return 2
}
__rvm_select_interpreter_mruby () {
	rvm_ruby_interpreter="mruby" 
	rvm_ruby_patch_level="" 
	rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "mruby_repo_url")}" 
	rvm_ruby_url=$rvm_ruby_repo_url 
	rvm_ruby_configure="" 
	rvm_ruby_make="" 
	rvm_ruby_make_install="" 
	export rvm_skip_autoreconf_flag=1 
	if [[ -z "${rvm_ruby_version:-}" ]]
	then
		rvm_head_flag=1 
	else
		rvm_head_flag=0 
		rvm_archive_extension="tar.gz" 
		rvm_ruby_package_file="${rvm_ruby_version}" 
	fi
}
__rvm_select_interpreter_opal () {
	__rvm_select_interpreter_common "opal"
}
__rvm_select_interpreter_rbx () {
	__rvm_select_rbx_nightly || return $?
	rvm_ruby_interpreter="rbx" 
	__rvm_select_rbx_compatibility_branch
	if (( ${rvm_head_flag:=1} == 0 )) && [[ -z "${rvm_ruby_repo_branch:-}" ]] && [[ "${rvm_ruby_version}" != "head" ]]
	then
		if __rvm_version_compare "${rvm_ruby_version}" -ge "2.0.0"
		then
			rbx_url="$( __rvm_db "rbx_url_2.0_and_newer" )" 
			rvm_archive_extension="tar.bz2" 
			rvm_ruby_package_file="rubinius-${rvm_ruby_version}" 
			rvm_ruby_url="${rbx_url}/${rvm_ruby_package_file}.${rvm_archive_extension}" 
		else
			rbx_url=${rbx_url:-$(__rvm_db "rbx_url")} 
			rvm_archive_extension="tar.gz" 
			rvm_ruby_package_file="rubinius-${rvm_ruby_version}" 
			rvm_ruby_url="${rbx_url}/$rvm_ruby_package_file.${rvm_archive_extension}" 
		fi
	else
		rvm_ruby_repo_url=${rvm_rbx_repo_url:-$(__rvm_db "rbx_repo_url")} 
		rvm_head_flag=1 
		rvm_ruby_patch_level="" 
		rvm_ruby_tag="${rvm_ruby_version:+v}${rvm_ruby_version:-}" 
		rvm_ruby_version="head" 
		rvm_disable_binary_flag=1 
	fi
	if [[ -n "${rvm_rbx_opt:-}" ]]
	then
		export RBXOPT="${RBXOPT:=${rvm_rbx_opt}}" 
	fi
	true
}
__rvm_select_interpreter_ree () {
	rvm_ruby_interpreter=ree 
	rvm_ruby_version=${rvm_ruby_version:-"$(__rvm_db "ree_version")"} 
	case "$rvm_ruby_version" in
		(1.8.*) true ;;
		(*) rvm_error "Unknown Ruby Enterprise Edition version: $rvm_ruby_version" ;;
	esac
	if [[ -n "${rvm_ruby_patch_level:-0}" ]]
	then
		rvm_ruby_patch_level="${rvm_ruby_patch_level#p}" 
	fi
	rvm_ruby_package_file="ruby-enterprise-$rvm_ruby_version-$rvm_ruby_patch_level" 
	rvm_ruby_url="$(__rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_version}_${rvm_ruby_patch_level}_url")" 
	rvm_ruby_url="${rvm_ruby_url:-$(__rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_version}_url")}" 
	rvm_ruby_url="${rvm_ruby_url}/$rvm_ruby_package_file.tar.gz" 
	true
}
__rvm_select_interpreter_rubinius () {
	__rvm_select_interpreter_rbx || return $?
}
__rvm_select_interpreter_ruby () {
	if [[ "${rvm_ruby_patch_level:-}" == "p0" ]] && __rvm_version_compare "${rvm_ruby_version}" -ge 2.1.0 && [[ ! -d "$rvm_rubies_path/$rvm_ruby_string" ]]
	then
		rvm_ruby_patch_level="" 
		rvm_ruby_string="${rvm_ruby_string%-p0}" 
	fi
	rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}${rvm_ruby_patch_level:+-}${rvm_ruby_patch_level:-}" 
	rvm_ruby_package_file="${rvm_ruby_package_name}" 
	if [[ -z "${rvm_ruby_version:-""}" ]] && (( ${rvm_head_flag:=0} == 0 ))
	then
		rvm_error "Ruby version was not specified!"
	else
		rvm_ruby_repo_url="${rvm_ruby_repo_url:-"$(__rvm_db "ruby_repo_url")"}" 
		if (( ${rvm_head_flag:=0} == 0 ))
		then
			if __rvm_version_compare "${rvm_ruby_version}" -lt "1.8.5"
			then
				rvm_archive_extension="tar.gz" 
			else
				rvm_archive_extension="tar.bz2" 
			fi
		else
			rvm_disable_binary_flag=1 
		fi
	fi
	true
}
__rvm_select_interpreter_system () {
	true
}
__rvm_select_interpreter_topaz () {
	__rvm_select_interpreter_common "topaz"
}
__rvm_select_interpreter_truffleruby () {
	__rvm_truffleruby_set_version
	__rvm_truffleruby_set_rvm_ruby_url
	true
}
__rvm_select_interpreter_user () {
	true
}
__rvm_select_interpreter_variables () {
	rvm_archive_extension="tar.gz" 
	if [[ -z "${rvm_ruby_interpreter:-}" ]]
	then
		rvm_ruby_interpreter="${rvm_ruby_string//-*/}" 
	fi
	rvm_ruby_interpreter="${rvm_ruby_interpreter:-missing}" 
	if is_a_function __rvm_select_interpreter_${rvm_ruby_interpreter}
	then
		__rvm_select_interpreter_${rvm_ruby_interpreter} || return $?
	elif [[ -n "${MY_RUBY_HOME:-""}" ]]
	then
		__rvm_select "${MY_RUBY_HOME##*/}" || return $?
	elif [[ -z "${rvm_ruby_string:-""}" ]]
	then
		rvm_error "Ruby implementation '$rvm_ruby_interpreter' is not known."
		return 1
	fi
}
__rvm_select_late () {
	if is_a_function __rvm_select_late_${rvm_ruby_interpreter}
	then
		__rvm_select_late_${rvm_ruby_interpreter}
	fi
}
__rvm_select_late_rbx () {
	if {
			[[ -n "${rvm_ruby_package_file:-}" && -f "${rvm_archives_path}/${rvm_ruby_package_file}" && -s "${rvm_archives_path}/${rvm_ruby_package_file}" ]]
		} || {
			[[ -n "${rvm_ruby_url:-}" ]] && file_exists_at_url "${rvm_ruby_url}"
		} || {
			[[ -n "${rbx_url:-}" && -n "${rvm_ruby_version:-}" ]] && __rvm_select_late_rbx_partial "${rbx_url}" "${rvm_ruby_version}"
		}
	then
		rvm_head_flag=0 
	else
		rvm_head_flag=1 
		if [[ "${rvm_ruby_version}" == 'head' ]]
		then
			true ${rvm_ruby_repo_branch:="master"}
		else
			true ${rvm_ruby_repo_branch:="master"} ${rvm_ruby_tag:="${rvm_ruby_version}"}
		fi
	fi
}
__rvm_select_late_rbx_partial () {
	\typeset __found __ext __patern
	__ext=".${rvm_archive_extension}" 
	__patern="${2//\./\.}.*\.${rvm_archive_extension//\./\.}\$" 
	__found="$(
    __rvm_curl -s $1/index.txt "rubinius-" |
    __rvm_awk -F"${__ext}" "/${__patern}/"'{print $1}' |
    __rvm_version_sort |
    __rvm_tail -n 1
  )" 
	if [[ -n "${__found}" ]]
	then
		rvm_ruby_version="${__found#rubinius-}" 
		rvm_ruby_string="rbx-${rvm_ruby_version}" 
		rvm_ruby_package_file="${__found}" 
		rvm_ruby_url="$1/${__found}.${rvm_archive_extension}" 
		return 0
	else
		return 1
	fi
}
__rvm_select_macruby_nightly () {
	__rvm_db "macruby_nightly_url" "rvm_ruby_url"
	case "${rvm_ruby_version:-}" in
		(nightly_*) __rvm_select_macruby_nightly_selected ;;
		(*) __rvm_select_macruby_nightly_detect ;;
	esac
	rvm_ruby_url+="/${rvm_ruby_package_file}" 
	rvm_verify_downloads_flag=1 
	rvm_debug "selected macruby $rvm_ruby_string => $rvm_ruby_url"
	true
}
__rvm_select_macruby_nightly_detect () {
	\typeset __string_version
	rvm_ruby_version="$(
    __rvm_curl -s "$rvm_ruby_url" |
    __rvm_grep -oE "<a href=\"macruby_nightly-[^<]+\.pkg</a>" |
    __rvm_awk -F"[<>]" '{print $3}' |
    __rvm_version_sort |
    __rvm_tail -n 1
  )" 
	[[ -n "${rvm_ruby_version}" ]] || {
		rvm_error "Could not find MacRuby nightly binary."
		return 1
	}
	rvm_ruby_package_file="${rvm_ruby_version}" 
	rvm_ruby_package_name="${rvm_ruby_package_file%.pkg}" 
	__string_version="${rvm_ruby_package_name#macruby_nightly-}" 
	__string_version="${__string_version//-/.}" 
	rvm_ruby_version="nightly_${__string_version}" 
	rvm_ruby_string="macruby-${rvm_ruby_version}${rvm_ruby_name:+-}${rvm_ruby_name:-}" 
	true
}
__rvm_select_macruby_nightly_selected () {
	\typeset __string_version
	__string_version="${rvm_ruby_version//./-}" 
	__string_version="${__string_version#nightly_}" 
	rvm_ruby_package_name="${rvm_ruby_interpreter}_nightly-${__string_version}" 
	rvm_ruby_package_file="$rvm_ruby_package_name.pkg" 
}
__rvm_select_rbx_compatibility_branch () {
	case "${rvm_ruby_version}" in
		(2.0pre) rvm_ruby_repo_branch="master"  ;;
		(2.0.testing) rvm_ruby_repo_branch="${rvm_ruby_version}"  ;;
	esac
	if [[ ${rvm_19_flag:-0} == 1 ]]
	then
		rvm_ruby_repo_branch="1.9.3" 
		rvm_head_flag=1 
	elif [[ ${rvm_18_flag:-0} == 1 ]]
	then
		rvm_ruby_repo_branch="1.8.7" 
		rvm_head_flag=1 
	fi
	true
}
__rvm_select_rbx_nightly () {
	(( ${rvm_nightly_flag:=0} == 1 )) || return 0
	\typeset org_rvm_ruby_patch_level _rvm_ruby_name
	if [[ "$rvm_ruby_version" == head ]]
	then
		rvm_ruby_version="" 
	fi
	rvm_debug "searching for binary rbx ${rvm_ruby_version:-}${rvm_ruby_version:+-}${rvm_ruby_patch_level}*${rvm_ruby_name:+-}${rvm_ruby_name:-}"
	org_rvm_ruby_patch_level="$rvm_ruby_patch_level" 
	_rvm_ruby_name="${rvm_ruby_name:-${detected_rvm_ruby_name:-}}" 
	rvm_ruby_patch_level="$(
    __list_remote_all |
      __rvm_grep ${rvm_ruby_version:-}${rvm_ruby_version:+-}${org_rvm_ruby_patch_level}.*${_rvm_ruby_name:+-}${_rvm_ruby_name:-} |
      __rvm_tail -n 1
  )" 
	[[ -n "${rvm_ruby_patch_level:-}" ]] || {
		rvm_error "Could not find rbx binary '${rvm_ruby_version:-}${rvm_ruby_version:+-}${org_rvm_ruby_patch_level}*${rvm_ruby_name:+-}${rvm_ruby_name:-}' binary release."
		return 1
	}
	rvm_ruby_patch_level="${rvm_ruby_patch_level##*/}" 
	rvm_ruby_patch_level="${rvm_ruby_patch_level%.tar.*}" 
	if [[ -z "${rvm_ruby_version:-}" ]]
	then
		rvm_ruby_patch_level="${rvm_ruby_patch_level#rubinius-}" 
		rvm_ruby_version="${rvm_ruby_patch_level%%-*}" 
	fi
	if [[ -z "${rvm_ruby_name:-}" ]]
	then
		rvm_ruby_name="${rvm_ruby_patch_level##*-}" 
	fi
	rvm_ruby_patch_level="${rvm_ruby_patch_level##*${org_rvm_ruby_patch_level}}" 
	rvm_ruby_patch_level="${rvm_ruby_patch_level%%-*}" 
	rvm_ruby_patch_level="${org_rvm_ruby_patch_level}${rvm_ruby_patch_level}" 
	rvm_ruby_string="rubinius-${rvm_ruby_version}-${rvm_ruby_patch_level}-${rvm_ruby_name}" 
	rvm_debug "detected rbx ${rvm_ruby_string}"
	rvm_verify_downloads_flag=1 
	true
}
__rvm_select_set_variable_defaults () {
	export GEM_HOME GEM_PATH MY_RUBY_HOME RUBY_VERSION IRBRC
	export rvm_env_string rvm_action rvm_alias_expanded rvm_archive_extension rvm_bin_flag rvm_bin_path rvm_debug_flag rvm_default_flag rvm_delete_flag rvm_docs_type rvm_dump_environment_flag rvm_error_message rvm_expanding_aliases rvm_file_name rvm_gemdir_flag rvm_gemset_name rvm_gemstone_package_file rvm_gemstone_url rvm_head_flag rvm_hook rvm_install_on_use_flag rvm_llvm_flag rvm_loaded_flag rvm_niceness rvm_nightly_flag rvm_only_path_flag rvm_parse_break rvm_patch_original_pwd rvm_pretty_print_flag rvm_proxy rvm_quiet_flag rvm_reload_flag rvm_remove_flag rvm_ruby_alias rvm_ruby_args rvm_ruby_binary rvm_ruby_bits rvm_ruby_configure rvm_ruby_file rvm_ruby_gem_home rvm_ruby_gem_path rvm_ruby_global_gems_path rvm_ruby_home rvm_ruby_interpreter rvm_ruby_irbrc rvm_ruby_major_version rvm_ruby_make rvm_ruby_make_install rvm_ruby_minor_version rvm_ruby_mode rvm_ruby_name rvm_ruby_package_file rvm_ruby_package_name rvm_ruby_patch rvm_ruby_patch_level rvm_ruby_release_version rvm_ruby_repo_url rvm_ruby_revision rvm_ruby_selected_flag rvm_ruby_sha rvm_ruby_string rvm_ruby_strings rvm_ruby_tag rvm_ruby_url rvm_ruby_user_tag rvm_ruby_version rvm_script_name rvm_sdk rvm_silent_flag rvm_sticky_flag rvm_system_flag rvm_token rvm_trace_flag rvm_use_flag rvm_user_flag rvm_verbose_flag rvm_ruby_repo_tag
}
__rvm_select_version_variables () {
	case "$rvm_ruby_version" in
		(+([0-9]).+([0-9]).+([0-9])) rvm_ruby_release_version="${rvm_ruby_version/.*/}" 
			rvm_ruby_major_version=${rvm_ruby_version%.*} 
			rvm_ruby_major_version=${rvm_ruby_major_version#*.} 
			rvm_ruby_minor_version="${rvm_ruby_version//*.}"  ;;
		(+([0-9]).+([0-9])) rvm_ruby_release_version="${rvm_ruby_version/.*/}" 
			rvm_ruby_major_version="${rvm_ruby_version#*.}" 
			rvm_ruby_minor_version=""  ;;
	esac
}
__rvm_set_color () {
	\typeset __buffer __variable
	__buffer=$'\E[' 
	__variable="$1" 
	shift
	while (( $# ))
	do
		__rvm_set_color_single "$1"
		shift
		if (( $# ))
		then
			__buffer+=';' 
		fi
	done
	__buffer+='m' 
	if [[ "${__variable}" == "" || "${__variable}" == "print" ]]
	then
		printf "${__buffer}"
	else
		eval "${__variable}='${__buffer}'"
	fi
}
__rvm_set_color_single () {
	case "$1" in
		(bold) __buffer+='7'  ;;
		(offbold) __buffer+='27'  ;;
		(black) __buffer+='30'  ;;
		(red) __buffer+='31'  ;;
		(green) __buffer+='32'  ;;
		(yellow) __buffer+='33'  ;;
		(blue) __buffer+='34'  ;;
		(magenta) __buffer+='35'  ;;
		(cyan) __buffer+='36'  ;;
		(white) __buffer+='37'  ;;
		(default) __buffer+='39'  ;;
		(iblack) __buffer+='30;1'  ;;
		(ired) __buffer+='31;1'  ;;
		(igreen) __buffer+='32;1'  ;;
		(iyellow) __buffer+='33;1'  ;;
		(iblue) __buffer+='34;1'  ;;
		(imagenta) __buffer+='35;1'  ;;
		(icyan) __buffer+='36;1'  ;;
		(iwhite) __buffer+='37;1'  ;;
		(bblack) __buffer+='40'  ;;
		(bred) __buffer+='41'  ;;
		(bgreen) __buffer+='42'  ;;
		(byellow) __buffer+='43'  ;;
		(bblue) __buffer+='44'  ;;
		(bmagenta) __buffer+='45'  ;;
		(bcyan) __buffer+='46'  ;;
		(bwhite) __buffer+='47'  ;;
		(bdefault) __buffer+='49'  ;;
		(*) __buffer+='0'  ;;
	esac
}
__rvm_set_colors () {
	case "${TERM:-dumb}" in
		(dumb|unknown) rvm_error_clr="" 
			rvm_warn_clr="" 
			rvm_debug_clr="" 
			rvm_notify_clr="" 
			rvm_code_clr="" 
			rvm_comment_clr="" 
			rvm_reset_clr=""  ;;
		(*) __rvm_set_color rvm_error_clr "${rvm_error_color:-red}"
			__rvm_set_color rvm_warn_clr "${rvm_warn_color:-yellow}"
			__rvm_set_color rvm_debug_clr "${rvm_debug_color:-magenta}"
			__rvm_set_color rvm_notify_clr "${rvm_notify_color:-green}"
			__rvm_set_color rvm_code_clr "${rvm_code_color:-blue}"
			__rvm_set_color rvm_comment_clr "${rvm_comment_color:-iblack}"
			__rvm_set_color rvm_reset_clr "${rvm_reset_color:-reset}" ;;
	esac
}
__rvm_set_env () {
	\typeset __save_to __set __key __value
	__save_to="$1" 
	shift
	for __set in "$@"
	do
		__key="${__set%%=*}" 
		__value="${__set#*=}" 
		case "$__value" in
			(\"*\") __value="${__value#\"}" 
				__value="${__value%\"}"  ;;
			(\'*\') __value="${__value#\'}" 
				__value="${__value%\'}"  ;;
		esac
		rvm_debug "key=$__key; value=$__value;"
		if [[ -n "${__save_to}" ]]
		then
			eval "${__save_to}+=( \"\${__key}=\${${__key}}\" )"
		fi
		if [[ -n "${__value}" ]]
		then
			eval "export \${__key}=\"\${__value}\""
		else
			eval "unset \${__key}"
		fi
	done
}
__rvm_set_executable () {
	for __file
	do
		[[ -x "${__file}" ]] || chmod +x "${__file}"
	done
}
__rvm_set_ruby_version () {
	if [[ -s .ruby-version ]]
	then
		\command \mv .ruby-version .ruby-version.$(__rvm_date +%m.%d.%Y-%H:%M:%S)
		rvm_warn ".ruby-version is not empty, moving aside to preserve."
	fi
	\typeset __version="$(__rvm_env_string)"
	case "${__version}" in
		(*@*) if [[ -s .ruby-gemset ]]
			then
				\command \mv .ruby-gemset .ruby-gemset.$(__rvm_date +%m.%d.%Y-%H:%M:%S)
				rvm_warn ".ruby-gemset is not empty, moving aside to preserve."
			fi
			echo "${__version##*@}" > .ruby-gemset ;;
		(*) if [[ -s .ruby-gemset ]]
			then
				\command \mv .ruby-gemset .ruby-gemset.$(__rvm_date +%m.%d.%Y-%H:%M:%S)
				rvm_warn ".ruby-gemset not needed, moving aside to preserve."
			fi ;;
	esac
	echo "${__version%@*}" > .ruby-version
}
__rvm_set_rvmrc () {
	\typeset flags identifier short_identifier gem_file
	true ${rvm_verbose_flag:=0}
	if [[ "$HOME" != "$PWD" && "${rvm_prefix:-}" != "$PWD" ]]
	then
		if (( rvm_verbose_flag ))
		then
			flags="use " 
		fi
		if [[ -s .rvmrc ]]
		then
			\command \mv .rvmrc .rvmrc.$(__rvm_date +%m.%d.%Y-%H:%M:%S)
			rvm_warn ".rvmrc is not empty, moving aside to preserve."
		fi
		identifier=$(__rvm_env_string) 
		short_identifier="${identifier#ruby-}" 
		short_identifier="${short_identifier%%-*}" 
		printf "%b" "#!/usr/bin/env bash

# This is an RVM Project .rvmrc file, used to automatically load the ruby
# development environment upon cd'ing into the directory

# First we specify our desired <ruby>[@<gemset>], the @gemset name is optional,
# Only full ruby name is supported here, for short names use:
#     echo \"rvm use ${short_identifier}\" > .rvmrc
environment_id=\"$identifier\"

# Uncomment the following lines if you want to verify rvm version per project
# rvmrc_rvm_version=\"${rvm_version}\" # 1.10.1 seems like a safe start
# eval \"\$(echo \${rvm_version}.\${rvmrc_rvm_version} | awk -F. '{print \"[[ \"\$1*65536+\$2*256+\$3\" -ge \"\$4*65536+\$5*256+\$6\" ]]\"}' )\" || {
#   echo \"This .rvmrc file requires at least RVM \${rvmrc_rvm_version}, aborting loading.\"
#   exit 1
# }
" >> .rvmrc
		if __rvm_string_match "$identifier" "jruby*"
		then
			printf "%b" "
# Uncomment following line if you want options to be set only for given project.
# PROJECT_JRUBY_OPTS=( --1.9 )
# The variable PROJECT_JRUBY_OPTS requires the following to be run in shell:
#    chmod +x \${rvm_path}/hooks/after_use_jruby_opts
" >> .rvmrc
		fi
		printf "%b" "
# First we attempt to load the desired environment directly from the environment
# file. This is very fast and efficient compared to running through the entire
# CLI and selector. If you want feedback on which environment was used then
# insert the word 'use' after --create as this triggers verbose mode.
if [[ -d \"\${rvm_path:-\$HOME/.rvm}/environments\"
  && -s \"\${rvm_path:-\$HOME/.rvm}/environments/\$environment_id\" ]]
then
  \\. \"\${rvm_path:-\$HOME/.rvm}/environments/\$environment_id\"
  for __hook in \"\${rvm_path:-\$HOME/.rvm}/hooks/after_use\"*
  do
    if [[ -f \"\${__hook}\" && -x \"\${__hook}\" && -s \"\${__hook}\" ]]
    then \\. \"\${__hook}\" || true
    fi
  done
  unset __hook
" >> .rvmrc
		if [[ " $flags " == *" use "* ]]
		then
			printf "%b" "  if (( \${rvm_use_flag:=1} >= 1 )) # display automatically" >> .rvmrc
		else
			printf "%b" "  if (( \${rvm_use_flag:=1} >= 2 )) # display only when forced" >> .rvmrc
		fi
		printf "%b" "
  then
    if [[ \$- == *i* ]] # check for interactive shells
    then printf \"%b\" \"Using: \$(tput setaf 2 2>/dev/null)\$GEM_HOME\$(tput sgr0 2>/dev/null)\\\\n\" # show the user the ruby and gemset they are using in green
    else printf \"%b\" \"Using: \$GEM_HOME\\\\n\" # don't use colors in non-interactive shells
    fi
  fi
" >> .rvmrc
		printf "%b" "else
  # If the environment file has not yet been created, use the RVM CLI to select.
  rvm --create $flags \"\$environment_id\" || {
    echo \"Failed to create RVM environment '\${environment_id}'.\"
    return 1
  }
fi
" >> .rvmrc
		for gem_file in *.gems
		do
			case "$gem_file" in
				(\*.gems) continue ;;
			esac
			printf "%b" "
# If you use an RVM gemset file to install a list of gems (*.gems), you can have
# it be automatically loaded. Uncomment the following and adjust the filename if
# necessary.
#
# filename=\".gems\"
# if [[ -s \"\$filename\" ]]
# then
#   rvm gemset import \"\$filename\" | GREP_OPTIONS=\"\" \\\\command \\grep -v already | GREP_OPTIONS=\"\" \command \grep -v listed | GREP_OPTIONS=\"\" \command \grep -v complete | \command \sed '/^$/d'
# fi
" >> .rvmrc
		done
		if [[ -s Gemfile ]]
		then
			printf "%b" "
# If you use bundler, this might be useful to you:
# if [[ -s Gemfile ]] && {
#   ! builtin command -v bundle >/dev/null ||
#   builtin command -v bundle | GREP_OPTIONS=\"\" \\\\command \\grep \$rvm_path/bin/bundle >/dev/null
# }
# then
#   printf \"%b\" \"The rubygem 'bundler' is not installed. Installing it now.\\\\n\"
#   gem install bundler
# fi
# if [[ -s Gemfile ]] && builtin command -v bundle >/dev/null
# then
#   bundle install | GREP_OPTIONS=\"\" \\\\command \\grep -vE '^Using|Your bundle is complete'
# fi
" >> .rvmrc
		fi
	else
		rvm_error ".rvmrc cannot be set in your home directory.      \nThe home .rvmrc is for global rvm settings only."
	fi
}
__rvm_set_versions_conf () {
	\typeset gemset identifier
	if [[ -s .versions.conf ]]
	then
		\command \mv .versions.conf .versions.conf.$(__rvm_date +%m.%d.%Y-%H:%M:%S)
		rvm_warn ".version.conf is not empty, moving aside to preserve."
	fi
	identifier=$(__rvm_env_string) 
	gemset=${identifier#*@} 
	identifier=${identifier%@*} 
	printf "%b" "ruby=$identifier
" >> .versions.conf
	if [[ -n "$gemset" && "$gemset" != "$identifier" ]]
	then
		printf "%b" "ruby-gemset=$gemset
" >> .versions.conf
	else
		printf "%b" "#ruby-gemset=my-projectit
" >> .versions.conf
	fi
	printf "%b" "#ruby-gem-install=bundler rake
#ruby-bundle-install=true
" >> .versions.conf
}
__rvm_setup () {
	__variables_definition export
	if (( __rvm_env_loaded != 1 ))
	then
		return 0
	fi
	if [[ -n "${BASH_VERSION:-}" ]] && ! __function_on_stack cd pushd popd
	then
		export rvm_shell_nounset
		if __rvm_has_opt "nounset"
		then
			rvm_bash_nounset=1 
		else
			rvm_bash_nounset=0 
		fi
		set +o nounset
		_rvm_old_traps=$( trap | __rvm_grep -E 'EXIT|HUP|INT|QUIT|TERM' || true ) 
		trap '__rvm_teardown_final ; set +x' EXIT HUP INT QUIT TERM
	fi
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		export rvm_zsh_clobber rvm_zsh_nomatch
		if setopt | __rvm_grep -s '^noclobber$' > /dev/null 2>&1
		then
			rvm_zsh_clobber=0 
		else
			rvm_zsh_clobber=1 
		fi
		setopt clobber
		if setopt | __rvm_grep -s '^nonomatch$' > /dev/null 2>&1
		then
			rvm_zsh_nomatch=0 
		else
			rvm_zsh_nomatch=1 
		fi
		setopt no_nomatch
	fi
}
__rvm_setup_statf_function () {
	if [[ "${_system_type}" == Darwin || "${_system_type}" == BSD ]]
	then
		__rvm_statf () {
			__rvm_stat -f "$2" "$3"
		}
	else
		__rvm_statf () {
			__rvm_stat -c "$1" "$3"
		}
	fi
}
__rvm_setup_sudo_function () {
	if is_a_function __rvm_setup_sudo_function_${_system_name}
	then
		__rvm_setup_sudo_function_${_system_name} "$@" || return $?
	else
		__rvm_setup_sudo_function_Other "$@" || return $?
	fi
}
__rvm_setup_sudo_function_Other () {
	if __rvm_which sudo > /dev/null 2>&1
	then
		__rvm_sudo () {
			\command \sudo "$@"
		}
	else
		rvm_debug "Warning: No 'sudo' found."
	fi
}
__rvm_setup_sudo_function_PCLinuxOS () {
	__rvm_sudo () {
		if [[ "$1" == "-p" ]]
		then
			rvm_printf_to_stderr "${2//%p/[root]/}"
			shift 2
		fi
		su -c "$*"
	}
}
__rvm_setup_sudo_function_Solaris () {
	if [[ -x /opt/csw/bin/sudo ]]
	then
		__rvm_sudo () {
			/opt/csw/bin/sudo "$@"
		}
	elif [[ -x /usr/bin/sudo ]]
	then
		__rvm_sudo () {
			/usr/bin/sudo "$@"
		}
	else
		rvm_debug "Warning: No '/opt/csw/bin/sudo' found."
	fi
}
__rvm_setup_utils_functions () {
	\typeset gnu_tools_path gnu_prefix gnu_util
	\typeset -a gnu_utils gnu_missing
	gnu_utils=(awk cp date find sed tail tar xargs) 
	gnu_missing=() 
	if is_a_function __rvm_setup_utils_functions_${_system_name}
	then
		__rvm_setup_utils_functions_${_system_name} "$@" || return $?
	else
		__rvm_setup_utils_functions_Other "$@" || return $?
	fi
}
__rvm_setup_utils_functions_OSX () {
	if [[ -x /usr/bin/stat ]]
	then
		__rvm_stat () {
			/usr/bin/stat "$@" || return $?
		}
	else
		rvm_error "ERROR: Missing (executable) /usr/bin/stat. Falling back to '\\\\command \\\\stat' which might be something else."
		__rvm_stat () {
			\command \stat "$@" || return $?
		}
	fi
	__rvm_setup_utils_functions_common
}
__rvm_setup_utils_functions_Other () {
	__rvm_stat () {
		\command \stat "$@" || return $?
	}
	__rvm_setup_utils_functions_common
}
__rvm_setup_utils_functions_Solaris () {
	case "${_system_version}" in
		(10) gnu_tools_path=/opt/csw/bin 
			gnu_prefix="g"  ;;
		(11) gnu_tools_path=/usr/gnu/bin 
			gnu_prefix=""  ;;
	esac
	if [[ -x $gnu_tools_path/${gnu_prefix}grep ]]
	then
		eval "__rvm_grep() { GREP_OPTIONS=\"\" $gnu_tools_path/${gnu_prefix}grep \"\$@\" || return \$?; }"
	else
		gnu_missing+=(${gnu_prefix}grep) 
	fi
	if [[ "${_system_name}" == "OpenIndiana" || "${_system_version}" == "11" ]]
	then
		__rvm_stat () {
			\command \stat "$@" || return $?
		}
	elif [[ -x $gnu_tools_path/${gnu_prefix}stat ]]
	then
		eval "__rvm_stat() { $gnu_tools_path/${gnu_prefix}stat \"\$@\" || return \$?; }"
	else
		gnu_missing+=(${gnu_prefix}stat) 
	fi
	if [[ "${_system_name}" == "SmartOS" ]]
	then
		__rvm_which () {
			\command \which "$@" || return $?
		}
	elif [[ -x $gnu_tools_path/${gnu_prefix}which ]]
	then
		eval "__rvm_which() { $gnu_tools_path/${gnu_prefix}which \"\$@\" || return \$?; }"
	else
		gnu_missing+=(${gnu_prefix}which) 
	fi
	for gnu_util in "${gnu_utils[@]}"
	do
		if [[ -x $gnu_tools_path/$gnu_prefix$gnu_util ]]
		then
			eval "__rvm_$gnu_util() { $gnu_tools_path/$gnu_prefix$gnu_util \"\$@\" || return \$?; }"
		else
			gnu_missing+=($gnu_prefix$gnu_util) 
		fi
	done
	if (( ${#gnu_missing[@]} ))
	then
		rvm_error "ERROR: Missing GNU tools: ${gnu_missing[@]}. Make sure they are installed in '$gnu_tools_path/' before using RVM!"
		if [[ "${_system_name} ${_system_version}" == "Solaris 10" ]]
		then
			rvm_error "You might want to look at OpenCSW project to install the above mentioned tools (https://www.opencsw.org/about)"
		fi
		exit 200
	fi
}
__rvm_setup_utils_functions_common () {
	__rvm_grep () {
		GREP_OPTIONS="" \command \grep "$@" || return $?
	}
	if \command \which --skip-alias --skip-functions which > /dev/null 2>&1
	then
		__rvm_which () {
			\command \which --skip-alias --skip-functions "$@" || return $?
		}
	elif \command \which whence > /dev/null 2>&1 && \command \whence whence > /dev/null 2>&1
	then
		__rvm_which () {
			\command \whence -p "$@" || return $?
		}
	elif \command \which which > /dev/null 2>&1
	then
		__rvm_which () {
			\command \which "$@" || return $?
		}
	elif \which which > /dev/null 2>&1
	then
		__rvm_which () {
			\which "$@" || return $?
		}
	else
		\typeset __result=$?
		rvm_error "ERROR: Missing proper 'which' command. Make sure it is installed before using RVM!"
		return ${__result}
	fi
	for gnu_util in "${gnu_utils[@]}"
	do
		eval "__rvm_$gnu_util() { \\$gnu_util \"\$@\" || return \$?; }"
	done
}
__rvm_sha256_for_contents () {
	if builtin command -v sha256sum > /dev/null
	then
		sha256sum | __rvm_awk '{print $1}'
	elif builtin command -v sha256 > /dev/null
	then
		sha256 | __rvm_awk '{print $1}'
	elif builtin command -v shasum > /dev/null
	then
		shasum -a256 | __rvm_awk '{print $1}'
	elif builtin command -v openssl > /dev/null
	then
		openssl sha -sha256 | __rvm_awk '{print $1}'
	else
		return 1
	fi
	true
}
__rvm_sha__calculate () {
	rvm_debug "Calculate sha512 checksum for $@"
	\typeset bits _sum
	bits=${1:-512} 
	shift
	if builtin command -v sha${bits}sum > /dev/null
	then
		_sum=$(sha${bits}sum    "$@") 
		echo ${_sum% *}
		return 0
	elif builtin command -v sha${bits} > /dev/null
	then
		_sum=$(sha${bits}       "$@") 
		if [[ "${_sum%% *}" == "SHA${bits}" ]]
		then
			echo ${_sum##* }
		else
			echo ${_sum% *}
		fi
		return 0
	elif builtin command -v shasum > /dev/null
	then
		_sum=$(shasum -a${bits} "$@") 
		echo ${_sum% *}
		return 0
	elif builtin command -v /opt/csw/bin/shasum > /dev/null
	then
		_sum=$(/opt/csw/bin/shasum -a${bits} "$@") 
		echo ${_sum% *}
		return 0
	fi
	rvm_error "Neither sha512sum nor shasum found in the PATH"
	return 1
}
__rvm_stat () {
	\command \stat "$@" || return $?
}
__rvm_statf () {
	__rvm_stat -f "$2" "$3"
}
__rvm_string_includes () {
	\typeset __search __text="$1"
	shift
	for __search in "$@"
	do
		if [[ " ${__text} " == *" ${__search} "* ]]
		then
			return 0
		fi
	done
	return 1
}
__rvm_string_match () {
	\typeset _string _search
	_string="$1" 
	shift
	while (( $# ))
	do
		_search="$1" 
		_search="${_search// /[[:space:]]}" 
		_search="${_search//\#/\#}" 
		eval "      case \"\${_string}\" in        ($_search) return 0 ;;      esac      "
		shift
	done
	return 1
}
__rvm_strings () {
	\typeset strings ruby_strings
	ruby_strings=($(echo ${rvm_ruby_args:-$rvm_ruby_string})) 
	for rvm_ruby_string in "${ruby_strings[@]}"
	do
		strings="$strings $(__rvm_select ; echo $rvm_ruby_string)" 
	done
	echo $strings
	return 0
}
__rvm_strip () {
	__rvm_sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/[[:space:]]\{1,\}/ /g'
	return $?
}
__rvm_sudo () {
	\command \sudo "$@"
}
__rvm_switch () {
	\typeset new_rvm_path new_rvm_bin_path
	(( $# )) && [[ -z "$1" ]] && shift || true
	(( $# )) && [[ -n "$1" ]] && [[ -d "$1" || -d "${1%/*}" ]] && [[ ! -f "$1" ]] || {
		rvm_error "No valid path given."
		return 1
	}
	[[ "${rvm_path}" != "${new_rvm_path}" ]] || {
		rvm_warn "Already there!"
		return 2
	}
	rvm_log "Switching ${rvm_path} => ${1}"
	new_rvm_path="${1%/}" 
	new_rvm_bin_path="${2:-$new_rvm_path/bin}" 
	new_rvm_bin_path="${new_rvm_bin_path%/}" 
	__rvm_use_system
	__rvm_remove_from_path "${rvm_path%/}/*"
	rvm_reload_flag=1 
	rvm_path="${new_rvm_path}" 
	rvm_bin_path="${new_rvm_bin_path}" 
	rvm_scripts_path="${rvm_path}/scripts" 
	rvm_environments_path="${rvm_path}/environments" 
	__rvm_remove_from_path "${rvm_path%/}/*"
	__rvm_add_to_path prepend "${rvm_bin_path}"
}
__rvm_system_path () {
	rvm_remote_server_path="$(__rvm_db "rvm_remote_server_path${2:-}")" 
	[[ -n "${rvm_remote_server_path}" ]] || rvm_remote_server_path="${_system_name_lowercase}/${_system_version}/${_system_arch}" 
	if [[ "${1:-}" == "-" ]]
	then
		printf "%b" "${rvm_remote_server_path}\n"
	fi
}
__rvm_table () {
	if [[ -n "${1:-}" ]]
	then
		__rvm_table_br
		echo "$1" | __rvm_table_wrap_text
	fi
	__rvm_table_br
	\command \cat "${2:--}" | __rvm_table_wrap_text
	__rvm_table_br
}
__rvm_table_br () {
	\typeset width=${COLUMNS:-78}
	width=$(( width > 116 ? 116 : width )) 
	printf "%-${width}s\n" " " | __rvm_sed 's/ /*/g'
}
__rvm_table_wrap_text () {
	\typeset width=${COLUMNS:-78}
	width=$(( width > 116 ? 116 : width )) 
	width=$(( width - 4 )) 
	__rvm_fold $width | __rvm_awk -v width=$width '{printf "* %-"width"s *\n", $0}'
}
__rvm_tail () {
	\tail "$@" || return $?
}
__rvm_take_n () {
	\typeset IFS __temp_counter
	\typeset -a __temp_arr1 __temp_arr2
	IFS=$3 
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		eval "__temp_arr1=( \${=$1} )"
	else
		eval "__temp_arr1=( \$$1 )"
	fi
	__temp_counter=0 
	__temp_arr2=() 
	while (( __temp_counter < $2 ))
	do
		__temp_arr2+=("${__temp_arr1[__array_start+__temp_counter++]}") 
	done
	eval "$1=\"\${__temp_arr2[*]}\""
}
__rvm_tar () {
	\tar "$@" || return $?
}
__rvm_teardown () {
	if builtin command -v __rvm_cleanup_tmp > /dev/null 2>&1
	then
		__rvm_cleanup_tmp
	fi
	export __rvm_env_loaded
	: __rvm_env_loaded:${__rvm_env_loaded:=${rvm_tmp_path:+1}}:
	: __rvm_env_loaded:${__rvm_env_loaded:=0}:
	: __rvm_env_loaded:$(( __rvm_env_loaded-=1 )):
	if [[ -z "${rvm_tmp_path:-}" ]] || (( __rvm_env_loaded > 0 ))
	then
		return 0
	fi
	if [[ -n "${BASH_VERSION:-}" ]]
	then
		trap - EXIT HUP INT QUIT TERM
		if [[ -n "${_rvm_old_traps:-}" ]]
		then
			eval "${_rvm_old_traps}"
		fi
		(( rvm_bash_nounset == 1 )) && set -o nounset
		unset rvm_bash_nounset
	fi
	if [[ -n "${ZSH_VERSION:-""}" ]]
	then
		(( rvm_zsh_clobber == 0 )) && setopt noclobber
		(( rvm_zsh_nomatch == 0 )) || setopt nomatch
		unset rvm_zsh_clobber rvm_zsh_nomatch
	fi
	if [[ -n "${rvm_stored_umask:-}" ]]
	then
		umask ${rvm_stored_umask}
		unset rvm_stored_umask
	fi
	if builtin command -v __rvm_cleanup_download > /dev/null 2>&1
	then
		__rvm_cleanup_download
	fi
	if [[ "${rvm_stored_errexit:-""}" == "1" ]]
	then
		set -e
	fi
	__variables_definition unset
	unset _system_arch _system_name _system_type _system_version
	return 0
}
__rvm_teardown_final () {
	__rvm_env_loaded=1 
	unset __rvm_project_rvmrc_lock
	__rvm_teardown
}
__rvm_teardown_if_broken () {
	if __function_on_stack __rvm_load_project_config || __function_on_stack __rvm_with
	then
		true
	elif (( ${__rvm_env_loaded:-0} > 0 ))
	then
		__rvm_teardown_final
	fi
}
__rvm_truffleruby_set_rvm_ruby_url () {
	case "${_system_type}" in
		(Linux) platform="linux"  ;;
		(Darwin) platform="macos"  ;;
		(*) rvm_error "TruffleRuby does not support ${_system_type} currently." ;;
	esac
	case "${_system_arch}" in
		(x86_64) arch=amd64  ;;
		(*) rvm_error "TruffleRuby does not support ${_system_arch} currently." ;;
	esac
	rvm_ruby_package_name="truffleruby-${truffleruby_version}" 
	if (( ${rvm_head_flag:=0} == 1 ))
	then
		case "$platform" in
			(linux) platform="ubuntu-18.04"  ;;
			(macos) platform="macos-latest"  ;;
		esac
		rvm_ruby_package_file="${rvm_ruby_package_name}-${platform}" 
		rvm_ruby_url="${rvm_ruby_repo_url:-https://github.com/ruby/truffleruby-dev-builder/releases/latest/download/${rvm_ruby_package_file}.tar.gz}" 
	else
		rvm_ruby_package_file="${rvm_ruby_package_name}-${platform}-${arch}" 
		rvm_ruby_url="${rvm_ruby_repo_url:-$(__rvm_db "truffleruby_url")/vm-${truffleruby_version}/${rvm_ruby_package_file}.tar.gz}" 
	fi
	true
}
__rvm_truffleruby_set_version () {
	if (( ${rvm_head_flag:=0} == 1 ))
	then
		rvm_ruby_version="head" 
		truffleruby_version="head" 
	else
		rvm_ruby_version="${rvm_ruby_version:-$(__rvm_db "truffleruby_version")}" 
		truffleruby_version="${rvm_ruby_version}${rvm_ruby_patch_level:+-}${rvm_ruby_patch_level:-}" 
	fi
	true
}
__rvm_trust_rvmrc () {
	[[ -f "$1" ]] || return 1
	__rvm_reset_rvmrc_trust "$1"
	__rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" "1;$(__rvm_checksum_for_contents "$1")" > /dev/null 2>&1 || return $?
}
__rvm_try_sudo () {
	(
		\typeset -a command_to_run
		\typeset sudo_path sbin_path missing_paths
		command_to_run=("$@") 
		(( UID == 0 )) || case "$rvm_autolibs_flag_number" in
			(0) rvm_debug "Running '$*' would require sudo."
				return 0 ;;
			(1) rvm_warn "Running '$*' would require sudo."
				return 0 ;;
			(2) rvm_requiremnts_fail error "Running '$*' would require sudo."
				return 1 ;;
			(*) if is_a_function __rvm_sudo
				then
					missing_paths="" 
					for sbin_path in /sbin /usr/sbin /usr/local/sbin
					do
						if [[ -d "${sbin_path}" ]] && [[ ":$PATH:" != *":${sbin_path}:"* ]]
						then
							missing_paths+=":${sbin_path}" 
						fi
					done
					if [[ -n "${missing_paths}" ]]
					then
						command_to_run=(/usr/bin/env PATH="${PATH}${missing_paths}" "${command_to_run[@]}") 
					fi
					command_to_run=(__rvm_sudo -p "%p password required for '$*': " "${command_to_run[@]}") 
				else
					rvm_error "Running '$*' would require sudo, but 'sudo' is not found!"
					return 1
				fi ;;
		esac
		"${command_to_run[@]}" || return $?
	)
}
__rvm_unload () {
	\typeset _element
	\typeset -a _list
	__rvm_remove_rvm_from_path
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		__rvm_remove_from_array fpath "$rvm_path/scripts/extras/completion.zsh" "${fpath[@]}"
	fi
	__rvm_unload_action unalias <<< "$(
    if [[ -n "${ZSH_VERSION:-}" ]]
    then alias | __rvm_awk -F"=" '/rvm/ {print $1}'
    else alias | __rvm_awk -F"[= ]" '/rvm/ {print $2}'
    fi
  )"
	__rvm_unload_action unset <<< "$(
    set |
      __rvm_awk -F"=" 'BEGIN{v=0;} /^[a-zA-Z_][a-zA-Z0-9_]*=/{v=1;} v==1&&$2~/^['\''\$]/{v=2;}
        v==1&&$2~/^\(/{v=3;} v==2&&/'\''$/&&!/'\'\''$/{v=1;} v==3&&/\)$/{v=1;} v{print;} v==1{v=0;}' |
      __rvm_awk -F"=" '/^[^ ]*(RUBY|GEM|IRB|gem|rubies|rvm)[^ ]*=/ {print $1} /^[^ ]*=.*rvm/ {print $1}' |
      __rvm_grep -vE "^PROMPT|^prompt|^PS|^BASH_SOURCE|^PATH"
  )"
	__rvm_unload_action __function_unset <<< "$(
    \typeset -f | __rvm_awk '$2=="()" {fun=$1} /rvm/{print fun}' | sort -u | __rvm_grep -v __rvm_unload_action
  )"
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		unset -f __rvm_unload_action
		unset -f __function_unset
		if [[ -n "${_comp_dumpfile:-}" ]]
		then
			\command \rm -f "$_comp_dumpfile"
			compinit -d "$_comp_dumpfile"
		fi
	else
		unset __rvm_unload_action __function_unset
	fi
}
__rvm_unload_action () {
	\typeset _element IFS
	\typeset -a _list
	IFS=$'\n' 
	_list=($( \command \cat ${2:--} | sort -u )) 
	for _element in "${_list[@]}"
	do
		$1 "${_element}"
	done
}
__rvm_unset_exports () {
	\typeset wrap_name name value
	\typeset -a __variables_list
	__rvm_read_lines __variables_list <<< "$(
    printenv | __rvm_sed '/^rvm_old_.*=/ { s/=.*$//; p; }; d;'
  )"
	for wrap_name in "${__variables_list[@]}"
	do
		eval "value=\"\${${wrap_name}}\""
		name=${wrap_name#rvm_old_} 
		if [[ -n "${value:-}" ]]
		then
			export $name="${value}"
		else
			unset $name
		fi
		unset $wrap_name
	done
}
__rvm_unset_ruby_variables () {
	unset rvm_env_string rvm_ruby_string rvm_ruby_strings rvm_ruby_binary rvm_ruby_gem_home rvm_ruby_gem_path rvm_ruby_home rvm_ruby_interpreter rvm_ruby_irbrc rvm_ruby_log_path rvm_ruby_major_version rvm_ruby_minor_version rvm_ruby_package_name rvm_ruby_patch_level rvm_ruby_release_version rvm_ruby_repo_url rvm_ruby_repo_branch rvm_ruby_revision rvm_ruby_selected_flag rvm_ruby_tag rvm_ruby_version rvm_head_flag rvm_ruby_package_file rvm_ruby_configure rvm_ruby_name rvm_ruby_url rvm_ruby_global_gems_path rvm_ruby_args rvm_ruby_name rvm_llvm_flag rvm_ruby_repo_tag
	__rvm_load_rvmrc
}
__rvm_untrust_rvmrc () {
	[[ -f "$1" ]] || return 1
	__rvm_reset_rvmrc_trust "$1"
	__rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" "0;$(__rvm_checksum_for_contents "$1")" > /dev/null 2>&1 || return $?
}
__rvm_use () {
	\typeset binary full_binary_path rvm_ruby_gem_home __path_prefix __path_suffix
	__rvm_select "$@" || return $?
	if [[ "system" == ${rvm_ruby_interpreter:="system"} ]]
	then
		__rvm_use_system
	else
		__rvm_use_ || return $?
	fi
	__rvm_use_common
}
__rvm_use_ () {
	rvm_ruby_home="${rvm_ruby_home%%@*}" 
	if [[ ! -d "$rvm_ruby_home" ]]
	then
		if [[ ${rvm_install_on_use_flag:-0} -eq 1 ]]
		then
			rvm_warn "Required $rvm_ruby_string is not installed - installing."
			__rvm_run_wrapper manage "install" "$rvm_ruby_string"
		else
			rvm_error "Required $rvm_ruby_string is not installed."
			rvm_log "To install do: 'rvm install \"$rvm_ruby_string\"'"
			export rvm_recommended_ruby="rvm install $rvm_ruby_string" 
			return 1
		fi
	fi
	__rvm_gemset_use_ensure || return $?
	export GEM_HOME GEM_PATH MY_RUBY_HOME RUBY_VERSION IRBRC
	GEM_HOME="$rvm_ruby_gem_home" 
	GEM_PATH="$rvm_ruby_gem_path" 
	MY_RUBY_HOME="$rvm_ruby_home" 
	RUBY_VERSION="$rvm_ruby_string" 
	IRBRC="$rvm_ruby_irbrc" 
	unset BUNDLE_PATH
	if [[ "maglev" == "$rvm_ruby_interpreter" ]]
	then
		GEM_PATH="$GEM_PATH:$MAGLEV_HOME/lib/maglev/gems/1.8/" 
	fi
	[[ -n "${IRBRC:-}" ]] || unset IRBRC
	if (( ${rvm_use_flag:-1} >= 2 && ${rvm_internal_use_flag:-0} == 0 )) || (( ${rvm_use_flag:-1} == 1 && ${rvm_verbose_flag:-0} == 1 ))
	then
		rvm_log "Using ${GEM_HOME/${rvm_gemset_separator:-'@'}/ with gemset }"
	fi
	if [[ "$GEM_HOME" != "$rvm_ruby_global_gems_path" ]]
	then
		__path_prefix="$GEM_HOME/bin:$rvm_ruby_global_gems_path/bin:${rvm_ruby_binary%/*}:${rvm_bin_path}" 
	else
		__path_prefix="$GEM_HOME/bin:${rvm_ruby_binary%/*}:${rvm_bin_path}" 
	fi
	__path_suffix="" 
}
__rvm_use_common () {
	[[ -z "${rvm_ruby_string:-}" ]] || export rvm_ruby_string
	[[ -z "${rvm_gemset_name:-}" ]] || export rvm_gemset_name
	\typeset __save_PATH
	__rvm_remove_rvm_from_path
	__save_PATH=$PATH 
	if [[ -n "${_OLD_VIRTUAL_PATH}" ]]
	then
		PATH="${_OLD_VIRTUAL_PATH}" 
		__rvm_remove_rvm_from_path
		_OLD_VIRTUAL_PATH="${__path_prefix:-}${__path_prefix:+:}${PATH}${__path_suffix:+:}${__path_suffix:-}" 
	fi
	PATH="${__path_prefix:-}${__path_prefix:+:}$__save_PATH${__path_suffix:+:}${__path_suffix:-}" 
	export PATH
	builtin hash -r
	if [[ "$rvm_ruby_string" != "system" ]]
	then
		case "${rvm_rvmrc_flag:-0}" in
			(rvmrc|versions_conf|ruby_version) __rvm_set_${rvm_rvmrc_flag} ;;
		esac
		\typeset environment_id
		environment_id="$(__rvm_env_string)" 
		if (( ${rvm_default_flag:=0} == 1 )) && [[ "default" != "${rvm_ruby_interpreter:-}" ]] && [[ "system" != "${rvm_ruby_interpreter:-}" ]]
		then
			"$rvm_scripts_path/alias" delete default &> /dev/null
			"$rvm_scripts_path/alias" create default "$environment_id" >&/dev/null
		fi
		rvm_default_flag=0 
		if [[ -n "${rvm_ruby_alias:-}" ]]
		then
			rvm_log "Attempting to alias $environment_id to $rvm_ruby_alias"
			"$rvm_scripts_path/alias" delete "$rvm_ruby_alias" > /dev/null 2>&1
			rvm_alias_expanded=1 "$rvm_scripts_path/alias" create "$rvm_ruby_alias" "$environment_id" > /dev/null 2>&1
			ruby_alias="" 
			rvm_ruby_alias="" 
		fi
	else
		if (( ${rvm_default_flag:=0} == 1 ))
		then
			builtin command -v __rvm_reset >> /dev/null 2>&1 || source "$rvm_scripts_path/functions/reset"
			__rvm_reset
		fi
	fi
	rvm_hook="after_use" 
	source "$rvm_scripts_path/hook"
	return 0
}
__rvm_use_ruby_warnings () {
	if [[ "${rvm_ruby_string}" == "system" || "${rvm_ruby_string}" == "" ]]
	then
		return 0
	fi
	\typeset __executable __gem_version
	for __executable in ruby gem irb
	do
		[[ -x "$MY_RUBY_HOME/bin/${__executable}" ]] || rvm_warn "Warning! Executable '${__executable}' missing, something went wrong with this ruby installation!"
	done
	if [[ "${rvm_ruby_interpreter}" == "ruby" ]] && {
			__rvm_version_compare "${rvm_ruby_version}" -ge 2.0.0 || [[ "${rvm_ruby_version}" == "head" ]]
		} && __rvm_which gem > /dev/null && __gem_version="$(RUBYGEMS_GEMDEPS= gem --version)"  && [[ -n "${__gem_version}" ]] && __rvm_version_compare "${__gem_version}" -lt "2.0.0"
	then
		rvm_warn "Warning! You have just used ruby 2.0.0 or newer, which is not fully compatible with rubygems 1.8.x or older,
         consider upgrading rubygems with: <code>rvm rubygems latest</code>"
	fi
}
__rvm_use_system () {
	unset GEM_HOME GEM_PATH MY_RUBY_HOME RUBY_VERSION IRBRC
	if [[ -s "$rvm_path/config/system" ]]
	then
		if __rvm_grep "MY_RUBY_HOME='$rvm_rubies_path" "$rvm_path/config/system" > /dev/null
		then
			if [[ -f "$rvm_path/config/system" ]]
			then
				\command \rm -f "$rvm_path/config/system"
			fi
		else
			source "$rvm_path/config/system"
		fi
	fi
	if (( ${rvm_default_flag:=0} == 1 ))
	then
		"$rvm_scripts_path/alias" delete default &> /dev/null
		__rvm_find "${rvm_bin_path}" -maxdepth 0 -name 'default_*' -exec rm '{}' \;
		\command \rm -f "$rvm_path/config/default"
		\command \rm -f "$rvm_environments_path/default"
		__rvm_rm_rf "$rvm_wrappers_path/default"
	fi
	rvm_verbose_log "Now using system ruby."
	__path_prefix="" 
	__path_suffix="${rvm_bin_path}" 
	export rvm_ruby_string="system" 
}
__rvm_using_gemset_globalcache () {
	__rvm_db_ "$rvm_user_path/db" "use_gemset_globalcache" | __rvm_grep '^true$' > /dev/null 2>&1
	return $?
}
__rvm_version () {
	echo "rvm $(__rvm_version_installed) by $(__rvm_version_authors) [$(__rvm_version_website)]"
}
__rvm_version_authors () {
	echo "Michal Papis, Piotr Kuczynski, Wayne E. Seguin"
}
__rvm_version_compare () {
	\typeset first
	first="$( \command \printf "%b" "$1\n$3\n" | __rvm_version_sort | \command \head -n1 )" 
	case "$2" in
		(-eq|==|=) [[ "$1" == "$3" ]] || return $? ;;
		(-ne|!=) [[ "$1" != "$3" ]] || return $? ;;
		(-gt|\>) if [[ "$first" == "head" ]]
			then
				[[ "$first" == "$1" && "$1" != "$3" ]] || return $?
			else
				[[ "$first" == "$3" && "$1" != "$3" ]] || return $?
			fi ;;
		(-ge|\>=) if [[ "$first" == "head" ]]
			then
				[[ "$first" == "$1" || "$1" == "$3" ]] || return $?
			else
				[[ "$first" == "$3" || "$1" == "$3" ]] || return $?
			fi ;;
		(-lt|\<) if [[ "$first" == "head" ]]
			then
				[[ "$first" == "$3" && "$1" != "$3" ]] || return $?
			else
				[[ "$first" == "$1" && "$1" != "$3" ]] || return $?
			fi ;;
		(-le|\<=) if [[ "$first" == "head" ]]
			then
				[[ "$first" == "$3" || "$1" == "$3" ]] || return $?
			else
				[[ "$first" == "$1" || "$1" == "$3" ]] || return $?
			fi ;;
		(*) rvm_error "Unsupported operator '$2'."
			return 1 ;;
	esac
	return 0
}
__rvm_version_copyright () {
	echo "(c) 2009-2017 $(__rvm_version_authors)"
}
__rvm_version_installed () {
	echo "$(\command \cat "$rvm_path/VERSION") ($(\command \cat "$rvm_path/RELEASE" 2>/dev/null))"
}
__rvm_version_remote () {
	__rvm_curl -s --max-time 10 https://github.com/rvm/rvm/raw/stable/VERSION || true
}
__rvm_version_sort () {
	\command \awk -F'[.-]' -v OFS=. '{                   # split on "." and "-", merge back with "."
    original=$0                                        # save original to preserve it before the line is changed
    for (n=1; n<10; n++) {                             # iterate through max 9 components of version
      $n=tolower($n)                                   # ignore case for sorting
      if ($n == "")                 $n="0"             # treat non existing parts as 0
      if ($n ~ /^p[0-9]/)           $n=substr($n, 2)   # old ruby -p notation
      if ($n ~ /^[0-9](rc|b)/)      $n=substr($n, 1, 1)". "substr($n, 2)   # old jruby 0RC1 notation
      if (n == 1 && $n ~ /^[0-9]/)  $n="zzz."$n        # first group must be a string
      if (n > 1 && $n ~ /^[a-z]/)   $n=" "$n           # names go before numbers thanks to space
    }
    print $0"\t"original                               # print the transformed version and original separated by \t
                                                       # so we can extract original after sorting
  }' | LC_ALL=C \sort -t. -k 1,1d -k 2,2n -k 3,3n -k 4,4n -k 5,5n -k 6,6n -k 7,7n -k 8,8n -k 9,9n | \awk -F'\t' '{print $2}'
}
__rvm_version_website () {
	echo "https://rvm.io"
}
__rvm_wait_anykey () {
	if [[ -n "${1:-}" ]]
	then
		echo "$1"
	fi
	\typeset _read_char_flag
	if [[ -n "${ZSH_VERSION:-}" ]]
	then
		_read_char_flag=k 
	else
		_read_char_flag=n 
	fi
	builtin read -${_read_char_flag} 1 -s -r anykey
}
__rvm_which () {
	\command \which "$@" || return $?
}
__rvm_with () {
	(
		unset rvm_rvmrc_flag
		export rvm_create_flag=1 
		export rvm_delete_flag=0 
		export rvm_internal_use_flag=1 
		export rvm_use_flag=0 
		__rvm_use "$1" || return $?
		shift
		"$@" || return $?
	)
}
__rvm_xargs () {
	\xargs "$@" || return $?
}
__rvmrc_full_path_to_file () {
	if [[ "$1" == "all.rvmrcs" || "$1" == "allGemfiles" ]]
	then
		__rvmrc_warning_file="$1" 
	elif [[ -d "$1" && -s "$1/.rvmrc" ]]
	then
		__rvmrc_warning_file="$( __rvm_cd "$1" >/dev/null 2>&1; pwd )/.rvmrc" 
	elif [[ -d "$1" && -s "$1/Gemfile" ]]
	then
		__rvmrc_warning_file="$( __rvm_cd "$1" >/dev/null 2>&1; pwd )/Gemfile" 
	elif [[ -f "$1" || "$1" == *".rvmrc" || "$1" == *"Gemfile" ]]
	then
		__rvmrc_warning_file="$( dirname "$1" )" 
		: __rvmrc_warning_file:${__rvmrc_warning_file:=$PWD}
		__rvmrc_warning_file="${__rvmrc_warning_file}/${1##*/}" 
	else
		rvm_warn "Do not know how to handle '$1', please report: https://github.com/rvm/rvm/issues ~ __rvmrc_full_path_to_file"
		return 1
	fi
}
__rvmrc_warning () {
	\typeset __rvmrc_warning_path __rvmrc_warning_file
	__rvmrc_warning_path="$rvm_user_path/rvmrc_ignored" 
	case "${1:-help}" in
		(list) __rvmrc_warning_$1 "${2:-}" || return $? ;;
		(check|check_quiet|ignore|reset) __rvmrc_full_path_to_file "${2:-}" && __rvmrc_warning_$1 "${__rvmrc_warning_file:-${2:-}}" || return $? ;;
		(help) rvm_help rvmrc warning ;;
		(*) rvm_error_help "Unknown subcommand '$1'" rvmrc warning
			return 1 ;;
	esac
}
__rvmrc_warning_check () {
	if __rvmrc_warning_check_quiet "$1"
	then
		rvm_log "path '$1' is ignored."
	else
		\typeset ret=$?
		rvm_log "path '$1' is not ignored."
		return $ret
	fi
}
__rvmrc_warning_check_quiet () {
	[[ -f "$__rvmrc_warning_path" ]] || return $?
	\typeset __rvmrc_type
	case "$1" in
		(all.rvmrcs|allGemfiles) true ;;
		(*) __rvmrc_type="^all${1##*/}s" 
			if __rvm_grep "${__rvmrc_type}$" "$__rvmrc_warning_path" > /dev/null
			then
				return 0
			fi ;;
	esac
	__rvm_grep "^$1$" "$__rvmrc_warning_path" > /dev/null || return $?
}
__rvmrc_warning_display_for_Gemfile () {
	\typeset __rvmrc_warning_path __rvmrc_warning_file
	__rvmrc_warning_path="$rvm_user_path/rvmrc_ignored" 
	if [[ -t 2 ]] && __rvmrc_full_path_to_file "${1:-}" && ! __rvmrc_warning_check_quiet "${__rvmrc_warning_file:-${2:-}}"
	then
		rvm_warn "RVM used your Gemfile for selecting Ruby, it is all fine - Heroku does that too,
you can ignore these warnings with 'rvm rvmrc warning ignore $1'.
To ignore the warning for all files run 'rvm rvmrc warning ignore allGemfiles'.
"
	fi
}
__rvmrc_warning_display_for_rvmrc () {
	\typeset __rvmrc_warning_path __rvmrc_warning_file
	__rvmrc_warning_path="$rvm_user_path/rvmrc_ignored" 
	if [[ -t 2 ]] && __rvmrc_full_path_to_file "${1:-}" && ! __rvmrc_warning_check_quiet "${__rvmrc_warning_file:-${2:-}}"
	then
		rvm_warn "You are using '.rvmrc', it requires trusting, it is slower and it is not compatible with other ruby managers,
you can switch to '.ruby-version' using 'rvm rvmrc to ruby-version'
or ignore this warning with 'rvm rvmrc warning ignore $1',
'.rvmrc' will continue to be the default project file in RVM 1 and RVM 2,
to ignore the warning for all files run 'rvm rvmrc warning ignore all.rvmrcs'.
"
	fi
}
__rvmrc_warning_ignore () {
	__rvmrc_warning_check_quiet "$1" || case "$1" in
		(all.rvmrcs|allGemfiles) echo "$1" >> "$__rvmrc_warning_path" ;;
		(*) echo "$1" >> "$__rvmrc_warning_path" ;;
	esac
}
__rvmrc_warning_list () {
	rvm_log "# List of project files that ignore warnings:"
	if [[ -s "$__rvmrc_warning_path" ]]
	then
		\command \cat "$__rvmrc_warning_path"
	fi
}
__rvmrc_warning_reset () {
	\typeset __rvmrc_type
	case "${1:-}" in
		(all.rvmrcs|allGemfiles) if __rvmrc_warning_check_quiet "$1"
			then
				__rvm_sed_i "$__rvmrc_warning_path" -e "\#^${1}\$# d" -e '/^$/ d'
				__rvmrc_type="${1#all}" 
				__rvmrc_type="${__rvmrc_type%s}" 
				__rvm_sed_i "$__rvmrc_warning_path" -e "\#/${__rvmrc_type}\$# d" -e '\#^$# d'
			else
				rvm_debug "Already removed warning ignore from '$1'."
			fi ;;
		(*) if __rvmrc_warning_check_quiet "$1"
			then
				__rvm_sed_i "$__rvmrc_warning_path" -e "\#^${1}\$# d" -e '\#^$# d'
			else
				rvm_debug "Already removed warning ignore from '$1'."
			fi ;;
	esac
}
__setup_lang_fallback () {
	if [[ -z "${LANG:-}" ]]
	then
		LANG="$(
      {
        locale -a | __rvm_grep "^en_US.utf8" ||
        locale -a | __rvm_grep "^en_US" ||
        locale -a | __rvm_grep "^en" ||
        locale -a
      } 2>/dev/null | \command \head -n 1
    )" 
		: LANG=${LANG:=en_US.utf-8}
		export LANG
		rvm_warn "\$LANG was empty, setting up LANG=$LANG, if it fails again try setting LANG to something sane and try again."
	fi
}
__variables_definition () {
	\typeset -a __variables_list __array_list
	\typeset __method
	__method="$1" 
	__variables_list=(rvm_head_flag rvm_ruby_selected_flag rvm_user_install_flag rvm_path_flag rvm_cron_flag rvm_static_flag rvm_default_flag rvm_loaded_flag rvm_llvm_flag rvm_skip_autoreconf_flag rvm_dynamic_extensions_flag rvm_18_flag rvm_19_flag rvm_20_flag rvm_21_flag rvm_force_autoconf_flag rvm_dump_environment_flag rvm_curl_flags rvm_rubygems_version rvm_verbose_flag rvm_debug_flag rvm_trace_flag __array_start rvm_skip_pristine_flag rvm_create_flag rvm_remove_flag rvm_movable_flag rvm_archive_flag rvm_gemdir_flag rvm_reload_flag rvm_auto_reload_flag rvm_disable_binary_flag rvm_ignore_gemsets_flag rvm_skip_gemsets_flag rvm_install_on_use_flag rvm_remote_flag rvm_verify_downloads_flag rvm_skip_openssl_flag rvm_gems_cache_path rvm_gems_path rvm_man_path rvm_ruby_gem_path rvm_ruby_log_path rvm_gems_cache_path rvm_archives_path rvm_docs_path rvm_environments_path rvm_examples_path rvm_gems_path rvm_gemsets_path rvm_help_path rvm_hooks_path rvm_lib_path rvm_log_path rvm_patches_path rvm_repos_path rvm_rubies_path rvm_scripts_path rvm_src_path rvm_tmp_path rvm_user_path rvm_usr_path rvm_wrappers_path rvm_stored_errexit rvm_ruby_strings rvm_ruby_binary rvm_ruby_gem_home rvm_ruby_home rvm_ruby_interpreter rvm_ruby_irbrc rvm_ruby_major_version rvm_ruby_minor_version rvm_ruby_package_name rvm_ruby_patch_level rvm_ruby_release_version rvm_ruby_repo_url rvm_ruby_repo_branch rvm_ruby_revision rvm_ruby_tag rvm_ruby_sha rvm_ruby_repo_tag rvm_ruby_version rvm_ruby_package_file rvm_ruby_name rvm_ruby_name rvm_ruby_args rvm_ruby_user_tag rvm_ruby_patch detected_rvm_ruby_name __rvm_env_loaded next_token rvm_error_message rvm_gemset_name rvm_parse_break rvm_token rvm_action rvm_export_args rvm_gemset_separator rvm_expanding_aliases rvm_tar_command rvm_tar_options rvm_patch_original_pwd rvm_project_rvmrc rvm_archive_extension rvm_autoinstall_bundler_flag rvm_codesign_identity rvm_expected_gemset_name rvm_without_gems rvm_with_gems rvm_with_default_gems rvm_ignore_dotfiles_flag rvm_fuzzy_flag rvm_autolibs_flag rvm_autolibs_flag_number rvm_autolibs_flag_runner rvm_quiet_curl_flag rvm_max_time_flag rvm_error_clr rvm_warn_clr rvm_debug_clr rvm_notify_clr rvm_code_clr rvm_comment_clr rvm_reset_clr rvm_error_color rvm_warn_color rvm_debug_color rvm_notify_color rvm_code_color rvm_comment_color rvm_reset_color rvm_log_timestamp rvm_log_filesystem rvm_log_namelen rvm_show_log_lines_on_error) 
	__array_list=(rvm_patch_names rvm_ree_options rvm_autoconf_flags rvm_architectures) 
	case "${__method}" in
		(export) true ;;
		(unset) unset "${__array_list[@]}" || true ;;
		(*) rvm_error "Unknown action given to __variables_definition: ${__method}"
			return 1 ;;
	esac
	${__method} "${__variables_list[@]}" || true
	if [[ -n "${BASH_VERSION:-}" ]]
	then
		export -fn __rvm_select_version_variables __rvm_ruby_string_parse_ __rvm_rm_rf_verbose __rvm_parse_args __rvm_ruby_string_find __rvm_file_load_env __rvm_remove_without_gems 2> /dev/null || true
	fi
}
__zsh_like_cd () {
	\typeset __zsh_like_cd_hook
	if builtin "$@"
	then
		for __zsh_like_cd_hook in chpwd "${chpwd_functions[@]}"
		do
			if \typeset -f "$__zsh_like_cd_hook" > /dev/null 2>&1
			then
				"$__zsh_like_cd_hook" || break
			fi
		done
		true
	else
		return $?
	fi
}
_a2ps () {
	# undefined
	builtin autoload -XUz
}
_a2utils () {
	# undefined
	builtin autoload -XUz
}
_aap () {
	# undefined
	builtin autoload -XUz
}
_absolute_command_paths () {
	# undefined
	builtin autoload -XUz
}
_ack () {
	# undefined
	builtin autoload -XUz
}
_acpi () {
	# undefined
	builtin autoload -XUz
}
_acpitool () {
	# undefined
	builtin autoload -XUz
}
_acroread () {
	# undefined
	builtin autoload -XUz
}
_adb () {
	# undefined
	builtin autoload -XUz
}
_add-zle-hook-widget () {
	# undefined
	builtin autoload -XUz
}
_add-zsh-hook () {
	# undefined
	builtin autoload -XUz
}
_alias () {
	# undefined
	builtin autoload -XUz
}
_aliases () {
	# undefined
	builtin autoload -XUz
}
_all_labels () {
	local __gopt __len __tmp __pre __suf __ret=1 __descr __spec __prev 
	if [[ "$1" = - ]]
	then
		__prev=- 
		shift
	fi
	__gopt=() 
	zparseopts -D -a __gopt 1 2 V J x
	__tmp=${argv[(ib:4:)-]} 
	__len=$# 
	if [[ __tmp -lt __len ]]
	then
		__pre=$(( __tmp-1 )) 
		__suf=$__tmp 
	elif [[ __tmp -eq $# ]]
	then
		__pre=-2 
		__suf=$(( __len+1 )) 
	else
		__pre=4 
		__suf=5 
	fi
	while comptags "-A$__prev" "$1" curtag __spec
	do
		(( $#funcstack > _tags_level )) && _comp_tags="${_comp_tags% * }" 
		_tags_level=$#funcstack 
		_comp_tags="$_comp_tags $__spec " 
		if [[ "$curtag" = *[^\\]:* ]]
		then
			zformat -f __descr "${curtag#*:}" "d:$3"
			_description "$__gopt[@]" "${curtag%:*}" "$2" "$__descr"
			curtag="${curtag%:*}" 
			"$4" "${(P@)2}" "${(@)argv[5,-1]}" && __ret=0 
		else
			_description "$__gopt[@]" "$curtag" "$2" "$3"
			"${(@)argv[4,__pre]}" "${(P@)2}" "${(@)argv[__suf,-1]}" && __ret=0 
		fi
	done
	return __ret
}
_all_matches () {
	# undefined
	builtin autoload -XUz
}
_alternative () {
	# undefined
	builtin autoload -XUz
}
_analyseplugin () {
	# undefined
	builtin autoload -XUz
}
_ansible () {
	# undefined
	builtin autoload -XUz
}
_ant () {
	# undefined
	builtin autoload -XUz
}
_antiword () {
	# undefined
	builtin autoload -XUz
}
_apachectl () {
	# undefined
	builtin autoload -XUz
}
_apm () {
	# undefined
	builtin autoload -XUz
}
_approximate () {
	# undefined
	builtin autoload -XUz
}
_apt () {
	# undefined
	builtin autoload -XUz
}
_apt-file () {
	# undefined
	builtin autoload -XUz
}
_apt-move () {
	# undefined
	builtin autoload -XUz
}
_apt-show-versions () {
	# undefined
	builtin autoload -XUz
}
_aptitude () {
	# undefined
	builtin autoload -XUz
}
_arch_archives () {
	# undefined
	builtin autoload -XUz
}
_arch_namespace () {
	# undefined
	builtin autoload -XUz
}
_arg_compile () {
	# undefined
	builtin autoload -XUz
}
_arguments () {
	local long cmd="$words[1]" descr odescr mesg subopts opt opt2 usecc autod 
	local oldcontext="$curcontext" hasopts rawret optarg singopt alwopt 
	local setnormarg start rest
	local -a match mbegin mend
	subopts=() 
	singopt=() 
	while [[ "$1" = -([AMO]*|[CRSWnsw]) ]]
	do
		case "$1" in
			(-C) usecc=yes 
				shift ;;
			(-O) subopts=("${(@P)2}") 
				shift 2 ;;
			(-O*) subopts=("${(@P)${1[3,-1]}}") 
				shift ;;
			(-R) rawret=yes 
				shift ;;
			(-n) setnormarg=yes 
				NORMARG=-1 
				shift ;;
			(-w) optarg=yes 
				shift ;;
			(-W) alwopt=arg 
				shift ;;
			(-[Ss]) singopt+=($1) 
				shift ;;
			(-[AM]) singopt+=($1 $2) 
				shift 2 ;;
			(-[AM]*) singopt+=($1) 
				shift ;;
		esac
	done
	[[ $1 = ':' ]] && shift
	singopt+=(':') 
	[[ "$PREFIX" = [-+] ]] && alwopt=arg 
	long=$argv[(I)--] 
	if (( long ))
	then
		local name tmp tmpargv
		tmpargv=("${(@)argv[1,long-1]}") 
		name=${~words[1]}  2> /dev/null
		[[ "$name" = [^/]*/* ]] && name="$PWD/$name" 
		name="_args_cache_${name}" 
		name="${name//[^a-zA-Z0-9_]/_}" 
		if (( ! ${(P)+name} ))
		then
			local iopts sopts lflag pattern tmpo dir cur cache
			typeset -Ua lopts
			cache=() 
			set -- "${(@)argv[long+1,-1]}"
			iopts=() 
			sopts=() 
			while [[ "$1" = -[lis]* ]]
			do
				if [[ "$1" = -l ]]
				then
					lflag='-l' 
					shift
					continue
				fi
				if [[ "$1" = -??* ]]
				then
					tmp="${1[3,-1]}" 
					cur=1 
				else
					tmp="$2" 
					cur=2 
				fi
				if [[ "$tmp[1]" = '(' ]]
				then
					tmp=(${=tmp[2,-2]}) 
				else
					tmp=("${(@P)tmp}") 
				fi
				if [[ "$1" = -i* ]]
				then
					iopts+=("$tmp[@]") 
				else
					sopts+=("$tmp[@]") 
				fi
				shift cur
			done
			tmp=() 
			_call_program $lflag options ${~words[1]} --help 2>&1 | while IFS= read -r opt
			do
				if (( ${#tmp} ))
				then
					if [[ $opt = [[:space:]][[:space:]][[:space:]]*[[:alpha:]]* ]]
					then
						opt=${opt##[[:space:]]##} 
						lopts+=("${^tmp[@]}":${${${opt//:/-}//\[/(}//\]/)}) 
						tmp=() 
						continue
					else
						lopts+=("${^tmp[@]}":) 
						tmp=() 
					fi
				fi
				while [[ $opt = [,[:space:]]#(#b)(-[^,[:space:]]#)(*) ]]
				do
					start=${match[1]} 
					rest=${match[2]} 
					if [[ -z ${tmp[(r)${start%%[^a-zA-Z0-9_-]#}]} ]]
					then
						if [[ $start = (#b)(*)\[(*)\](*) ]]
						then
							tmp+=("${match[1]}${match[2]}${match[3]}" "${match[1]}${match[3]}") 
						else
							tmp+=($start) 
						fi
					fi
					opt=$rest 
				done
				opt=${opt## [^[:space:]]##  } 
				opt=${opt##[[:space:]]##} 
				if [[ -n $opt ]]
				then
					lopts+=("${^tmp[@]}":${${${opt//:/-}//\[/(}//\]/)}) 
					tmp=() 
				fi
			done
			if (( ${#tmp} ))
			then
				lopts+=("${^tmp[@]}":) 
			fi
			tmp=() 
			for opt in "${(@)${(@)lopts:#--}%%[\[:=]*}"
			do
				let "$tmpargv[(I)(|\([^\)]#\))(|\*)${opt}(|[-+]|=(|-))(|\[*\])(|:*)]" || tmp+=("$lopts[(r)$opt(|[\[:=]*)]") 
			done
			lopts=("$tmp[@]") 
			while (( $#iopts ))
			do
				lopts=(${lopts:#$~iopts[1](|[\[:=]*)}) 
				shift iopts
			done
			while (( $#sopts ))
			do
				lopts+=(${lopts/$~sopts[1]/$sopts[2]}) 
				shift 2 sopts
			done
			argv+=('*=FILE*:file:_files' '*=(DIR|PATH)*:directory:_files -/' '*=*:=: ' '*: :  ') 
			while (( $# ))
			do
				pattern="${${${(M)1#*[^\\]:}[1,-2]}//\\\\:/:}" 
				descr="${1#${pattern}}" 
				if [[ "$pattern" = *\(-\) ]]
				then
					pattern="$pattern[1,-4]" 
					dir=- 
				else
					dir= 
				fi
				shift
				tmp=("${(@M)lopts:##$~pattern:*}") 
				lopts=("${(@)lopts:##$~pattern:*}") 
				(( $#tmp )) || continue
				opt='' 
				tmp=("${(@)tmp%:}") 
				tmpo=("${(@M)tmp:#[^:]##\[\=*}") 
				if (( $#tmpo ))
				then
					tmp=("${(@)tmp:#[^:]##\[\=*}") 
					for opt in "$tmpo[@]"
					do
						if [[ $opt = (#b)(*):([^:]#) ]]
						then
							opt=$match[1] 
							odescr="[${match[2]}]" 
						else
							odescr= 
						fi
						if [[ $opt = (#b)(*)\[\=* ]]
						then
							opt2=${${match[1]}//[^a-zA-Z0-9_-]}=-${dir}${odescr} 
						else
							opt2=${${opt}//[^a-zA-Z0-9_-]}=${dir}${odescr} 
						fi
						if [[ "$descr" = :\=* ]]
						then
							cache+=("${opt2}::${(L)${opt%\]}#*\=}: ") 
						elif [[ "$descr" = ::* ]]
						then
							cache+=("${opt2}${descr}") 
						else
							cache+=("${opt2}:${descr}") 
						fi
					done
				fi
				tmpo=("${(@M)tmp:#[^:]##\=*}") 
				if (( $#tmpo ))
				then
					tmp=("${(@)tmp:#[^:]##\=*}") 
					for opt in "$tmpo[@]"
					do
						if [[ $opt = (#b)(*):([^:]#) ]]
						then
							opt=$match[1] 
							odescr="[${match[2]}]" 
						else
							odescr= 
						fi
						opt2="${${opt%%\=*}//[^a-zA-Z0-9_-]}=${dir}${odescr}" 
						if [[ "$descr" = :\=* ]]
						then
							cache+=("${opt2}:${(L)${opt%\]}#*\=}: ") 
						else
							cache+=("${opt2}${descr}") 
						fi
					done
				fi
				if (( $#tmp ))
				then
					tmp=("${(@)^${(@)tmp:#^*:*}//:/[}]" "${(@)${(@)tmp:#*:*}//[^a-zA-Z0-9_-]}") 
					if [[ -n "$descr" && "$descr" != ': :  ' ]]
					then
						cache+=("${(@)^tmp}${descr}") 
					else
						cache+=("$tmp[@]") 
					fi
				fi
			done
			set -A "$name" "${(@)cache:# #}"
		fi
		set -- "$tmpargv[@]" "${(@P)name}"
	fi
	zstyle -s ":completion:${curcontext}:options" auto-description autod
	if (( $# )) && comparguments -i "$autod" "$singopt[@]" "$@"
	then
		local action noargs aret expl local tried ret=1 
		local next direct odirect equal single matcher matched ws tmp1 tmp2 tmp3
		local opts subc tc prefix suffix descrs actions subcs anum
		local origpre="$PREFIX" origipre="$IPREFIX" nm="$compstate[nmatches]" 
		if comparguments -D descrs actions subcs
		then
			if comparguments -O next direct odirect equal
			then
				opts=yes 
				_tags "$subcs[@]" options
			else
				_tags "$subcs[@]"
			fi
		else
			if comparguments -a
			then
				noargs='no more arguments' 
			else
				noargs='no arguments' 
			fi
			if comparguments -O next direct odirect equal
			then
				opts=yes 
				_tags options
			elif [[ $? -eq 2 ]]
			then
				compadd -Q - "${PREFIX}${SUFFIX}"
				return 0
			else
				_message "$noargs"
				return 1
			fi
		fi
		comparguments -M matcher
		context=() 
		state=() 
		state_descr=() 
		while true
		do
			while _tags
			do
				anum=1 
				if [[ -z "$tried" ]]
				then
					while [[ anum -le $#descrs ]]
					do
						action="$actions[anum]" 
						descr="$descrs[anum]" 
						subc="$subcs[anum++]" 
						if [[ $subc = argument* && -n $setnormarg ]]
						then
							comparguments -n NORMARG
						fi
						if [[ -n "$matched" ]] || _requested "$subc"
						then
							curcontext="${oldcontext%:*}:$subc" 
							_description "$subc" expl "$descr"
							if [[ "$action" = \=\ * ]]
							then
								action="$action[3,-1]" 
								words=("$subc" "$words[@]") 
								(( CURRENT++ ))
							fi
							if [[ "$action" = -\>* ]]
							then
								action="${${action[3,-1]##[ 	]#}%%[ 	]#}" 
								if (( ! $state[(I)$action] ))
								then
									comparguments -W line opt_args
									state+=("$action") 
									state_descr+=("$descr") 
									if [[ -n "$usecc" ]]
									then
										curcontext="${oldcontext%:*}:$subc" 
									else
										context+=("$subc") 
									fi
									compstate[restore]='' 
									aret=yes 
								fi
							else
								if [[ -z "$local" ]]
								then
									local line
									typeset -A opt_args
									local=yes 
								fi
								comparguments -W line opt_args
								if [[ "$action" = \ # ]]
								then
									_message -e "$subc" "$descr"
									mesg=yes 
									tried=yes 
									alwopt=${alwopt:-yes} 
								elif [[ "$action" = \(\(*\)\) ]]
								then
									eval ws\=\( "${action[3,-3]}" \)
									_describe -t "$subc" "$descr" ws -M "$matcher" "$subopts[@]" || alwopt=${alwopt:-yes} 
									tried=yes 
								elif [[ "$action" = \(*\) ]]
								then
									eval ws\=\( "${action[2,-2]}" \)
									_all_labels "$subc" expl "$descr" compadd "$subopts[@]" -a - ws || alwopt=${alwopt:-yes} 
									tried=yes 
								elif [[ "$action" = \{*\} ]]
								then
									while _next_label "$subc" expl "$descr"
									do
										eval "$action[2,-2]" && ret=0 
									done
									(( ret )) && alwopt=${alwopt:-yes} 
									tried=yes 
								elif [[ "$action" = \ * ]]
								then
									eval "action=( $action )"
									while _next_label "$subc" expl "$descr"
									do
										"$action[@]" && ret=0 
									done
									(( ret )) && alwopt=${alwopt:-yes} 
									tried=yes 
								else
									eval "action=( $action )"
									while _next_label "$subc" expl "$descr"
									do
										"$action[1]" "$subopts[@]" "$expl[@]" "${(@)action[2,-1]}" && ret=0 
									done
									(( ret )) && alwopt=${alwopt:-yes} 
									tried=yes 
								fi
							fi
						fi
					done
				fi
				if _requested options && [[ -z "$hasopts" && -z "$matched" && ( -z "$aret" || "$PREFIX" = "$origpre" ) ]] && {
						! zstyle -T ":completion:${oldcontext%:*}:options" prefix-needed || [[ "$origpre" = [-+]* || -z "$aret$mesg$tried" ]]
					}
				then
					local prevpre="$PREFIX" previpre="$IPREFIX" prevcontext="$curcontext" 
					curcontext="${oldcontext%:*}:options" 
					hasopts=yes 
					PREFIX="$origpre" 
					IPREFIX="$origipre" 
					if [[ -z "$alwopt" || -z "$tried" || "$alwopt" = arg ]] && comparguments -s single
					then
						if [[ "$single" = direct ]]
						then
							_all_labels options expl option compadd -QS '' - "${PREFIX}${SUFFIX}"
						elif [[ -z "$optarg" && "$single" = next ]]
						then
							_all_labels options expl option compadd -Q - "${PREFIX}${SUFFIX}"
						elif [[ "$single" = equal ]]
						then
							_all_labels options expl option compadd -QqS= - "${PREFIX}${SUFFIX}"
						else
							tmp1=("$next[@]" "$direct[@]" "$odirect[@]" "$equal[@]") 
							[[ "$PREFIX" = [-+]* ]] && tmp1=("${(@M)tmp1:#${PREFIX[1]}*}") 
							[[ "$single" = next ]] && tmp1=("${(@)tmp1:#[-+]${PREFIX[-1]}((#e)|:*)}") 
							[[ "$PREFIX" != --* ]] && tmp1=("${(@)tmp1:#--*}") 
							tmp3=("${(M@)tmp1:#[-+]?[^:]*}") 
							tmp1=("${(M@)tmp1:#[-+]?(|:*)}") 
							tmp2=("${PREFIX}${(@M)^${(@)${(@)tmp1%%:*}#[-+]}:#?}") 
							_describe -O option tmp1 tmp2 -Q -S '' -- tmp3 -Q
							[[ -n "$optarg" && "$single" = next && nm -eq $compstate[nmatches] ]] && _all_labels options expl option compadd -Q - "${PREFIX}${SUFFIX}"
						fi
						single=yes 
					else
						next+=("$odirect[@]") 
						_describe -O option next -Q -M "$matcher" -- direct -QS '' -M "$matcher" -- equal -QqS= -M "$matcher"
					fi
					PREFIX="$prevpre" 
					IPREFIX="$previpre" 
					curcontext="$prevcontext" 
				fi
				[[ -n "$tried" && "${${alwopt:+$origpre}:-$PREFIX}" != [-+]* ]] && break
			done
			if [[ -n "$opts" && -z "$aret" && -z "$matched" && ( -z "$tried" || -n "$alwopt" ) && nm -eq compstate[nmatches] ]]
			then
				PREFIX="$origpre" 
				IPREFIX="$origipre" 
				prefix="${PREFIX#*\=}" 
				suffix="$SUFFIX" 
				PREFIX="${PREFIX%%\=*}" 
				SUFFIX='' 
				compadd -M "$matcher" -D equal - "${(@)equal%%:*}"
				if [[ $#equal -eq 1 ]]
				then
					PREFIX="$prefix" 
					SUFFIX="$suffix" 
					IPREFIX="${IPREFIX}${equal[1]%%:*}=" 
					matched=yes 
					comparguments -L "${equal[1]%%:*}" descrs actions subcs
					_tags "$subcs[@]"
					continue
				fi
			fi
			break
		done
		[[ -z "$aret" || -z "$usecc" ]] && curcontext="$oldcontext" 
		if [[ -n "$aret" ]]
		then
			[[ -n $rawret ]] && return 300
		else
			[[ -n "$noargs" && nm -eq "$compstate[nmatches]" ]] && _message "$noargs"
		fi
		[[ nm -ne "$compstate[nmatches]" ]]
	else
		return 1
	fi
}
_arp () {
	# undefined
	builtin autoload -XUz
}
_arping () {
	# undefined
	builtin autoload -XUz
}
_arrays () {
	# undefined
	builtin autoload -XUz
}
_asciidoctor () {
	# undefined
	builtin autoload -XUz
}
_asciinema () {
	# undefined
	builtin autoload -XUz
}
_assign () {
	# undefined
	builtin autoload -XUz
}
_at () {
	# undefined
	builtin autoload -XUz
}
_attr () {
	# undefined
	builtin autoload -XUz
}
_augeas () {
	# undefined
	builtin autoload -XUz
}
_auto-apt () {
	# undefined
	builtin autoload -XUz
}
_autocd () {
	# undefined
	builtin autoload -XUz
}
_awk () {
	# undefined
	builtin autoload -XUz
}
_axi-cache () {
	# undefined
	builtin autoload -XUz
}
_base64 () {
	# undefined
	builtin autoload -XUz
}
_basename () {
	# undefined
	builtin autoload -XUz
}
_bash () {
	# undefined
	builtin autoload -XUz
}
_bash_completions () {
	# undefined
	builtin autoload -XUz
}
_baudrates () {
	# undefined
	builtin autoload -XUz
}
_baz () {
	# undefined
	builtin autoload -XUz
}
_be_name () {
	# undefined
	builtin autoload -XUz
}
_beadm () {
	# undefined
	builtin autoload -XUz
}
_beep () {
	# undefined
	builtin autoload -XUz
}
_bibtex () {
	# undefined
	builtin autoload -XUz
}
_bind_addresses () {
	# undefined
	builtin autoload -XUz
}
_bindkey () {
	# undefined
	builtin autoload -XUz
}
_bison () {
	# undefined
	builtin autoload -XUz
}
_bittorrent () {
	# undefined
	builtin autoload -XUz
}
_bogofilter () {
	# undefined
	builtin autoload -XUz
}
_bpf_filters () {
	# undefined
	builtin autoload -XUz
}
_bpython () {
	# undefined
	builtin autoload -XUz
}
_brace_parameter () {
	# undefined
	builtin autoload -XUz
}
_brctl () {
	# undefined
	builtin autoload -XUz
}
_brew () {
	# undefined
	builtin autoload -XUz
}
_brew_cask () {
	# undefined
	builtin autoload -XUz
}
_bsd_pkg () {
	# undefined
	builtin autoload -XUz
}
_bsdconfig () {
	# undefined
	builtin autoload -XUz
}
_bsdinstall () {
	# undefined
	builtin autoload -XUz
}
_btrfs () {
	# undefined
	builtin autoload -XUz
}
_bts () {
	# undefined
	builtin autoload -XUz
}
_bug () {
	# undefined
	builtin autoload -XUz
}
_builtin () {
	# undefined
	builtin autoload -XUz
}
_bzip2 () {
	# undefined
	builtin autoload -XUz
}
_bzr () {
	# undefined
	builtin autoload -XUz
}
_cabal () {
	# undefined
	builtin autoload -XUz
}
_cache_invalid () {
	# undefined
	builtin autoload -XUz
}
_caffeinate () {
	# undefined
	builtin autoload -XUz
}
_cal () {
	# undefined
	builtin autoload -XUz
}
_calendar () {
	# undefined
	builtin autoload -XUz
}
_call_function () {
	# undefined
	builtin autoload -XUz
}
_call_program () {
	local curcontext="${curcontext}" tmp err_fd=-1 clocale='_comp_locale;' 
	local -a prefix
	if [[ "$1" = -p ]]
	then
		shift
		if (( $#_comp_priv_prefix ))
		then
			curcontext="${curcontext%:*}/${${(@M)_comp_priv_prefix:#^*[^\\]=*}[1]}:" 
			zstyle -t ":completion:${curcontext}:${1}" gain-privileges && prefix=($_comp_priv_prefix) 
		fi
	elif [[ "$1" = -l ]]
	then
		shift
		clocale='' 
	fi
	if (( ${debug_fd:--1} > 2 )) || [[ ! -t 2 ]]
	then
		exec {err_fd}>&2
	else
		exec {err_fd}> /dev/null
	fi
	{
		if zstyle -s ":completion:${curcontext}:${1}" command tmp
		then
			if [[ "$tmp" = -* ]]
			then
				eval $clocale "$tmp[2,-1]" "$argv[2,-1]"
			else
				eval $clocale $prefix "$tmp"
			fi
		else
			eval $clocale $prefix "$argv[2,-1]"
		fi 2>&$err_fd
	} always {
		exec {err_fd}>&-
	}
}
_canonical_paths () {
	# undefined
	builtin autoload -XUz
}
_cat () {
	local -a args
	if _pick_variant gnu=GNU unix --version
	then
		args=('(-A --show-all)'{-A,--show-all}'[equivalent to -vET]' '(-b --number-nonblank -n --number)'{-b,--number-nonblank}'[number nonempty output lines, overrides -n]' '-e[equivalent to -vE]' '(-E --show-ends)'{-E,--show-ends}'[display $ at end of each line]' '(-n --number)'{-n,--number}'[number all output lines]' '(-s --squeeze-blank)'{-s,--squeeze-blank}'[suppress repeated empty output lines]' '-t[equivalent to -vT]' '(-T --show-tabs)'{-T,--show-tabs}'[display TAB characters as ^I]' '-u[ignored]' '(-v --show-nonprinting)'{-v,--show-nonprinting}'[use ^ and M- notation, except for LFD and TAB]' '(- : *)--help[display help and exit]' '(- : *)--version[output version information and exit]' '*: :_files') 
	elif [[ "$OSTYPE" == (*bsd|dragonfly|darwin)* ]]
	then
		args=(-A "-*" '(-n)-b[number non-blank output lines]' '(-v)-e[display $ at the end of each line (implies -v)]' '-n[number all output lines]' '-s[squeeze multiple blank lines into one]' '(-v)-t[display tab as ^I (implies -v)]' '-u[do not buffer output]' '-v[display non-printing chars as ^X or M-a]' '*: :_files') 
		[[ $OSTYPE = (free|net)bsd* ]] && args+=('-l[set a lock on the stdout file descriptor]') 
		[[ $OSTYPE = netbsd* ]] && args+=('-B+[read with buffer of specified size]:size (bytes)' '-f[only attempt to display regular files]') 
	elif [[ $OSTYPE = solaris* ]]
	then
		args=(-A "-*" '(-b)-n[number all output lines]' '(-n)-b[number non-blank output lines]' "-u[don't buffer output]" '-s[be silent about non-existent files]' '-v[display non-printing chars as ^X or M-a]' '-e[display $ at the end of each line (requires -v)]' '-t[display tab as ^I and formfeeds and ^L (requires -v)]' '*: :_files') 
	else
		args=('-n[number all output lines]' '-u[do not buffer output]' '*: :_files') 
	fi
	_arguments -s -S $args
}
_ccal () {
	# undefined
	builtin autoload -XUz
}
_cd () {
	# undefined
	builtin autoload -XUz
}
_cdbs-edit-patch () {
	# undefined
	builtin autoload -XUz
}
_cdcd () {
	# undefined
	builtin autoload -XUz
}
_cdr () {
	# undefined
	builtin autoload -XUz
}
_cdrdao () {
	# undefined
	builtin autoload -XUz
}
_cdrecord () {
	# undefined
	builtin autoload -XUz
}
_chattr () {
	# undefined
	builtin autoload -XUz
}
_chflags () {
	# undefined
	builtin autoload -XUz
}
_chkconfig () {
	# undefined
	builtin autoload -XUz
}
_chmod () {
	local curcontext="$curcontext" state line expl ret=1 
	local -a args privs
	args=('*: :->files' '1: :_file_modes') 
	if _pick_variant gnu=Free\ Soft unix --version
	then
		args+=('(-v --verbose -c --changes)'{-c,--changes}'[report changes made]' '(-v --verbose -c --changes)'{-v,--verbose}'[output a diagnostic for every file processed]' '(-f --silent --quiet)'{-f,--silent,--quiet}'[suppress most error messages]' '(--no-preserve-root)--preserve-root[fail to operate recursively on /]' "(--preserve-root)--no-preserve-root[don't treat / specially (default)]" '(1)--reference=[copy permissions of specified file]:file:_files' '(-R --recursive)'{-R,--recursive}'[change files and directories recursively]' '(- : *)--help[display help information]' '(- : *)--version[display version information]') 
	else
		args+=('-f[suppress most error messages]' '-R[change files and directories recursively]') 
		case $OSTYPE in
			(freebsd* | dragonfly* | darwin*) args+=('-v[output a diagnostic for every file processed]')  ;|
			(freebsd* | netbsd* | darwin* | dragonfly*) args+=("-h[operate on symlinks them self]")  ;|
			(freebsd* | openbsd* | netbsd* | darwin* | dragonfly*) args+=('(-H -L -P)-L[follow all symlinks]' '(-H -L -P)-H[follow symlinks on the command line]' '(-H -L -P)-P[do not follow symlinks (default)]')  ;|
			(darwin*) args+=('(1)-C[returns false if any of the named files have ACLs]' '(1)-N[remove ACLs from specified files]' '(1)-E[read ACL info from stdin as a sequential list of ACEs]' '(1)-i[removes inherited bit from all entries in named files ACLs]' '(1)-I[removes all inherited entries from named files ACLs]')  ;;
		esac
	fi
	_arguments -C -s "$args[@]" && ret=0 
	case "$state" in
		(files) if [[ -n $opt_args[--reference] ]]
			then
				zmodload -F zsh/stat b:zstat 2> /dev/null
				typeset -i8 ref=$(zstat +mode $opt_args[--reference]) 
				_wanted files expl file _files -g "*(-.^f${ref#??})" && ret=0 
			elif [[ $line[1] = [0-7]## ]]
			then
				_wanted files expl file _files -g "*(-.^f$line[1])" && ret=0 
			else
				local spec who op priv
				local -a specs
				for spec in ${(s:,:)line[1]}
				do
					if [[ ${spec#*[+-=]} != [rwxst]## ]]
					then
						_files && ret=0 
						return ret
					fi
					specs+=(${${(M)spec##[+-=]*}:+a}$spec) 
				done
				_wanted files expl file _files -g "*(-.^f:${(j.,.)specs}:)" && ret=0 
			fi ;;
	esac
	return ret
}
_chown () {
	# undefined
	builtin autoload -XUz
}
_chroot () {
	# undefined
	builtin autoload -XUz
}
_chrt () {
	# undefined
	builtin autoload -XUz
}
_chsh () {
	# undefined
	builtin autoload -XUz
}
_cksum () {
	# undefined
	builtin autoload -XUz
}
_clay () {
	# undefined
	builtin autoload -XUz
}
_cmdambivalent () {
	# undefined
	builtin autoload -XUz
}
_cmdstring () {
	# undefined
	builtin autoload -XUz
}
_cmp () {
	# undefined
	builtin autoload -XUz
}
_code () {
	# undefined
	builtin autoload -XUz
}
_column () {
	# undefined
	builtin autoload -XUz
}
_combination () {
	# undefined
	builtin autoload -XUz
}
_comm () {
	# undefined
	builtin autoload -XUz
}
_command () {
	# undefined
	builtin autoload -XUz
}
_command_names () {
	# undefined
	builtin autoload -XUz
}
_comp_locale () {
	# undefined
	builtin autoload -XUz
}
_compadd () {
	# undefined
	builtin autoload -XUz
}
_compdef () {
	# undefined
	builtin autoload -XUz
}
_complete () {
	local comp name oldcontext ret=1 service 
	typeset -T curcontext="$curcontext" ccarray 
	oldcontext="$curcontext" 
	if [[ -n "$compcontext" ]]
	then
		if [[ "${(t)compcontext}" = *array* ]]
		then
			local expl
			_wanted values expl value compadd -a - compcontext
		elif [[ "${(t)compcontext}" = *assoc* ]]
		then
			local expl tmp i
			tmp=() 
			for i in "${(@k)compcontext[(R)*[^[:blank:]]]}"
			do
				tmp=("$tmp[@]" "${i}:${compcontext[$i]}") 
			done
			tmp=("$tmp[@]" "${(k@)compcontext[(R)[[:blank:]]#]}") 
			_describe -t values value tmp
		elif [[ "$compcontext" = *:*:* ]]
		then
			local tag="${${compcontext%%:*}:-values}" 
			local descr="${${${compcontext#${tag}:}%%:*}:-value}" 
			local action="${compcontext#${tag}:${descr}:}" expl ws ret=1 
			case "$action" in
				(\ #) _message -e "$tag" "$descr" ;;
				(\(\(*\)\)) eval ws\=\( "${action[3,-3]}" \)
					_describe -t "$tag" "$descr" ws ;;
				(\(*\)) eval ws\=\( "${action[2,-2]}" \)
					_wanted "$tag" expl "$descr" compadd -a - ws ;;
				(\{*\}) _tags "$tag"
					while _tags
					do
						while _next_label "$tag" expl "$descr"
						do
							eval "$action[2,-2]" && ret=0 
						done
						(( ret )) || break
					done ;;
				(\ *) eval ws\=\( "$action" \)
					_tags "$tag"
					while _tags
					do
						while _next_label "$tag" expl "$descr"
						do
							"$ws[@]"
						done
						(( ret )) || break
					done ;;
				(*) eval ws\=\( "$action" \)
					_tags "$tag"
					while _tags
					do
						while _next_label "$tag" expl "$descr"
						do
							"$ws[1]" "$expl[@]" "${(@)ws[2,-1]}"
						done
						(( ret )) || break
					done ;;
			esac
		else
			ccarray[3]="$compcontext" 
			comp="$_comps[$compcontext]" 
			[[ -n "$comp" ]] && eval "$comp"
		fi
		return
	fi
	comp="$_comps[-first-]" 
	if [[ -n "$comp" ]]
	then
		service="${_services[-first-]:--first-}" 
		ccarray[3]=-first- 
		eval "$comp" && ret=0 
		if [[ "$_compskip" = all ]]
		then
			_compskip= 
			return ret
		fi
	fi
	[[ -n $compstate[vared] ]] && compstate[context]=vared 
	ret=1 
	if [[ "$compstate[context]" = command ]]
	then
		curcontext="$oldcontext" 
		_normal -s && ret=0 
	else
		local cname="-${compstate[context]:s/_/-/}-" 
		ccarray[3]="$cname" 
		comp="$_comps[$cname]" 
		service="${_services[$cname]:-$cname}" 
		if [[ -z "$comp" ]]
		then
			if [[ "$_compskip" = *default* ]]
			then
				_compskip= 
				return 1
			fi
			comp="$_comps[-default-]" 
			service="${_services[-default-]:--default-}" 
		fi
		[[ -n "$comp" ]] && eval "$comp" && ret=0 
	fi
	_compskip= 
	return ret
}
_complete_debug () {
	# undefined
	builtin autoload -XUz
}
_complete_help () {
	# undefined
	builtin autoload -XUz
}
_complete_help_generic () {
	# undefined
	builtin autoload -XUz
}
_complete_tag () {
	# undefined
	builtin autoload -XUz
}
_completers () {
	# undefined
	builtin autoload -XUz
}
_composer () {
	# undefined
	builtin autoload -XUz
}
_compress () {
	# undefined
	builtin autoload -XUz
}
_condition () {
	# undefined
	builtin autoload -XUz
}
_configure () {
	# undefined
	builtin autoload -XUz
}
_coreadm () {
	# undefined
	builtin autoload -XUz
}
_correct () {
	# undefined
	builtin autoload -XUz
}
_correct_filename () {
	# undefined
	builtin autoload -XUz
}
_correct_word () {
	# undefined
	builtin autoload -XUz
}
_cowsay () {
	# undefined
	builtin autoload -XUz
}
_cp () {
	# undefined
	builtin autoload -XUz
}
_cpio () {
	# undefined
	builtin autoload -XUz
}
_cplay () {
	# undefined
	builtin autoload -XUz
}
_cpupower () {
	# undefined
	builtin autoload -XUz
}
_crontab () {
	# undefined
	builtin autoload -XUz
}
_cryptsetup () {
	# undefined
	builtin autoload -XUz
}
_cscope () {
	# undefined
	builtin autoload -XUz
}
_cssh () {
	# undefined
	builtin autoload -XUz
}
_csup () {
	# undefined
	builtin autoload -XUz
}
_ctags_tags () {
	# undefined
	builtin autoload -XUz
}
_cu () {
	# undefined
	builtin autoload -XUz
}
_curl () {
	# undefined
	builtin autoload -XUz
}
_current_dir () {
	local _max_pwd_length="65" 
	if [[ $(echo -n $PWD | wc -c) -gt ${_max_pwd_length} ]]
	then
		echo "%{$fg_bold[blue]%}%-2~ ... %3~%{$reset_color%} "
	else
		echo "%{$fg_bold[blue]%}%~%{$reset_color%} "
	fi
}
_cut () {
	# undefined
	builtin autoload -XUz
}
_cvs () {
	# undefined
	builtin autoload -XUz
}
_cvsup () {
	# undefined
	builtin autoload -XUz
}
_cygcheck () {
	# undefined
	builtin autoload -XUz
}
_cygpath () {
	# undefined
	builtin autoload -XUz
}
_cygrunsrv () {
	# undefined
	builtin autoload -XUz
}
_cygserver () {
	# undefined
	builtin autoload -XUz
}
_cygstart () {
	# undefined
	builtin autoload -XUz
}
_dak () {
	# undefined
	builtin autoload -XUz
}
_darcs () {
	# undefined
	builtin autoload -XUz
}
_date () {
	# undefined
	builtin autoload -XUz
}
_date_formats () {
	# undefined
	builtin autoload -XUz
}
_dates () {
	# undefined
	builtin autoload -XUz
}
_dbus () {
	# undefined
	builtin autoload -XUz
}
_dchroot () {
	# undefined
	builtin autoload -XUz
}
_dchroot-dsa () {
	# undefined
	builtin autoload -XUz
}
_dconf () {
	# undefined
	builtin autoload -XUz
}
_dcop () {
	# undefined
	builtin autoload -XUz
}
_dcut () {
	# undefined
	builtin autoload -XUz
}
_dd () {
	# undefined
	builtin autoload -XUz
}
_deb_architectures () {
	# undefined
	builtin autoload -XUz
}
_deb_codenames () {
	# undefined
	builtin autoload -XUz
}
_deb_packages () {
	# undefined
	builtin autoload -XUz
}
_debbugs_bugnumber () {
	# undefined
	builtin autoload -XUz
}
_debchange () {
	# undefined
	builtin autoload -XUz
}
_debcheckout () {
	# undefined
	builtin autoload -XUz
}
_debdiff () {
	# undefined
	builtin autoload -XUz
}
_debfoster () {
	# undefined
	builtin autoload -XUz
}
_deborphan () {
	# undefined
	builtin autoload -XUz
}
_debsign () {
	# undefined
	builtin autoload -XUz
}
_debuild () {
	# undefined
	builtin autoload -XUz
}
_default () {
	# undefined
	builtin autoload -XUz
}
_defaults () {
	# undefined
	builtin autoload -XUz
}
_delimiters () {
	# undefined
	builtin autoload -XUz
}
_describe () {
	# undefined
	builtin autoload -XUz
}
_description () {
	local name gropt nopt xopt format gname hidden hide match opts tag sort
	opts=() 
	gropt=(-J) 
	xopt=(-X) 
	nopt=() 
	zparseopts -K -D -a nopt 1 2 V=gropt J=gropt x=xopt
	3="${${3##[[:blank:]]#}%%[[:blank:]]#}" 
	[[ -n "$3" ]] && _lastdescr=("$_lastdescr[@]" "$3") 
	zstyle -s ":completion:${curcontext}:$1" group-name gname && [[ -z "$gname" ]] && gname="$1" 
	_setup "$1" "${gname:--default-}"
	name="$2" 
	zstyle -s ":completion:${curcontext}:$1" format format || zstyle -s ":completion:${curcontext}:descriptions" format format
	if zstyle -s ":completion:${curcontext}:$1" hidden hidden && [[ "$hidden" = (all|yes|true|1|on) ]]
	then
		[[ "$hidden" = all ]] && format='' 
		opts=(-n) 
	fi
	zstyle -s ":completion:${curcontext}:$1" matcher match && opts=($opts -M "$match") 
	[[ -n "$_matcher" ]] && opts=($opts -M "$_matcher") 
	if {
			zstyle -s ":completion:${curcontext}:$1" sort sort || zstyle -s ":completion:${curcontext}:" sort sort
		} && [[ "$gropt" = -J && $sort != menu ]]
	then
		if [[ "$sort" = (yes|true|1|on) ]]
		then
			gropt=(-J) 
		else
			gropt=(-V) 
		fi
	fi
	if [[ -z "$_comp_no_ignore" ]]
	then
		zstyle -a ":completion:${curcontext}:$1" ignored-patterns _comp_ignore || _comp_ignore=() 
		if zstyle -s ":completion:${curcontext}:$1" ignore-line hidden
		then
			local -a qwords
			qwords=(${words//(#m)[\[\]()\\*?#<>~\^\|]/\\$MATCH}) 
			case "$hidden" in
				(true | yes | on | 1) _comp_ignore+=($qwords)  ;;
				(current) _comp_ignore+=($qwords[CURRENT])  ;;
				(current-shown) [[ "$compstate[old_list]" = *shown* ]] && _comp_ignore+=($qwords[CURRENT])  ;;
				(other) _comp_ignore+=($qwords[1,CURRENT-1] $qwords[CURRENT+1,-1])  ;;
			esac
		fi
		(( $#_comp_ignore )) && opts=(-F _comp_ignore $opts) 
	else
		_comp_ignore=() 
	fi
	tag="$1" 
	shift 2
	if [[ -z "$1" && $# -eq 1 ]]
	then
		format= 
	elif [[ -n "$format" ]]
	then
		zformat -f format "$format" "d:$1" "${(@)argv[2,-1]}"
	fi
	if [[ -n "$gname" ]]
	then
		if [[ -n "$format" ]]
		then
			set -A "$name" "$opts[@]" "$nopt[@]" "$gropt" "$gname" "$xopt" "$format"
		else
			set -A "$name" "$opts[@]" "$nopt[@]" "$gropt" "$gname"
		fi
	else
		if [[ -n "$format" ]]
		then
			set -A "$name" "$opts[@]" "$nopt[@]" "$gropt" -default- "$xopt" "$format"
		else
			set -A "$name" "$opts[@]" "$nopt[@]" "$gropt" -default-
		fi
	fi
	if ! (( ${funcstack[2,-1][(I)_description]} ))
	then
		local fakestyle descr
		for fakestyle in fake fake-always
		do
			zstyle -a ":completion:${curcontext}:$tag" $fakestyle match || continue
			descr=("${(@M)match:#*[^\\]:*}") 
			opts=("${(@P)name}") 
			if [[ $fakestyle = fake-always && $opts[1,2] = "-F _comp_ignore" ]]
			then
				shift 2 opts
			fi
			compadd "${(@)opts}" - "${(@)${(@)match:#*[^\\]:*}:s/\\:/:/}"
			(( $#descr )) && _describe -t "$tag" '' descr "${(@)opts}"
		done
	fi
	return 0
}
_devtodo () {
	# undefined
	builtin autoload -XUz
}
_df () {
	# undefined
	builtin autoload -XUz
}
_dhclient () {
	# undefined
	builtin autoload -XUz
}
_dhcpinfo () {
	# undefined
	builtin autoload -XUz
}
_dict () {
	# undefined
	builtin autoload -XUz
}
_dict_words () {
	# undefined
	builtin autoload -XUz
}
_diff () {
	# undefined
	builtin autoload -XUz
}
_diff3 () {
	# undefined
	builtin autoload -XUz
}
_diff_options () {
	# undefined
	builtin autoload -XUz
}
_diffstat () {
	# undefined
	builtin autoload -XUz
}
_dig () {
	# undefined
	builtin autoload -XUz
}
_dir_list () {
	# undefined
	builtin autoload -XUz
}
_directories () {
	# undefined
	builtin autoload -XUz
}
_directory_stack () {
	# undefined
	builtin autoload -XUz
}
_dirs () {
	# undefined
	builtin autoload -XUz
}
_disable () {
	# undefined
	builtin autoload -XUz
}
_dispatch () {
	local comp pat val name i ret=1 _compskip="$_compskip" 
	local curcontext="$curcontext" service str noskip 
	local -a match mbegin mend
	if [[ "$1" = -s ]]
	then
		noskip=yes 
		shift
	fi
	[[ -z "$noskip" ]] && _compskip= 
	curcontext="${curcontext%:*:*}:${1}:" 
	shift
	if [[ "$_compskip" != (all|*patterns*) ]]
	then
		for str in "$@"
		do
			[[ -n "$str" ]] || continue
			service="${_services[$str]:-$str}" 
			for i in "${(@)_patcomps[(K)$str]}"
			do
				if [[ $i = (#b)"="([^=]#)"="(*) ]]
				then
					service=$match[1] 
					i=$match[2] 
				fi
				eval "$i" && ret=0 
				if [[ "$_compskip" = *patterns* ]]
				then
					break
				elif [[ "$_compskip" = all ]]
				then
					_compskip='' 
					return ret
				fi
			done
		done
	fi
	ret=1 
	for str in "$@"
	do
		[[ -n "$str" ]] || continue
		str=${(Q)str} 
		name="$str" 
		comp="${_comps[$str]}" 
		service="${_services[$str]:-$str}" 
		[[ -z "$comp" ]] || break
	done
	if [[ -n "$comp" && "$name" != "${argv[-1]}" ]]
	then
		_compskip=patterns 
		eval "$comp" && ret=0 
		[[ "$_compskip" = (all|*patterns*) ]] && return ret
	fi
	if [[ "$_compskip" != (all|*patterns*) ]]
	then
		for str
		do
			[[ -n "$str" ]] || continue
			service="${_services[$str]:-$str}" 
			for i in "${(@)_postpatcomps[(K)$str]}"
			do
				_compskip=default 
				eval "$i" && ret=0 
				if [[ "$_compskip" = *patterns* ]]
				then
					break
				elif [[ "$_compskip" = all ]]
				then
					_compskip='' 
					return ret
				fi
			done
		done
	fi
	[[ "$name" = "${argv[-1]}" && -n "$comp" && "$_compskip" != (all|*default*) ]] && service="${_services[$name]:-$name}"  && eval "$comp" && ret=0 
	_compskip='' 
	return ret
}
_django () {
	# undefined
	builtin autoload -XUz
}
_dkms () {
	# undefined
	builtin autoload -XUz
}
_dladm () {
	# undefined
	builtin autoload -XUz
}
_dlocate () {
	# undefined
	builtin autoload -XUz
}
_dmesg () {
	# undefined
	builtin autoload -XUz
}
_dmidecode () {
	# undefined
	builtin autoload -XUz
}
_dnf () {
	# undefined
	builtin autoload -XUz
}
_dns_types () {
	# undefined
	builtin autoload -XUz
}
_doas () {
	# undefined
	builtin autoload -XUz
}
_docker-compose () {
	# undefined
	builtin autoload -XUz
}
_docker-machine () {
	# undefined
	builtin autoload -XUz
}
_domains () {
	# undefined
	builtin autoload -XUz
}
_dos2unix () {
	# undefined
	builtin autoload -XUz
}
_dpatch-edit-patch () {
	# undefined
	builtin autoload -XUz
}
_dpkg () {
	# undefined
	builtin autoload -XUz
}
_dpkg-buildpackage () {
	# undefined
	builtin autoload -XUz
}
_dpkg-cross () {
	# undefined
	builtin autoload -XUz
}
_dpkg-repack () {
	# undefined
	builtin autoload -XUz
}
_dpkg_source () {
	# undefined
	builtin autoload -XUz
}
_dput () {
	# undefined
	builtin autoload -XUz
}
_drill () {
	# undefined
	builtin autoload -XUz
}
_dsh () {
	# undefined
	builtin autoload -XUz
}
_dtrace () {
	# undefined
	builtin autoload -XUz
}
_dtruss () {
	# undefined
	builtin autoload -XUz
}
_du () {
	# undefined
	builtin autoload -XUz
}
_dumpadm () {
	# undefined
	builtin autoload -XUz
}
_dumper () {
	# undefined
	builtin autoload -XUz
}
_dupload () {
	# undefined
	builtin autoload -XUz
}
_dvi () {
	# undefined
	builtin autoload -XUz
}
_dynamic_directory_name () {
	# undefined
	builtin autoload -XUz
}
_e2label () {
	# undefined
	builtin autoload -XUz
}
_ecasound () {
	# undefined
	builtin autoload -XUz
}
_echotc () {
	# undefined
	builtin autoload -XUz
}
_echoti () {
	# undefined
	builtin autoload -XUz
}
_ed () {
	# undefined
	builtin autoload -XUz
}
_elfdump () {
	# undefined
	builtin autoload -XUz
}
_elinks () {
	# undefined
	builtin autoload -XUz
}
_elm () {
	# undefined
	builtin autoload -XUz
}
_email_addresses () {
	# undefined
	builtin autoload -XUz
}
_emulate () {
	# undefined
	builtin autoload -XUz
}
_enable () {
	# undefined
	builtin autoload -XUz
}
_enscript () {
	# undefined
	builtin autoload -XUz
}
_entr () {
	# undefined
	builtin autoload -XUz
}
_env () {
	# undefined
	builtin autoload -XUz
}
_eog () {
	# undefined
	builtin autoload -XUz
}
_equal () {
	# undefined
	builtin autoload -XUz
}
_espeak () {
	# undefined
	builtin autoload -XUz
}
_etags () {
	# undefined
	builtin autoload -XUz
}
_ethtool () {
	# undefined
	builtin autoload -XUz
}
_evince () {
	# undefined
	builtin autoload -XUz
}
_exec () {
	# undefined
	builtin autoload -XUz
}
_expand () {
	# undefined
	builtin autoload -XUz
}
_expand_alias () {
	# undefined
	builtin autoload -XUz
}
_expand_word () {
	# undefined
	builtin autoload -XUz
}
_extensions () {
	# undefined
	builtin autoload -XUz
}
_external_pwds () {
	# undefined
	builtin autoload -XUz
}
_fakeroot () {
	# undefined
	builtin autoload -XUz
}
_fbsd_architectures () {
	# undefined
	builtin autoload -XUz
}
_fc () {
	# undefined
	builtin autoload -XUz
}
_feh () {
	# undefined
	builtin autoload -XUz
}
_fetch () {
	# undefined
	builtin autoload -XUz
}
_fetchmail () {
	# undefined
	builtin autoload -XUz
}
_ffmpeg () {
	# undefined
	builtin autoload -XUz
}
_figlet () {
	# undefined
	builtin autoload -XUz
}
_file_descriptors () {
	# undefined
	builtin autoload -XUz
}
_file_flags () {
	# undefined
	builtin autoload -XUz
}
_file_modes () {
	# undefined
	builtin autoload -XUz
}
_file_systems () {
	# undefined
	builtin autoload -XUz
}
_files () {
	local -a match mbegin mend
	local ret=1 
	if _have_glob_qual $PREFIX
	then
		compset -p ${#match[1]}
		compset -S '[^\)\|\~]#(|\))'
		if [[ $_comp_caller_options[extendedglob] == on ]] && compset -P '\#'
		then
			_globflags && ret=0 
		else
			if [[ $_comp_caller_options[extendedglob] == on ]]
			then
				_describe -t globflags "glob flag" '(\#:introduce\ glob\ flag)' -Q -S '' && ret=0 
			fi
			_globquals && ret=0 
		fi
		return ret
	elif [[ $_comp_caller_options[extendedglob] == on && $PREFIX = \(\#[^\)]# ]] && compset -P '\(\#'
	then
		_globflags && return
	fi
	local opts tmp glob pat pats expl tag i def descr end ign tried
	local type sdef ignvars ignvar prepath oprefix rfiles rfile
	zparseopts -a opts '/=tmp' 'f=tmp' 'g+:-=tmp' q n 1 2 P: S: r: R: W: X+: M+: F: J+: V+:
	type="${(@j::M)${(@)tmp#-}#?}" 
	if (( $tmp[(I)-g*] ))
	then
		glob="${${${(@)${(@M)tmp:#-g*}#-g}##[[:blank:]]#}%%[[:blank:]]#}" 
		[[ "$glob" = *[^\\][[:blank:]]* ]] && glob="{${glob//(#b)([^\\])[[:blank:]]##/${match[1]},}}" 
		[[ "$glob" = (#b)(*\()([^\|\~]##\)) && $match[2] != \#q* ]] && glob="${match[1]}#q${match[2]}" 
	elif [[ $type = */* ]]
	then
		glob="*(#q-/)" 
	fi
	tmp=$opts[(I)-F] 
	if (( tmp ))
	then
		ignvars=($=opts[tmp+1]) 
		if [[ $ignvars = _comp_ignore ]]
		then
			ign=($_comp_ignore) 
		elif [[ $ignvars = \(* ]]
		then
			ign=(${=ignvars[2,-2]}) 
		else
			ign=() 
			for ignvar in $ignvars
			do
				ign+=(${(P)ignvar}) 
			done
			opts[tmp+1]=_comp_ignore 
		fi
	else
		ign=() 
	fi
	if zstyle -a ":completion:${curcontext}:" file-patterns tmp
	then
		pats=() 
		for i in ${tmp//\%p/${${glob:-\*}//:/\\:}}
		do
			if [[ $i = *[^\\]:* ]]
			then
				pats+=(" $i ") 
			else
				pats+=(" ${i}:files ") 
			fi
		done
	elif zstyle -t ":completion:${curcontext}:" list-dirs-first
	then
		pats=(" *(-/):directories:directory ${${glob:-*}//:/\\:}(#q^-/):globbed-files" '*:all-files') 
	else
		pats=("${${glob:-*}//:/\\:}:globbed-files *(-/):directories" '*:all-files ') 
	fi
	tried=() 
	for def in "$pats[@]"
	do
		eval "def=( ${${def//\\:/\\\\\\:}//(#b)([][()|*?^#~<>])/\\${match[1]}} )"
		tmp="${(@M)def#*[^\\]:}" 
		(( $tried[(I)${(q)tmp}] )) && continue
		tried=("$tried[@]" "$tmp") 
		for sdef in "$def[@]"
		do
			tag="${${sdef#*[^\\]:}%%:*}" 
			pat="${${sdef%%:${tag}*}//\\:/:}" 
			if [[ "$sdef" = *:${tag}:* ]]
			then
				descr="${(Q)sdef#*:${tag}:}" 
			else
				if (( $opts[(I)-X] ))
				then
					descr= 
				else
					descr=file 
				fi
				end=yes 
			fi
			_tags "$tag"
			while _tags
			do
				_comp_ignore=() 
				while _next_label "$tag" expl "$descr"
				do
					_comp_ignore=($_comp_ignore $ign) 
					if [[ -n "$end" ]]
					then
						if _path_files -g "$pat" "$opts[@]" "$expl[@]"
						then
							ret=0 
						elif [[ $PREFIX$SUFFIX != */* ]] && zstyle -a ":completion:${curcontext}:$tag" recursive-files rfiles
						then
							local subtree
							for rfile in $rfiles
							do
								if [[ $PWD/ = ${~rfile} ]]
								then
									if [[ -z $subtree ]]
									then
										subtree=(**/*(/)) 
									fi
									for prepath in $subtree
									do
										oprefix=$PREFIX 
										PREFIX=$prepath/$PREFIX 
										_path_files -g "$pat" "$opts[@]" "$expl[@]" && ret=0 
										PREFIX=$oprefix 
									done
									break
								fi
							done
						fi
					else
						_path_files "$expl[@]" -g "$pat" "$opts[@]" && ret=0 
					fi
				done
				(( ret )) || break
			done
			[[ "$pat" = '*' ]] && return ret
		done
		(( ret )) || return 0
	done
	return 1
}
_find () {
	# undefined
	builtin autoload -XUz
}
_find_net_interfaces () {
	# undefined
	builtin autoload -XUz
}
_finger () {
	# undefined
	builtin autoload -XUz
}
_fink () {
	# undefined
	builtin autoload -XUz
}
_first () {
	
}
_flac () {
	# undefined
	builtin autoload -XUz
}
_flasher () {
	# undefined
	builtin autoload -XUz
}
_flex () {
	# undefined
	builtin autoload -XUz
}
_floppy () {
	# undefined
	builtin autoload -XUz
}
_flowadm () {
	# undefined
	builtin autoload -XUz
}
_fmadm () {
	# undefined
	builtin autoload -XUz
}
_fmt () {
	# undefined
	builtin autoload -XUz
}
_fold () {
	# undefined
	builtin autoload -XUz
}
_fortune () {
	# undefined
	builtin autoload -XUz
}
_freebsd-update () {
	# undefined
	builtin autoload -XUz
}
_fs_usage () {
	# undefined
	builtin autoload -XUz
}
_fsh () {
	# undefined
	builtin autoload -XUz
}
_fstat () {
	# undefined
	builtin autoload -XUz
}
_functions () {
	# undefined
	builtin autoload -XUz
}
_fuse_arguments () {
	# undefined
	builtin autoload -XUz
}
_fuse_values () {
	# undefined
	builtin autoload -XUz
}
_fuser () {
	# undefined
	builtin autoload -XUz
}
_fusermount () {
	# undefined
	builtin autoload -XUz
}
_fw_update () {
	# undefined
	builtin autoload -XUz
}
_gcc () {
	# undefined
	builtin autoload -XUz
}
_gcore () {
	# undefined
	builtin autoload -XUz
}
_gdb () {
	# undefined
	builtin autoload -XUz
}
_geany () {
	# undefined
	builtin autoload -XUz
}
_gem () {
	# undefined
	builtin autoload -XUz
}
_generic () {
	# undefined
	builtin autoload -XUz
}
_genisoimage () {
	# undefined
	builtin autoload -XUz
}
_getclip () {
	# undefined
	builtin autoload -XUz
}
_getconf () {
	# undefined
	builtin autoload -XUz
}
_getent () {
	# undefined
	builtin autoload -XUz
}
_getfacl () {
	# undefined
	builtin autoload -XUz
}
_getmail () {
	# undefined
	builtin autoload -XUz
}
_getopt () {
	# undefined
	builtin autoload -XUz
}
_ghostscript () {
	# undefined
	builtin autoload -XUz
}
_git () {
	# undefined
	builtin autoload -XUz
}
_git-buildpackage () {
	# undefined
	builtin autoload -XUz
}
_git_log_prettily () {
	if ! [ -z $1 ]
	then
		git log --pretty=$1
	fi
}
_git_time_since_commit () {
	if last_commit=$(git log --pretty=format:'%at' -1 2> /dev/null) 
	then
		now=$(date +%s) 
		seconds_since_last_commit=$((now-last_commit)) 
		minutes=$((seconds_since_last_commit / 60)) 
		hours=$((seconds_since_last_commit/3600)) 
		days=$((seconds_since_last_commit / 86400)) 
		sub_hours=$((hours % 24)) 
		sub_minutes=$((minutes % 60)) 
		if [ $hours -ge 24 ]
		then
			commit_age="${days}d" 
		elif [ $minutes -gt 60 ]
		then
			commit_age="${sub_hours}h${sub_minutes}m" 
		else
			commit_age="${minutes}m" 
		fi
		color=$ZSH_THEME_GIT_TIME_SINCE_COMMIT_NEUTRAL 
		echo "$color$commit_age%{$reset_color%}"
	fi
}
_global () {
	# undefined
	builtin autoload -XUz
}
_global_tags () {
	# undefined
	builtin autoload -XUz
}
_globflags () {
	# undefined
	builtin autoload -XUz
}
_globqual_delims () {
	# undefined
	builtin autoload -XUz
}
_globquals () {
	# undefined
	builtin autoload -XUz
}
_gnome-gv () {
	# undefined
	builtin autoload -XUz
}
_gnu_generic () {
	# undefined
	builtin autoload -XUz
}
_gnupod () {
	# undefined
	builtin autoload -XUz
}
_gnutls () {
	# undefined
	builtin autoload -XUz
}
_go () {
	# undefined
	builtin autoload -XUz
}
_gpasswd () {
	# undefined
	builtin autoload -XUz
}
_gpg () {
	# undefined
	builtin autoload -XUz
}
_gphoto2 () {
	# undefined
	builtin autoload -XUz
}
_gprof () {
	# undefined
	builtin autoload -XUz
}
_gqview () {
	# undefined
	builtin autoload -XUz
}
_gradle () {
	# undefined
	builtin autoload -XUz
}
_graphicsmagick () {
	# undefined
	builtin autoload -XUz
}
_grep () {
	# undefined
	builtin autoload -XUz
}
_grep-excuses () {
	# undefined
	builtin autoload -XUz
}
_groff () {
	# undefined
	builtin autoload -XUz
}
_groups () {
	# undefined
	builtin autoload -XUz
}
_growisofs () {
	# undefined
	builtin autoload -XUz
}
_gsettings () {
	# undefined
	builtin autoload -XUz
}
_gstat () {
	# undefined
	builtin autoload -XUz
}
_guard () {
	# undefined
	builtin autoload -XUz
}
_guilt () {
	# undefined
	builtin autoload -XUz
}
_gv () {
	# undefined
	builtin autoload -XUz
}
_gzip () {
	# undefined
	builtin autoload -XUz
}
_hash () {
	# undefined
	builtin autoload -XUz
}
_have_glob_qual () {
	local complete
	[[ $2 = complete ]] && complete=")" 
	[[ -z $compstate[quote] && ( ( $_comp_caller_options[bareglobqual] == on && $1 = (#b)(((*[^\\\$]|)(\\\\)#)\()([^\)\|\~]#)$complete && ${#match[1]} -gt 1 ) || ( $_comp_caller_options[extendedglob] == on && $1 = (#b)(((*[^\\\$]|)(\\\\)#)"(#q")([^\)]#)$complete ) ) ]]
}
_hdiutil () {
	# undefined
	builtin autoload -XUz
}
_head () {
	# undefined
	builtin autoload -XUz
}
_helm () {
	# undefined
	builtin autoload -XUz
}
_hexdump () {
	# undefined
	builtin autoload -XUz
}
_hg () {
	# undefined
	builtin autoload -XUz
}
_history () {
	# undefined
	builtin autoload -XUz
}
_history-substring-search-begin () {
	setopt localoptions extendedglob
	_history_substring_search_refresh_display= 
	_history_substring_search_query_highlight= 
	if [[ -n $BUFFER && $BUFFER == ${_history_substring_search_result:-} ]]
	then
		return
	fi
	_history_substring_search_result='' 
	if [[ -z $BUFFER ]]
	then
		_history_substring_search_query= 
		_history_substring_search_query_parts=() 
		_history_substring_search_raw_matches=() 
	else
		_history_substring_search_query=$BUFFER 
		if [[ -n $HISTORY_SUBSTRING_SEARCH_FUZZY ]]
		then
			_history_substring_search_query_parts=(${=_history_substring_search_query}) 
		else
			_history_substring_search_query_parts=(${==_history_substring_search_query}) 
		fi
		local search_pattern="*${(j:*:)_history_substring_search_query_parts[@]//(#m)[\][()|\\*?#<>~^]/\\$MATCH}*" 
		_history_substring_search_raw_matches=(${(k)history[(R)(#$HISTORY_SUBSTRING_SEARCH_GLOBBING_FLAGS)${search_pattern}]}) 
	fi
	_history_substring_search_raw_match_index=0 
	_history_substring_search_matches=() 
	_history_substring_search_unique_filter=() 
	if [[ $WIDGET == history-substring-search-down ]]
	then
		_history_substring_search_match_index=1 
	else
		_history_substring_search_match_index=0 
	fi
}
_history-substring-search-down-buffer () {
	local buflines XRBUFFER xrbuflines
	buflines=(${(f)BUFFER}) 
	XRBUFFER="x"$RBUFFER 
	xrbuflines=(${(f)XRBUFFER}) 
	if [[ $#buflines -gt 1 && $CURSOR -ne $#BUFFER && $#xrbuflines -ne 1 ]]
	then
		zle down-line-or-history
		return 0
	fi
	return 1
}
_history-substring-search-down-history () {
	if [[ -z $_history_substring_search_query ]]
	then
		if [[ $HISTNO -eq 1 && -z $BUFFER ]]
		then
			BUFFER=${history[1]} 
			_history_substring_search_refresh_display=1 
		else
			zle down-line-or-history
		fi
		return 0
	fi
	return 1
}
_history-substring-search-down-search () {
	_history_substring_search_refresh_display=1 
	if [[ $_history_substring_search_match_index -lt 1 ]]
	then
		_history-substring-search-not-found
		return
	fi
	if _history-substring-search-has-prev
	then
		_history_substring_search_match_index+=-1 
		_history-substring-search-found
	else
		_history_substring_search_match_index+=-1 
		_history-substring-search-not-found
	fi
	if [[ -o HIST_IGNORE_ALL_DUPS || -n $HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE ]]
	then
		return
	fi
	if [[ -o HIST_FIND_NO_DUPS && $BUFFER == $_history_substring_search_result ]]
	then
		_history-substring-search-down-search
	fi
}
_history-substring-search-end () {
	setopt localoptions extendedglob
	_history_substring_search_result=$BUFFER 
	if [[ $_history_substring_search_refresh_display -eq 1 ]]
	then
		region_highlight=() 
		CURSOR=${#BUFFER} 
	fi
	_zsh_highlight
	if [[ -n $_history_substring_search_query_highlight ]]
	then
		local highlight_start_index=0 
		local highlight_end_index=0 
		local query_part
		for query_part in $_history_substring_search_query_parts
		do
			local escaped_query_part=${query_part//(#m)[\][()|\\*?#<>~^]/\\$MATCH} 
			local query_part_match_index="${${BUFFER:$highlight_start_index}[(i)(#$HISTORY_SUBSTRING_SEARCH_GLOBBING_FLAGS)${escaped_query_part}]}" 
			if [[ $query_part_match_index -le ${#BUFFER:$highlight_start_index} ]]
			then
				highlight_start_index=$(( $highlight_start_index + $query_part_match_index )) 
				highlight_end_index=$(( $highlight_start_index + ${#query_part} )) 
				region_highlight+=("$(($highlight_start_index - 1)) $(($highlight_end_index - 1)) $_history_substring_search_query_highlight") 
			fi
		done
	fi
	return 0
}
_history-substring-search-found () {
	BUFFER=$history[$_history_substring_search_matches[$_history_substring_search_match_index]] 
	_history_substring_search_query_highlight=$HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND 
}
_history-substring-search-has-next () {
	if [[ $_history_substring_search_match_index -lt $#_history_substring_search_matches ]]
	then
		return 0
	else
		_history_substring_search_process_raw_matches
		return $?
	fi
}
_history-substring-search-has-prev () {
	if [[ $_history_substring_search_match_index -gt 1 ]]
	then
		return 0
	else
		return 1
	fi
}
_history-substring-search-not-found () {
	BUFFER=$_history_substring_search_query 
	_history_substring_search_query_highlight=$HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_NOT_FOUND 
}
_history-substring-search-up-buffer () {
	local buflines XLBUFFER xlbuflines
	buflines=(${(f)BUFFER}) 
	XLBUFFER=$LBUFFER"x" 
	xlbuflines=(${(f)XLBUFFER}) 
	if [[ $#buflines -gt 1 && $CURSOR -ne $#BUFFER && $#xlbuflines -ne 1 ]]
	then
		zle up-line-or-history
		return 0
	fi
	return 1
}
_history-substring-search-up-history () {
	if [[ -z $_history_substring_search_query ]]
	then
		if [[ $HISTNO -eq 1 ]]
		then
			BUFFER= 
		else
			zle up-line-or-history
		fi
		return 0
	fi
	return 1
}
_history-substring-search-up-search () {
	_history_substring_search_refresh_display=1 
	if [[ $_history_substring_search_match_index -gt $#_history_substring_search_matches ]]
	then
		_history-substring-search-not-found
		return
	fi
	if _history-substring-search-has-next
	then
		_history_substring_search_match_index+=1 
		_history-substring-search-found
	else
		_history_substring_search_match_index+=1 
		_history-substring-search-not-found
	fi
	if [[ -o HIST_IGNORE_ALL_DUPS || -n $HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE ]]
	then
		return
	fi
	if [[ -o HIST_FIND_NO_DUPS && $BUFFER == $_history_substring_search_result ]]
	then
		_history-substring-search-up-search
	fi
}
_history_complete_word () {
	# undefined
	builtin autoload -XUz
}
_history_modifiers () {
	# undefined
	builtin autoload -XUz
}
_history_substring_search_process_raw_matches () {
	while [[ $_history_substring_search_raw_match_index -lt $#_history_substring_search_raw_matches ]]
	do
		_history_substring_search_raw_match_index+=1 
		local index=${_history_substring_search_raw_matches[$_history_substring_search_raw_match_index]} 
		if [[ ! -o HIST_IGNORE_ALL_DUPS && -n $HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE ]]
		then
			local entry=${history[$index]} 
			if [[ -z ${_history_substring_search_unique_filter[$entry]} ]]
			then
				_history_substring_search_unique_filter[$entry]=1 
				_history_substring_search_matches+=($index) 
				return 0
			fi
		else
			_history_substring_search_matches+=($index) 
			return 0
		fi
	done
	return 1
}
_host () {
	# undefined
	builtin autoload -XUz
}
_hostname () {
	# undefined
	builtin autoload -XUz
}
_hosts () {
	# undefined
	builtin autoload -XUz
}
_htop () {
	# undefined
	builtin autoload -XUz
}
_hwinfo () {
	# undefined
	builtin autoload -XUz
}
_iconv () {
	# undefined
	builtin autoload -XUz
}
_iconvconfig () {
	# undefined
	builtin autoload -XUz
}
_id () {
	# undefined
	builtin autoload -XUz
}
_ifconfig () {
	# undefined
	builtin autoload -XUz
}
_iftop () {
	# undefined
	builtin autoload -XUz
}
_ignored () {
	[[ _matcher_num -gt 1 || $compstate[ignored] -eq 0 ]] && return 1
	local comp
	integer ind
	if ! zstyle -a ":completion:${curcontext}:" completer comp
	then
		comp=("${(@)_completers[1,_completer_num-1]}") 
		ind=${comp[(I)_ignored(|:*)]} 
		(( ind )) && comp=("${(@)comp[ind,-1]}") 
	fi
	local _comp_no_ignore=yes tmp expl _completer _completer_num _matcher _c_matcher _matchers _matcher_num 
	_completer_num=1 
	for tmp in "$comp[@]"
	do
		if [[ "$tmp" = *:-* ]]
		then
			_completer="${${tmp%:*}[2,-1]//_/-}${tmp#*:}" 
			tmp="${tmp%:*}" 
		elif [[ $tmp = *:* ]]
		then
			_completer="${tmp#*:}" 
			tmp="${tmp%:*}" 
		else
			_completer="${tmp[2,-1]//_/-}" 
		fi
		curcontext="${curcontext/:[^:]#:/:${_completer}:}" 
		zstyle -a ":completion:${curcontext}:" matcher-list _matchers || _matchers=('') 
		_matcher_num=1 
		_matcher='' 
		for _c_matcher in "$_matchers[@]"
		do
			if [[ "$_c_matcher" == +* ]]
			then
				_matcher="$_matcher $_c_matcher[2,-1]" 
			else
				_matcher="$_c_matcher" 
			fi
			if [[ "$tmp" != _ignored ]] && "$tmp"
			then
				if zstyle -s ":completion:${curcontext}:" single-ignored tmp && [[ $compstate[old_list] != shown && $compstate[nmatches] -eq 1 ]]
				then
					case "$tmp" in
						(show) compstate[insert]='' compstate[list]='list force' tmp=''  ;;
						(menu) compstate[insert]=menu 
							_description original expl original
							compadd "$expl[@]" -S '' - "$PREFIX$SUFFIX" ;;
					esac
				fi
				return 0
			fi
			(( _matcher_num++ ))
		done
		(( _completer_num++ ))
	done
	return 1
}
_imagemagick () {
	# undefined
	builtin autoload -XUz
}
_in_vared () {
	# undefined
	builtin autoload -XUz
}
_inetadm () {
	# undefined
	builtin autoload -XUz
}
_init_d () {
	# undefined
	builtin autoload -XUz
}
_initctl () {
	# undefined
	builtin autoload -XUz
}
_install () {
	# undefined
	builtin autoload -XUz
}
_invoke-rc.d () {
	# undefined
	builtin autoload -XUz
}
_ionice () {
	# undefined
	builtin autoload -XUz
}
_iostat () {
	# undefined
	builtin autoload -XUz
}
_ip () {
	# undefined
	builtin autoload -XUz
}
_ipadm () {
	# undefined
	builtin autoload -XUz
}
_ipsec () {
	# undefined
	builtin autoload -XUz
}
_ipset () {
	# undefined
	builtin autoload -XUz
}
_iptables () {
	# undefined
	builtin autoload -XUz
}
_irssi () {
	# undefined
	builtin autoload -XUz
}
_ispell () {
	# undefined
	builtin autoload -XUz
}
_iwconfig () {
	# undefined
	builtin autoload -XUz
}
_jail () {
	# undefined
	builtin autoload -XUz
}
_jails () {
	# undefined
	builtin autoload -XUz
}
_java () {
	# undefined
	builtin autoload -XUz
}
_java_class () {
	# undefined
	builtin autoload -XUz
}
_jexec () {
	# undefined
	builtin autoload -XUz
}
_jls () {
	# undefined
	builtin autoload -XUz
}
_jobs () {
	# undefined
	builtin autoload -XUz
}
_jobs_bg () {
	# undefined
	builtin autoload -XUz
}
_jobs_builtin () {
	# undefined
	builtin autoload -XUz
}
_jobs_fg () {
	# undefined
	builtin autoload -XUz
}
_joe () {
	# undefined
	builtin autoload -XUz
}
_join () {
	# undefined
	builtin autoload -XUz
}
_jot () {
	# undefined
	builtin autoload -XUz
}
_jq () {
	# undefined
	builtin autoload -XUz
}
_kdeconnect () {
	# undefined
	builtin autoload -XUz
}
_kfmclient () {
	# undefined
	builtin autoload -XUz
}
_kill () {
	# undefined
	builtin autoload -XUz
}
_killall () {
	# undefined
	builtin autoload -XUz
}
_kind () {
	# undefined
	builtin autoload -XUz
}
_kld () {
	# undefined
	builtin autoload -XUz
}
_knock () {
	# undefined
	builtin autoload -XUz
}
_kpartx () {
	# undefined
	builtin autoload -XUz
}
_kubectx () {
	# undefined
	builtin autoload -XUz
}
_kubens () {
	# undefined
	builtin autoload -XUz
}
_kvno () {
	# undefined
	builtin autoload -XUz
}
_last () {
	# undefined
	builtin autoload -XUz
}
_ld_debug () {
	# undefined
	builtin autoload -XUz
}
_ldap () {
	# undefined
	builtin autoload -XUz
}
_ldconfig () {
	# undefined
	builtin autoload -XUz
}
_ldd () {
	# undefined
	builtin autoload -XUz
}
_legit () {
	# undefined
	builtin autoload -XUz
}
_less () {
	# undefined
	builtin autoload -XUz
}
_lha () {
	# undefined
	builtin autoload -XUz
}
_libvirt () {
	# undefined
	builtin autoload -XUz
}
_lighttpd () {
	# undefined
	builtin autoload -XUz
}
_limit () {
	# undefined
	builtin autoload -XUz
}
_limits () {
	# undefined
	builtin autoload -XUz
}
_links () {
	# undefined
	builtin autoload -XUz
}
_lintian () {
	# undefined
	builtin autoload -XUz
}
_list () {
	# undefined
	builtin autoload -XUz
}
_list_files () {
	local stat f elt what dir
	local -a stylevals
	integer ok
	listfiles=() 
	listopts=() 
	zstyle -a ":completion:${curcontext}:" file-list stylevals || return 1
	case $WIDGETSTYLE in
		(*complete*) what=insert  ;;
		(*) what=list  ;;
	esac
	for elt in $stylevals
	do
		case $elt in
			(*($what|all|true|1|yes)*=<->) (( ${(P)#1} <= ${elt##*=} )) && (( ok = 1 ))
				break ;;
			([^=]#($what|all|true|1|yes)[^=]#) (( ok = 1 ))
				break ;;
		esac
	done
	(( ok )) || return 1
	zmodload -F zsh/stat b:zstat 2> /dev/null || return 1
	dir=${2:+$2/} 
	dir=${(Q)dir} 
	for f in ${(PQ)1}
	do
		if [[ ! -e "$dir$f" ]]
		then
			listfiles+=("$dir$f") 
			continue
		fi
		zstat -s -H stat -F "%b %e %H:%M" - "$dir$f" > /dev/null 2>&1
		listfiles+=("$stat[mode] ${(l:3:)stat[nlink]} ${(r:8:)stat[uid]}  ${(r:8:)stat[gid]} ${(l:8:)stat[size]} $stat[mtime] $f") 
	done
	(( ${#listfiles} )) && listopts=(-d listfiles -l -o) 
	return 0
}
_lldb () {
	# undefined
	builtin autoload -XUz
}
_ln () {
	# undefined
	builtin autoload -XUz
}
_loadkeys () {
	# undefined
	builtin autoload -XUz
}
_locale () {
	# undefined
	builtin autoload -XUz
}
_localedef () {
	# undefined
	builtin autoload -XUz
}
_locales () {
	# undefined
	builtin autoload -XUz
}
_locate () {
	# undefined
	builtin autoload -XUz
}
_logical_volumes () {
	# undefined
	builtin autoload -XUz
}
_logs_completions () {
	if [ "${COMP_CWORD}" = "1" ]
	then
		COMPREPLY=($(compgen -W "$(docker ps --format="{{.Names}}\n{{.ID}}")" "${COMP_WORDS[1]}")) 
		return
	fi
}
_look () {
	# undefined
	builtin autoload -XUz
}
_lp () {
	# undefined
	builtin autoload -XUz
}
_ls () {
	# undefined
	builtin autoload -XUz
}
_lsattr () {
	# undefined
	builtin autoload -XUz
}
_lsblk () {
	# undefined
	builtin autoload -XUz
}
_lscfg () {
	# undefined
	builtin autoload -XUz
}
_lsdev () {
	# undefined
	builtin autoload -XUz
}
_lslv () {
	# undefined
	builtin autoload -XUz
}
_lsof () {
	# undefined
	builtin autoload -XUz
}
_lspv () {
	# undefined
	builtin autoload -XUz
}
_lsusb () {
	# undefined
	builtin autoload -XUz
}
_lsvg () {
	# undefined
	builtin autoload -XUz
}
_ltrace () {
	# undefined
	builtin autoload -XUz
}
_lua () {
	# undefined
	builtin autoload -XUz
}
_luarocks () {
	# undefined
	builtin autoload -XUz
}
_lynx () {
	# undefined
	builtin autoload -XUz
}
_lz4 () {
	# undefined
	builtin autoload -XUz
}
_lzop () {
	# undefined
	builtin autoload -XUz
}
_mac_applications () {
	# undefined
	builtin autoload -XUz
}
_mac_files_for_application () {
	# undefined
	builtin autoload -XUz
}
_madison () {
	# undefined
	builtin autoload -XUz
}
_mail () {
	# undefined
	builtin autoload -XUz
}
_mailboxes () {
	# undefined
	builtin autoload -XUz
}
_main_complete () {
	local IFS=$' \t\n\0' 
	eval "$_comp_setup"
	local func funcs ret=1 tmp _compskip format nm call match min max i num _completers _completer _completer_num curtag _comp_force_list _matchers _matcher _c_matcher _matcher_num _comp_tags _comp_mesg mesg str context state state_descr line opt_args val_args curcontext="$curcontext" _last_nmatches=-1 _last_menu_style _def_menu_style _menu_style sel _tags_level=0 _saved_exact="${compstate[exact]}" _saved_lastprompt="${compstate[last_prompt]}" _saved_list="${compstate[list]}" _saved_insert="${compstate[insert]}" _saved_colors="$ZLS_COLORS" _saved_colors_set=${+ZLS_COLORS} _ambiguous_color='' 
	local _comp_priv_prefix
	unset _comp_priv_prefix
	local -a precommands
	typeset -U _lastdescr _comp_ignore _comp_colors
	{
		[[ -z "$curcontext" ]] && curcontext=::: 
		zstyle -s ":completion:${curcontext}:" insert-tab tmp || tmp=yes 
		if [[ ( "$tmp" = *pending(|[[:blank:]]*) && PENDING -gt 0 ) || ( "$tmp" = *pending=(#b)([0-9]##)(|[[:blank:]]*) && PENDING -ge $match[1] ) ]]
		then
			compstate[insert]=tab 
			return 0
		fi
		if [[ "$compstate[insert]" = tab* ]]
		then
			if [[ "$tmp" = (|*[[:blank:]])(yes|true|on|1)(|[[:blank:]]*) ]]
			then
				if [[ "$curcontext" != :* || -z "$compstate[vared]" ]] || zstyle -t ":completion:vared${curcontext}:" insert-tab
				then
					return 0
				fi
			fi
			compstate[insert]="${compstate[insert]//tab /}" 
		fi
		if [[ "$compstate[pattern_match]" = "*" && "$_lastcomp[unambiguous]" = "$PREFIX" && -n "$_lastcomp[unambiguous_cursor]" ]]
		then
			integer upos="$_lastcomp[unambiguous_cursor]" 
			SUFFIX="$PREFIX[upos,-1]$SUFFIX" 
			PREFIX="$PREFIX[1,upos-1]" 
		fi
		if [[ -z "$compstate[quote]" ]]
		then
			if [[ -o equals ]] && compset -P 1 '='
			then
				compstate[context]=equal 
			elif [[ "$PREFIX" != */* && "$PREFIX[1]" = '~' ]]
			then
				compset -p 1
				compstate[context]=tilde 
			fi
		fi
		_setup default
		_def_menu_style=("$_last_menu_style[@]") 
		_last_menu_style=() 
		if zstyle -s ":completion:${curcontext}:default" list-prompt tmp
		then
			LISTPROMPT="$tmp" 
			zmodload -i zsh/complist
		fi
		if zstyle -s ":completion:${curcontext}:default" select-prompt tmp
		then
			MENUPROMPT="$tmp" 
			zmodload -i zsh/complist
		fi
		if zstyle -s ":completion:${curcontext}:default" select-scroll tmp
		then
			MENUSCROLL="$tmp" 
			zmodload -i zsh/complist
		fi
		if (( $# ))
		then
			if [[ "$1" = - ]]
			then
				if [[ $# -lt 3 ]]
				then
					_completers=() 
				else
					_completers=("$2") 
					call=yes 
				fi
			else
				_completers=("$@") 
			fi
		else
			zstyle -a ":completion:${curcontext}:" completer _completers || _completers=(_complete _ignored) 
		fi
		_completer_num=1 
		integer SECONDS=0 
		TRAPINT () {
			zle -M "Killed by signal in ${funcstack[2]} after ${SECONDS}s"
			zle -R
			return 130
		}
		TRAPQUIT () {
			zle -M "Killed by signal in ${funcstack[2]} after ${SECONDS}s"
			zle -R
			return 131
		}
		funcs=("$compprefuncs[@]") 
		compprefuncs=() 
		for func in "$funcs[@]"
		do
			"$func"
		done
		for tmp in "$_completers[@]"
		do
			if [[ -n "$call" ]]
			then
				_completer="${tmp}" 
			elif [[ "$tmp" = *:-* ]]
			then
				_completer="${${tmp%:*}[2,-1]//_/-}${tmp#*:}" 
				tmp="${tmp%:*}" 
			elif [[ $tmp = *:* ]]
			then
				_completer="${tmp#*:}" 
				tmp="${tmp%:*}" 
			else
				_completer="${tmp[2,-1]//_/-}" 
			fi
			curcontext="${curcontext/:[^:]#:/:${_completer}:}" 
			zstyle -t ":completion:${curcontext}:" show-completer && zle -R "Trying completion for :completion:${curcontext}"
			zstyle -a ":completion:${curcontext}:" matcher-list _matchers || _matchers=('') 
			_matcher_num=1 
			_matcher='' 
			for _c_matcher in "$_matchers[@]"
			do
				if [[ "$_c_matcher" == +* ]]
				then
					_matcher="$_matcher $_c_matcher[2,-1]" 
				else
					_matcher="$_c_matcher" 
				fi
				_comp_mesg= 
				if [[ -n "$call" ]]
				then
					if "${(@)argv[3,-1]}"
					then
						ret=0 
						break 2
					fi
				elif "$tmp"
				then
					ret=0 
					break 2
				fi
				(( _matcher_num++ ))
			done
			[[ -n "$_comp_mesg" ]] && break
			(( _completer_num++ ))
		done
		curcontext="${curcontext/:[^:]#:/::}" 
		if [[ $compstate[old_list] = keep ]]
		then
			nm=$_lastcomp[nmatches] 
		else
			nm=$compstate[nmatches] 
		fi
		if [[ $compstate[old_list] = keep || nm -gt 1 ]]
		then
			[[ _last_nmatches -ge 0 && _last_nmatches -ne nm ]] && _menu_style=("$_last_menu_style[@]" "$_menu_style[@]") 
			tmp=$(( compstate[list_lines] + BUFFERLINES + 1 )) 
			_menu_style=("$_menu_style[@]" "$_def_menu_style[@]") 
			if [[ "$compstate[list]" = *list && tmp -gt LINES && ( -n "$_menu_style[(r)select=long-list]" || -n "$_menu_style[(r)(yes|true|on|1)=long-list]" ) ]]
			then
				compstate[insert]=menu 
			elif [[ "$compstate[insert]" = "$_saved_insert" ]]
			then
				if [[ -n "$compstate[insert]" && -n "$_menu_style[(r)(yes|true|1|on)=long]" && tmp -gt LINES ]]
				then
					compstate[insert]=menu 
				else
					sel=("${(@M)_menu_style:#(yes|true|1|on)*}") 
					if (( $#sel ))
					then
						min=9999999 
						for i in "$sel[@]"
						do
							if [[ "$i" = *\=[0-9]* ]]
							then
								num="${i#*\=}" 
								[[ num -lt 0 ]] && num=0 
							elif [[ "$i" != *\=* ]]
							then
								num=0 
							else
								num=9999999 
							fi
							[[ num -lt min ]] && min="$num" 
							(( min )) || break
						done
					fi
					sel=("${(@M)_menu_style:#(no|false|0|off)*}") 
					if (( $#sel ))
					then
						max=9999999 
						for i in "$sel[@]"
						do
							if [[ "$i" = *\=[0-9]* ]]
							then
								num="${i#*\=}" 
								[[ num -lt 0 ]] && num=0 
							elif [[ "$i" != *\=* ]]
							then
								num=0 
							else
								num=9999999 
							fi
							[[ num -lt max ]] && max="$num" 
							(( max )) || break
						done
					fi
					if [[ ( -n "$min" && nm -ge min && ( -z "$max" || nm -lt max ) ) || ( -n "$_menu_style[(r)auto*]" && "$compstate[insert]" = automenu ) ]]
					then
						compstate[insert]=menu 
					elif [[ -n "$max" && nm -ge max ]]
					then
						compstate[insert]=unambiguous 
					elif [[ -n "$_menu_style[(r)auto*]" && "$compstate[insert]" != automenu ]]
					then
						compstate[insert]=automenu-unambiguous 
					fi
				fi
			fi
			if [[ "$compstate[insert]" = *menu* ]]
			then
				[[ "$MENUSELECT" = 00 ]] && MENUSELECT=0 
				if [[ -n "$_menu_style[(r)no-select*]" ]]
				then
					unset MENUSELECT
				elif [[ -n "$_menu_style[(r)select=long*]" ]]
				then
					if [[ tmp -gt LINES ]]
					then
						zmodload -i zsh/complist
						MENUSELECT=00 
					fi
				fi
				if [[ "$MENUSELECT" != 00 ]]
				then
					sel=("${(@M)_menu_style:#select*}") 
					if (( $#sel ))
					then
						min=9999999 
						for i in "$sel[@]"
						do
							if [[ "$i" = *\=[0-9]* ]]
							then
								num="${i#*\=}" 
								[[ num -lt 0 ]] && num=0 
							elif [[ "$i" != *\=* ]]
							then
								num=0 
							else
								num=9999999 
							fi
							[[ num -lt min ]] && min="$num" 
							(( min )) || break
						done
						zmodload -i zsh/complist
						MENUSELECT="$min" 
					else
						unset MENUSELECT
					fi
				fi
				if [[ -n "$MENUSELECT" ]]
				then
					if [[ -n "$_menu_style[(r)interactive*]" ]]
					then
						MENUMODE=interactive 
					elif [[ -n "$_menu_style[(r)search*]" ]]
					then
						if [[ -n "$_menu_style[(r)*backward*]" ]]
						then
							MENUMODE=search-backward 
						else
							MENUMODE=search-forward 
						fi
					else
						unset MENUMODE
					fi
				fi
			fi
		elif [[ nm -lt 1 && -n "$_comp_mesg" ]]
		then
			compstate[insert]='' 
			compstate[list]='list force' 
		elif [[ nm -eq 0 && -z "$_comp_mesg" && $#_lastdescr -ne 0 && $compstate[old_list] != keep ]] && zstyle -s ":completion:${curcontext}:warnings" format format
		then
			compstate[list]='list force' 
			compstate[insert]='' 
			tmp=("\`${(@)^_lastdescr:#}'") 
			case $#tmp in
				(1) str="$tmp[1]"  ;;
				(2) str="$tmp[1] or $tmp[2]"  ;;
				(*) str="${(j:, :)tmp[1,-2]}, or $tmp[-1]"  ;;
			esac
			_setup warnings
			zformat -f mesg "$format" "d:$str" "D:${(F)${(@)_lastdescr:#}}"
			compadd -x "$mesg"
		fi
		if [[ -n "$_ambiguous_color" ]]
		then
			local toquote='[=\(\)\|~^?*[\]#<>]' 
			local prefix=${${compstate[unambiguous]}[1,${compstate[unambiguous_cursor]}-1]} 
			[[ -n $prefix ]] && _comp_colors+=("=(#i)${prefix[1,-2]//?/(}${prefix[1,-2]//(#m)?/${MATCH/$~toquote/\\$MATCH}|)}${prefix[-1]//(#m)$~toquote/\\$MATCH}(#b)(?|)*==$_ambiguous_color") 
		fi
		[[ "$_comp_force_list" = always || ( "$_comp_force_list" = ?* && nm -ge _comp_force_list ) ]] && compstate[list]="${compstate[list]//messages} force" 
	} always {
		if [[ "$compstate[old_list]" = keep ]]
		then
			if [[ $_saved_colors_set = 1 ]]
			then
				ZLS_COLORS="$_saved_colors" 
			else
				unset ZLS_COLORS
			fi
		elif (( $#_comp_colors ))
		then
			ZLS_COLORS="${(j.:.)_comp_colors}" 
		else
			unset ZLS_COLORS
		fi
	}
	funcs=("$comppostfuncs[@]") 
	comppostfuncs=() 
	for func in "$funcs[@]"
	do
		"$func"
	done
	_lastcomp=("${(@kv)compstate}") 
	_lastcomp[nmatches]=$nm 
	_lastcomp[completer]="$_completer" 
	_lastcomp[prefix]="$PREFIX" 
	_lastcomp[suffix]="$SUFFIX" 
	_lastcomp[iprefix]="$IPREFIX" 
	_lastcomp[isuffix]="$ISUFFIX" 
	_lastcomp[qiprefix]="$QIPREFIX" 
	_lastcomp[qisuffix]="$QISUFFIX" 
	_lastcomp[tags]="$_comp_tags" 
	return ret
}
_make () {
	# undefined
	builtin autoload -XUz
}
_make-kpkg () {
	# undefined
	builtin autoload -XUz
}
_man () {
	# undefined
	builtin autoload -XUz
}
_match () {
	# undefined
	builtin autoload -XUz
}
_math () {
	# undefined
	builtin autoload -XUz
}
_math_params () {
	# undefined
	builtin autoload -XUz
}
_matlab () {
	# undefined
	builtin autoload -XUz
}
_md5sum () {
	# undefined
	builtin autoload -XUz
}
_mdadm () {
	# undefined
	builtin autoload -XUz
}
_mdatp () {
	# undefined
	builtin autoload -XUz
}
_mdfind () {
	# undefined
	builtin autoload -XUz
}
_mdls () {
	# undefined
	builtin autoload -XUz
}
_mdutil () {
	# undefined
	builtin autoload -XUz
}
_members () {
	# undefined
	builtin autoload -XUz
}
_mencal () {
	# undefined
	builtin autoload -XUz
}
_menu () {
	# undefined
	builtin autoload -XUz
}
_mere () {
	# undefined
	builtin autoload -XUz
}
_mergechanges () {
	# undefined
	builtin autoload -XUz
}
_message () {
	# undefined
	builtin autoload -XUz
}
_mh () {
	# undefined
	builtin autoload -XUz
}
_mii-tool () {
	# undefined
	builtin autoload -XUz
}
_mime_types () {
	# undefined
	builtin autoload -XUz
}
_minikube () {
	# undefined
	builtin autoload -XUz
}
_mixerctl () {
	# undefined
	builtin autoload -XUz
}
_mkdir () {
	# undefined
	builtin autoload -XUz
}
_mkfifo () {
	# undefined
	builtin autoload -XUz
}
_mknod () {
	# undefined
	builtin autoload -XUz
}
_mkshortcut () {
	# undefined
	builtin autoload -XUz
}
_mktemp () {
	# undefined
	builtin autoload -XUz
}
_mkzsh () {
	# undefined
	builtin autoload -XUz
}
_module () {
	# undefined
	builtin autoload -XUz
}
_module-assistant () {
	# undefined
	builtin autoload -XUz
}
_module_math_func () {
	# undefined
	builtin autoload -XUz
}
_modutils () {
	# undefined
	builtin autoload -XUz
}
_mondo () {
	# undefined
	builtin autoload -XUz
}
_monotone () {
	# undefined
	builtin autoload -XUz
}
_moosic () {
	# undefined
	builtin autoload -XUz
}
_mosh () {
	# undefined
	builtin autoload -XUz
}
_most_recent_file () {
	# undefined
	builtin autoload -XUz
}
_mount () {
	# undefined
	builtin autoload -XUz
}
_mozilla () {
	# undefined
	builtin autoload -XUz
}
_mpc () {
	# undefined
	builtin autoload -XUz
}
_mplayer () {
	# undefined
	builtin autoload -XUz
}
_mt () {
	# undefined
	builtin autoload -XUz
}
_mtools () {
	# undefined
	builtin autoload -XUz
}
_mtr () {
	# undefined
	builtin autoload -XUz
}
_multi_parts () {
	# undefined
	builtin autoload -XUz
}
_mupdf () {
	# undefined
	builtin autoload -XUz
}
_mutt () {
	# undefined
	builtin autoload -XUz
}
_mv () {
	# undefined
	builtin autoload -XUz
}
_my_accounts () {
	# undefined
	builtin autoload -XUz
}
_mysql_utils () {
	# undefined
	builtin autoload -XUz
}
_mysqldiff () {
	# undefined
	builtin autoload -XUz
}
_nautilus () {
	# undefined
	builtin autoload -XUz
}
_nbsd_architectures () {
	# undefined
	builtin autoload -XUz
}
_ncftp () {
	# undefined
	builtin autoload -XUz
}
_nedit () {
	# undefined
	builtin autoload -XUz
}
_net_interfaces () {
	# undefined
	builtin autoload -XUz
}
_netcat () {
	# undefined
	builtin autoload -XUz
}
_netscape () {
	# undefined
	builtin autoload -XUz
}
_netstat () {
	# undefined
	builtin autoload -XUz
}
_networkmanager () {
	# undefined
	builtin autoload -XUz
}
_networksetup () {
	# undefined
	builtin autoload -XUz
}
_newsgroups () {
	# undefined
	builtin autoload -XUz
}
_next_label () {
	local __gopt __descr __spec
	__gopt=() 
	zparseopts -D -a __gopt 1 2 V J x
	if comptags -A "$1" curtag __spec
	then
		(( $#funcstack > _tags_level )) && _comp_tags="${_comp_tags% * }" 
		_tags_level=$#funcstack 
		_comp_tags="$_comp_tags $__spec " 
		if [[ "$curtag" = *[^\\]:* ]]
		then
			zformat -f __descr "${curtag#*:}" "d:$3"
			_description "$__gopt[@]" "${curtag%:*}" "$2" "$__descr"
			curtag="${curtag%:*}" 
			set -A $2 "${(P@)2}" "${(@)argv[4,-1]}"
		else
			_description "$__gopt[@]" "$curtag" "$2" "$3"
			set -A $2 "${(@)argv[4,-1]}" "${(P@)2}"
		fi
		return 0
	fi
	return 1
}
_next_tags () {
	# undefined
	builtin autoload -XUz
}
_nginx () {
	# undefined
	builtin autoload -XUz
}
_ngrep () {
	# undefined
	builtin autoload -XUz
}
_nice () {
	# undefined
	builtin autoload -XUz
}
_nkf () {
	# undefined
	builtin autoload -XUz
}
_nl () {
	# undefined
	builtin autoload -XUz
}
_nm () {
	# undefined
	builtin autoload -XUz
}
_nmap () {
	# undefined
	builtin autoload -XUz
}
_normal () {
	local _comp_command1 _comp_command2 _comp_command skip
	if [[ "$1" = -s ]]
	then
		skip=(-s) 
	else
		skip=() 
		_compskip='' 
	fi
	if [[ -o BANG_HIST && ( ( $words[CURRENT] = \!*: && -z $compstate[quote] ) || ( $words[CURRENT] = \"\!*: && $compstate[all_quotes] = \" ) ) ]]
	then
		PREFIX=${PREFIX//\\!/!} 
		compset -P '*:'
		_history_modifiers h
		return
	fi
	if [[ CURRENT -eq 1 ]]
	then
		curcontext="${curcontext%:*:*}:-command-:" 
		comp="$_comps[-command-]" 
		[[ -n "$comp" ]] && eval "$comp" && return
		return 1
	fi
	_set_command
	_dispatch "$skip[@]" "$_comp_command" "$_comp_command1" "$_comp_command2" -default-
}
_nothing () {
	# undefined
	builtin autoload -XUz
}
_notmuch () {
	# undefined
	builtin autoload -XUz
}
_npm () {
	# undefined
	builtin autoload -XUz
}
_nslookup () {
	# undefined
	builtin autoload -XUz
}
_numfmt () {
	# undefined
	builtin autoload -XUz
}
_nvram () {
	# undefined
	builtin autoload -XUz
}
_objdump () {
	# undefined
	builtin autoload -XUz
}
_object_classes () {
	# undefined
	builtin autoload -XUz
}
_object_files () {
	# undefined
	builtin autoload -XUz
}
_obsd_architectures () {
	# undefined
	builtin autoload -XUz
}
_od () {
	# undefined
	builtin autoload -XUz
}
_okular () {
	# undefined
	builtin autoload -XUz
}
_oldlist () {
	# undefined
	builtin autoload -XUz
}
_omz_diag_dump_check_core_commands () {
	builtin echo "Core command check:"
	local redefined name builtins externals reserved_words
	redefined=() 
	reserved_words=(do done esac then elif else fi for case if while function repeat time until select coproc nocorrect foreach end '!' '[[' '{' '}') 
	builtins=(alias autoload bg bindkey break builtin bye cd chdir command comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues continue dirs disable disown echo echotc echoti emulate enable eval exec exit false fc fg functions getln getopts hash jobs kill let limit log logout noglob popd print printf pushd pushln pwd r read rehash return sched set setopt shift source suspend test times trap true ttyctl type ulimit umask unalias unfunction unhash unlimit unset unsetopt vared wait whence where which zcompile zle zmodload zparseopts zregexparse zstyle) 
	if is-at-least 5.1
	then
		reserved_word+=(declare export integer float local readonly typeset) 
	else
		builtins+=(declare export integer float local readonly typeset) 
	fi
	builtins_fatal=(builtin command local) 
	externals=(zsh) 
	for name in $reserved_words
	do
		if [[ $(builtin whence -w $name) != "$name: reserved" ]]
		then
			builtin echo "reserved word '$name' has been redefined"
			builtin which $name
			redefined+=$name 
		fi
	done
	for name in $builtins
	do
		if [[ $(builtin whence -w $name) != "$name: builtin" ]]
		then
			builtin echo "builtin '$name' has been redefined"
			builtin which $name
			redefined+=$name 
		fi
	done
	for name in $externals
	do
		if [[ $(builtin whence -w $name) != "$name: command" ]]
		then
			builtin echo "command '$name' has been redefined"
			builtin which $name
			redefined+=$name 
		fi
	done
	if [[ -n "$redefined" ]]
	then
		builtin echo "SOME CORE COMMANDS HAVE BEEN REDEFINED: $redefined"
	else
		builtin echo "All core commands are defined normally"
	fi
}
_omz_diag_dump_echo_file_w_header () {
	local file=$1 
	if [[ -f $file || -h $file ]]
	then
		builtin echo "========== $file =========="
		if [[ -h $file ]]
		then
			builtin echo "==========    ( => ${file:A} )   =========="
		fi
		command cat $file
		builtin echo "========== end $file =========="
		builtin echo
	elif [[ -d $file ]]
	then
		builtin echo "File '$file' is a directory"
	elif [[ ! -e $file ]]
	then
		builtin echo "File '$file' does not exist"
	else
		command ls -lad "$file"
	fi
}
_omz_diag_dump_one_big_text () {
	local program programs progfile md5
	builtin echo oh-my-zsh diagnostic dump
	builtin echo
	builtin echo $outfile
	builtin echo
	command date
	command uname -a
	builtin echo OSTYPE=$OSTYPE
	builtin echo ZSH_VERSION=$ZSH_VERSION
	builtin echo User: $USER
	builtin echo umask: $(umask)
	builtin echo
	_omz_diag_dump_os_specific_version
	builtin echo
	programs=(sh zsh ksh bash sed cat grep ls find git posh) 
	local progfile="" extra_str="" sha_str="" 
	for program in $programs
	do
		extra_str="" sha_str="" 
		progfile=$(builtin which $program) 
		if [[ $? == 0 ]]
		then
			if [[ -e $progfile ]]
			then
				if builtin whence shasum &> /dev/null
				then
					sha_str=($(command shasum $progfile)) 
					sha_str=$sha_str[1] 
					extra_str+=" SHA $sha_str" 
				fi
				if [[ -h "$progfile" ]]
				then
					extra_str+=" ( -> ${progfile:A} )" 
				fi
			fi
			builtin printf '%-9s %-20s %s\n' "$program is" "$progfile" "$extra_str"
		else
			builtin echo "$program: not found"
		fi
	done
	builtin echo
	builtin echo Command Versions:
	builtin echo "zsh: $(zsh --version)"
	builtin echo "this zsh session: $ZSH_VERSION"
	builtin echo "bash: $(bash --version | command grep bash)"
	builtin echo "git: $(git --version)"
	builtin echo "grep: $(grep --version)"
	builtin echo
	_omz_diag_dump_check_core_commands || return 1
	builtin echo
	builtin echo Process state:
	builtin echo pwd: $PWD
	if builtin whence pstree &> /dev/null
	then
		builtin echo Process tree for this shell:
		pstree -p $$
	else
		ps -fT
	fi
	builtin set | command grep -a '^\(ZSH\|plugins\|TERM\|LC_\|LANG\|precmd\|chpwd\|preexec\|FPATH\|TTY\|DISPLAY\|PATH\)\|OMZ'
	builtin echo
	builtin echo Exported:
	builtin echo $(builtin export | command sed 's/=.*//')
	builtin echo
	builtin echo Locale:
	command locale
	builtin echo
	builtin echo Zsh configuration:
	builtin echo setopt: $(builtin setopt)
	builtin echo
	builtin echo zstyle:
	builtin zstyle
	builtin echo
	builtin echo 'compaudit output:'
	compaudit
	builtin echo
	builtin echo '$fpath directories:'
	command ls -lad $fpath
	builtin echo
	builtin echo oh-my-zsh installation:
	command ls -ld ~/.z*
	command ls -ld ~/.oh*
	builtin echo
	builtin echo oh-my-zsh git state:
	(
		cd $ZSH && builtin echo "HEAD: $(git rev-parse HEAD)" && git remote -v && git status | command grep "[^[:space:]]"
	)
	if [[ $verbose -ge 1 ]]
	then
		(
			cd $ZSH && git reflog --date=default | command grep pull
		)
	fi
	builtin echo
	if [[ -e $ZSH_CUSTOM ]]
	then
		local custom_dir=$ZSH_CUSTOM 
		if [[ -h $custom_dir ]]
		then
			custom_dir=$(cd $custom_dir && pwd -P) 
		fi
		builtin echo "oh-my-zsh custom dir:"
		builtin echo "   $ZSH_CUSTOM ($custom_dir)"
		(
			cd ${custom_dir:h} && command find ${custom_dir:t} -name .git -prune -o -print
		)
		builtin echo
	fi
	if [[ $verbose -ge 1 ]]
	then
		builtin echo "bindkey:"
		builtin bindkey
		builtin echo
		builtin echo "infocmp:"
		command infocmp -L
		builtin echo
	fi
	local zdotdir=${ZDOTDIR:-$HOME} 
	builtin echo "Zsh configuration files:"
	local cfgfile cfgfiles
	cfgfiles=(/etc/zshenv /etc/zprofile /etc/zshrc /etc/zlogin /etc/zlogout $zdotdir/.zshenv $zdotdir/.zprofile $zdotdir/.zshrc $zdotdir/.zlogin $zdotdir/.zlogout ~/.zsh.pre-oh-my-zsh /etc/bashrc /etc/profile ~/.bashrc ~/.profile ~/.bash_profile ~/.bash_logout) 
	command ls -lad $cfgfiles 2>&1
	builtin echo
	if [[ $verbose -ge 1 ]]
	then
		for cfgfile in $cfgfiles
		do
			_omz_diag_dump_echo_file_w_header $cfgfile
		done
	fi
	builtin echo
	builtin echo "Zsh compdump files:"
	local dumpfile dumpfiles
	command ls -lad $zdotdir/.zcompdump*
	dumpfiles=($zdotdir/.zcompdump*(N)) 
	if [[ $verbose -ge 2 ]]
	then
		for dumpfile in $dumpfiles
		do
			_omz_diag_dump_echo_file_w_header $dumpfile
		done
	fi
}
_omz_diag_dump_os_specific_version () {
	local osname osver version_file version_files
	case "$OSTYPE" in
		(darwin*) osname=$(command sw_vers -productName) 
			osver=$(command sw_vers -productVersion) 
			builtin echo "OS Version: $osname $osver build $(sw_vers -buildVersion)" ;;
		(cygwin) command systeminfo | command head -4 | command tail -2 ;;
	esac
	if builtin which lsb_release > /dev/null
	then
		builtin echo "OS Release: $(command lsb_release -s -d)"
	fi
	version_files=(/etc/*-release(N) /etc/*-version(N) /etc/*_version(N)) 
	for version_file in $version_files
	do
		builtin echo "$version_file:"
		command cat "$version_file"
		builtin echo
	done
}
_omz_osx_get_frontmost_app () {
	local the_app=$(
    osascript 2>/dev/null <<EOF
      tell application "System Events"
        name of first item of (every process whose frontmost is true)
      end tell
EOF
  ) 
	echo "$the_app"
}
_open () {
	# undefined
	builtin autoload -XUz
}
_openstack () {
	# undefined
	builtin autoload -XUz
}
_opkg () {
	# undefined
	builtin autoload -XUz
}
_options () {
	# undefined
	builtin autoload -XUz
}
_options_set () {
	# undefined
	builtin autoload -XUz
}
_options_unset () {
	# undefined
	builtin autoload -XUz
}
_osascript () {
	# undefined
	builtin autoload -XUz
}
_osc () {
	# undefined
	builtin autoload -XUz
}
_other_accounts () {
	# undefined
	builtin autoload -XUz
}
_otool () {
	# undefined
	builtin autoload -XUz
}
_pack () {
	# undefined
	builtin autoload -XUz
}
_parameter () {
	# undefined
	builtin autoload -XUz
}
_parameters () {
	# undefined
	builtin autoload -XUz
}
_paste () {
	# undefined
	builtin autoload -XUz
}
_patch () {
	# undefined
	builtin autoload -XUz
}
_patchutils () {
	# undefined
	builtin autoload -XUz
}
_path_commands () {
	# undefined
	builtin autoload -XUz
}
_path_files () {
	local -a match mbegin mend
	local splitchars
	if zstyle -s ":completion:${curcontext}:" file-split-chars splitchars
	then
		compset -P "*[${(q)splitchars}]"
	fi
	if _have_glob_qual $PREFIX
	then
		local ret=1 
		compset -p ${#match[1]}
		compset -S '[^\)\|\~]#(|\))'
		if [[ $_comp_caller_options[extendedglob] == on ]] && compset -P '\#'
		then
			_globflags && ret=0 
		else
			if [[ $_comp_caller_options[extendedglob] == on ]]
			then
				local -a flags
				flags=('#:introduce glob flag') 
				_describe -t globflags "glob flag" flags -Q -S '' && ret=0 
			fi
			_globquals && ret=0 
		fi
		return ret
	fi
	local linepath realpath donepath prepath testpath exppath skips skipped
	local tmp1 tmp2 tmp3 tmp4 i orig eorig pre suf tpre tsuf opre osuf cpre
	local pats haspats ignore pfx pfxsfx sopt gopt opt sdirs ignpar cfopt listsfx
	local nm=$compstate[nmatches] menu matcher mopts sort mid accex fake 
	local listfiles listopts tmpdisp origtmp1 Uopt
	local accept_exact_dirs path_completion
	integer npathcheck
	local -a Mopts
	typeset -U prepaths exppaths
	exppaths=() 
	zparseopts -a mopts 'P:=pfx' 'S:=pfxsfx' 'q=pfxsfx' 'r:=pfxsfx' 'R:=pfxsfx' 'W:=prepaths' 'F:=ignore' 'M+:=matcher' J+: V+: X+: 1 2 n 'f=tmp1' '/=tmp1' 'g+:-=tmp1'
	sopt="-${(@j::M)${(@)tmp1#-}#?}" 
	(( $tmp1[(I)-[/g]*] )) && haspats=yes 
	(( $tmp1[(I)-g*] )) && gopt=yes 
	if (( $tmp1[(I)-/] ))
	then
		pats="${(@)${(@M)tmp1:#-g*}#-g}" 
		pats=('*(-/)' ${${(z):-x $pats}[2,-1]}) 
	else
		pats="${(@)${(@M)tmp1:#-g*}#-g}" 
		pats=(${${(z):-x $pats}[2,-1]}) 
	fi
	pats=("${(@)pats:# #}") 
	if (( $#pfx ))
	then
		compset -P "${(b)pfx[2]}" || pfxsfx=("$pfx[@]" "$pfxsfx[@]") 
	fi
	if (( $#prepaths ))
	then
		tmp1="${prepaths[2]}" 
		if [[ "$tmp1[1]" = '(' ]]
		then
			prepaths=(${^=tmp1[2,-2]%/}/) 
		elif [[ "$tmp1[1]" = '/' ]]
		then
			prepaths=("${tmp1%/}/") 
		else
			prepaths=(${(P)^tmp1%/}/) 
			(( ! $#prepaths )) && prepaths=(${tmp1%/}/) 
		fi
		(( ! $#prepaths )) && prepaths=('') 
	else
		prepaths=('') 
	fi
	if (( $#ignore ))
	then
		if [[ "${ignore[2]}" = \(* ]]
		then
			ignore=(${=ignore[2][2,-2]}) 
		else
			ignore=(${(P)ignore[2]}) 
		fi
	fi
	if [[ "$sopt" = -(f|) ]]
	then
		if [[ -z "$gopt" ]]
		then
			sopt='-f' 
			pats=('*') 
		else
			unset sopt
		fi
	fi
	if (( ! $mopts[(I)-[JVX]] ))
	then
		local expl
		if [[ -z "$gopt" && "$sopt" = -/ ]]
		then
			_description directories expl directory
		else
			_description files expl file
		fi
		tmp1=$expl[(I)-M*] 
		if (( tmp1 ))
		then
			if (( $#matcher ))
			then
				matcher[2]="$matcher[2] $expl[1+tmp1]" 
			else
				matcher=(-M "$expl[1+tmp1]") 
			fi
		fi
		mopts=("$mopts[@]" "$expl[@]") 
	fi
	[[ -z "$_comp_no_ignore" && $#ignore -eq 0 && ( -z $gopt || "$pats" = \ #\*\ # ) && -n $FIGNORE ]] && ignore=("?*${^fignore[@]}") 
	if (( $#ignore ))
	then
		_comp_ignore=("$_comp_ignore[@]" "$ignore[@]") 
		(( $mopts[(I)-F] )) || mopts=("$mopts[@]" -F _comp_ignore) 
	fi
	if [[ $#matcher -eq 0 && -o nocaseglob ]]
	then
		matcher=(-M 'm:{a-zA-Z}={A-Za-z}') 
	fi
	if (( $#matcher ))
	then
		mopts=("$mopts[@]" "$matcher[@]") 
	fi
	if zstyle -s ":completion:${curcontext}:" file-sort tmp1
	then
		case "$tmp1" in
			(*size*) sort=oL  ;;
			(*links*) sort=ol  ;;
			(*(time|date|modi)*) sort=om  ;;
			(*access*) sort=oa  ;;
			(*(inode|change)*) sort=oc  ;;
			(*) sort=on  ;;
		esac
		[[ "$tmp1" = *rev* ]] && sort[1]=O 
		[[ "$tmp1" = *follow* ]] && sort="-${sort}-" 
		if [[ "$sort" = on ]]
		then
			sort= 
		else
			mopts=("${(@)mopts/#-J/-V}") 
			tmp2=() 
			for tmp1 in "$pats[@]"
			do
				if _have_glob_qual "$tmp1" complete
				then
					tmp2+=("${match[1]}#q${sort})(${match[5]})") 
				else
					tmp2+=("${tmp1}(${sort})") 
				fi
			done
			pats=("$tmp2[@]") 
		fi
	fi
	if zstyle -t ":completion:${curcontext}:paths" squeeze-slashes
	then
		skips='((.|..|)/)##' 
	else
		skips='((.|..)/)##' 
	fi
	zstyle -s ":completion:${curcontext}:paths" special-dirs sdirs
	zstyle -t ":completion:${curcontext}:paths" list-suffixes && listsfx=yes 
	[[ "$pats" = ((|*[[:blank:]])\*(|[[:blank:]]*|\([^[:blank:]]##\))|*\([^[:blank:]]#/[^[:blank:]]#\)*) ]] && sopt=$sopt/ 
	zstyle -a ":completion:${curcontext}:paths" accept-exact accex
	zstyle -a ":completion:${curcontext}:" fake-files fake
	zstyle -s ":completion:${curcontext}:" ignore-parents ignpar
	zstyle -t ":completion:${curcontext}:paths" accept-exact-dirs && accept_exact_dirs=1 
	zstyle -T ":completion:${curcontext}:paths" path-completion && path_completion=1 
	if [[ -n "$compstate[pattern_match]" ]]
	then
		if {
				[[ -z "$SUFFIX" ]] && _have_glob_qual "$PREFIX" complete
			} || _have_glob_qual "$SUFFIX" complete
		then
			tmp3=${match[5]} 
			if [[ -n "$SUFFIX" ]]
			then
				SUFFIX=${match[2]} 
			else
				PREFIX=${match[2]} 
			fi
			tmp2=() 
			for tmp1 in "$pats[@]"
			do
				if _have_glob_qual "$tmp1" complete
				then
					tmp2+=("${match[1]}${tmp3}${match[5]})") 
				else
					tmp2+=("${tmp1}(${tmp3})") 
				fi
			done
			pats=("$tmp2[@]") 
		fi
	fi
	pre="$PREFIX" 
	suf="$SUFFIX" 
	opre="$PREFIX" 
	osuf="$SUFFIX" 
	orig="${PREFIX}${SUFFIX}" 
	eorig="$orig" 
	[[ $compstate[insert] = (*menu|[0-9]*) || -n "$_comp_correct" || ( -n "$compstate[pattern_match]" && "${orig#\~}" != (|*[^\\])[][*?#~^\|\<\>]* ) ]] && menu=yes 
	if [[ -n "$_comp_correct" ]]
	then
		cfopt=- 
		Uopt=-U 
	else
		Mopts=(-M "r:|/=* r:|=*") 
	fi
	if [[ "$pre" = [^][*?#^\|\<\>\\]#(\`[^\`]#\`|\$)*/* && "$compstate[quote]" != \' ]]
	then
		linepath="${(M)pre##*\$[^/]##/}" 
		() {
			setopt localoptions nounset
			eval 'realpath=${(e)~linepath}' 2> /dev/null
		}
		[[ -z "$realpath" || "$realpath" = "$linepath" ]] && return 1
		pre="${pre#${linepath}}" 
		i='[^/]' 
		i="${#linepath//$i}" 
		orig="${orig[1,(in:i:)/][1,-2]}" 
		donepath= 
		prepaths=('') 
	elif [[ "$pre[1]" = \~ && "$compstate[quote]" = (|\`) ]]
	then
		linepath="${pre[2,-1]%%/*}" 
		if [[ -z "$linepath" ]]
		then
			realpath="${HOME%/}/" 
		elif [[ "$linepath" = ([-+]|)[0-9]## ]]
		then
			if [[ "$linepath" != [-+]* ]]
			then
				tmp1="$linepath" 
			else
				if [[ "$linepath" = -* ]]
				then
					tmp1=$(( $#dirstack $linepath )) 
				else
					tmp1=$linepath[2,-1] 
				fi
				[[ -o pushdminus ]] && tmp1=$(( $#dirstack - $tmp1 )) 
			fi
			if (( ! tmp1 ))
			then
				realpath=$PWD/ 
			elif [[ tmp1 -le $#dirstack ]]
			then
				realpath=$dirstack[tmp1]/ 
			else
				_message 'not enough directory stack entries'
				return 1
			fi
		elif [[ "$linepath" = [-+] ]]
		then
			realpath=${~:-\~$linepath}/ 
		else
			eval "realpath=~${linepath}/" 2> /dev/null
			if [[ -z "$realpath" ]]
			then
				_message "unknown user \`$linepath'"
				return 1
			fi
		fi
		linepath="~${linepath}/" 
		[[ "$realpath" = "$linepath" ]] && return 1
		pre="${pre#*/}" 
		orig="${orig#*/}" 
		donepath= 
		prepaths=('') 
	else
		linepath= 
		realpath= 
		if zstyle -s ":completion:${curcontext}:" preserve-prefix tmp1 && [[ -n "$tmp1" && "$pre" = (#b)(${~tmp1})* ]]
		then
			pre="$pre[${#match[1]}+1,-1]" 
			orig="$orig[${#match[1]}+1,-1]" 
			donepath="$match[1]" 
			prepaths=('') 
		elif [[ "$pre[1]" = / ]]
		then
			pre="$pre[2,-1]" 
			orig="$orig[2,-1]" 
			donepath='/' 
			prepaths=('') 
		else
			[[ "$pre" = (.|..)/* ]] && prepaths=('') 
			donepath= 
		fi
	fi
	for prepath in "$prepaths[@]"
	do
		skipped= 
		cpre= 
		if [[ ( -n $accept_exact_dirs || -z $path_completion ) && ${pre} = (#b)(*)/([^/]#) ]]
		then
			tmp1=${match[1]} 
			tpre=${match[2]} 
			tmp2=$tmp1 
			tmp1=${tmp1//(#b)\\(?)/$match[1]} 
			tpre=${tpre//(#b)\\([^\\\]\[\^\~\(\)\#\*\?])/$match[1]} 
			tmp3=${donepath//(#b)\\(?)/$match[1]} 
			while true
			do
				if [[ -z $path_completion || -d $prepath$realpath$tmp3$tmp2 ]]
				then
					tmp3=$tmp3$tmp1/ 
					donepath=${tmp3//(#b)([\\\]\[\^\~\(\)\#\*\?])/\\$match[1]} 
					pre=$tpre 
					break
				elif [[ $tmp1 = (#b)(*)/([^/]#) ]]
				then
					tmp1=$match[1] 
					tpre=$match[2]/$tpre 
				else
					break
				fi
			done
		fi
		tpre="$pre" 
		tsuf="$suf" 
		testpath="${donepath//(#b)\\([\\\]\[\^\~\(\)\#\*\?])/$match[1]}" 
		tmp2="${(M)tpre##${~skips}}" 
		tpre="${tpre#$tmp2}" 
		tmp1=("$prepath$realpath$donepath$tmp2") 
		(( npathcheck = 0 ))
		while true
		do
			origtmp1=("${tmp1[@]}") 
			if [[ "$tpre" = */* ]]
			then
				PREFIX="${tpre%%/*}" 
				SUFFIX= 
			else
				PREFIX="${tpre}" 
				SUFFIX="${tsuf%%/*}" 
			fi
			tmp2=("$tmp1[@]") 
			if [[ "$tpre$tsuf" = (#b)*/(*) ]]
			then
				if [[ -n "$fake${match[1]}" ]]
				then
					compfiles -P$cfopt tmp1 accex "$skipped" "$_matcher $matcher[2]" "$sdirs" fake
				else
					compfiles -P$cfopt tmp1 accex "$skipped" "$_matcher $matcher[2]" '' fake
				fi
			elif [[ "$sopt" = *[/f]* ]]
			then
				compfiles -p$cfopt tmp1 accex "$skipped" "$_matcher $matcher[2]" "$sdirs" fake "$pats[@]"
			else
				compfiles -p$cfopt tmp1 accex "$skipped" "$_matcher $matcher[2]" '' fake "$pats[@]"
			fi
			tmp1=($~tmp1)  2> /dev/null
			if [[ -n "$PREFIX$SUFFIX" ]]
			then
				if (( ! $#tmp1 && npathcheck == 0 ))
				then
					(( npathcheck = 1 ))
					for tmp3 in "$tmp2[@]"
					do
						if [[ -n $tmp3 && $tmp3 != */ ]]
						then
							tmp3+=/ 
						fi
						if [[ -e "$tmp3${(Q)PREFIX}${(Q)SUFFIX}" ]]
						then
							(( npathcheck = 2 ))
						fi
					done
					if (( npathcheck == 2 ))
					then
						tmp1=("$origtmp1[@]") 
						continue
					fi
				fi
				if (( ! $#tmp1 ))
				then
					tmp2=(${^${tmp2:#/}}/$PREFIX$SUFFIX) 
				elif [[ "$tmp1[1]" = */* ]]
				then
					if [[ -n "$_comp_correct" ]]
					then
						tmp2=("$tmp1[@]") 
						builtin compadd -D tmp1 "$matcher[@]" - "${(@)tmp1:t}"
						if [[ $#tmp1 -eq 0 ]]
						then
							tmp1=("$tmp2[@]") 
							compadd -D tmp1 "$matcher[@]" - "${(@)tmp2:t}"
						fi
					else
						tmp2=("$tmp1[@]") 
						compadd -D tmp1 "$matcher[@]" - "${(@)tmp1:t}"
					fi
				else
					tmp2=('') 
					compadd -D tmp1 "$matcher[@]" -a tmp1
				fi
				if (( ! $#tmp1 ))
				then
					if [[ "$tmp2[1]" = */* ]]
					then
						tmp2=("${(@)tmp2#${prepath}${realpath}}") 
						if [[ "$tmp2[1]" = */* ]]
						then
							tmp2=("${(@)tmp2:h}") 
							compquote tmp2
							if [[ "$tmp2" = */ ]]
							then
								exppaths=("$exppaths[@]" ${^tmp2}${tpre}${tsuf}) 
							else
								exppaths=("$exppaths[@]" ${^tmp2}/${tpre}${tsuf}) 
							fi
						elif [[ ${tpre}${tsuf} = */* ]]
						then
							exppaths=("$exppaths[@]" ${tpre}${tsuf}) 
						fi
					fi
					continue 2
				fi
			elif (( ! $#tmp1 ))
			then
				if [[ -z "$tpre$tsuf" && -n "$pre$suf" ]]
				then
					pfxsfx=(-S '' "$pfxsfx[@]") 
				elif [[ -n "$haspats" && -z "$tpre$tsuf$suf" && "$pre" = */ ]]
				then
					PREFIX="${opre}" 
					SUFFIX="${osuf}" 
					compadd -nQS '' - "$linepath$donepath$orig"
					tmp4=- 
				fi
				continue 2
			fi
			if [[ -n "$ignpar" && -z "$_comp_no_ignore" && "$tpre$tsuf" != */* && $#tmp1 -ne 0 && ( "$ignpar" != *dir* || "$pats" = '*(-/)' ) && ( "$ignpar" != *..* || "$tmp1[1]" = *../* ) ]]
			then
				compfiles -i tmp1 ignore "$ignpar" "$prepath$realpath$donepath"
				_comp_ignore+=(${(@)ignore#$prepath$realpath$donepath}) 
				(( $#_comp_ignore && ! $mopts[(I)-F] )) && mopts=("$mopts[@]" -F _comp_ignore) 
			fi
			if [[ "$tpre" = */* ]]
			then
				tpre="${tpre#*/}" 
			elif [[ "$tsuf" = */* ]]
			then
				tpre="${tsuf#*/}" 
				tsuf= 
			else
				break
			fi
			tmp2="${(M)tpre##${~skips}}" 
			if [[ -n "$tmp2" ]]
			then
				skipped="/$tmp2" 
				tpre="${tpre#$tmp2}" 
			else
				skipped=/ 
			fi
			(( npathcheck = 0 ))
		done
		tmp3="$pre$suf" 
		tpre="$pre" 
		tsuf="$suf" 
		if [[ -n "${prepath}${realpath}${testpath}" ]]
		then
			if [[ -o nocaseglob ]]
			then
				tmp1=("${(@)tmp1#(#i)${prepath}${realpath}${testpath}}") 
			else
				tmp1=("${(@)tmp1#${prepath}${realpath}${testpath}}") 
			fi
		fi
		while true
		do
			compfiles -r tmp1 "${(Q)tmp3}"
			tmp4=$? 
			if [[ "$tpre" = */* ]]
			then
				tmp2="${cpre}${tpre%%/*}" 
				PREFIX="${linepath}${donepath}${tmp2}" 
				SUFFIX="/${tpre#*/}${tsuf#*/}" 
			else
				tmp2="${cpre}${tpre}" 
				PREFIX="${linepath}${donepath}${tmp2}" 
				SUFFIX="${tsuf}" 
			fi
			if (( tmp4 ))
			then
				tmp2="$testpath" 
				if [[ -n "$linepath" ]]
				then
					compquote -p tmp2 tmp1
				elif [[ -n "$tmp2" ]]
				then
					compquote -p tmp1
					compquote tmp2
				else
					compquote tmp1 tmp2
				fi
				if [[ -z "$_comp_correct" && "$compstate[pattern_match]" = \* && -n "$listsfx" && "$tmp2" = (|*[^\\])[][*?#~^\|\<\>]* ]]
				then
					PREFIX="$opre" 
					SUFFIX="$osuf" 
				fi
				if [[ -z "$compstate[insert]" ]] || {
						! zstyle -t ":completion:${curcontext}:paths" expand suffix && [[ -z "$listsfx" && ( -n "$_comp_correct" || -z "$compstate[pattern_match]" || "$SUFFIX" != */* || "${SUFFIX#*/}" = (|*[^\\])[][*?#~^\|\<\>]* ) ]]
					}
				then
					(( tmp4 )) && zstyle -t ":completion:${curcontext}:paths" ambiguous && compstate[to_end]= 
					if [[ "$tmp3" = */* ]]
					then
						if [[ -z "$listsfx" || "$tmp3" != */?* ]]
						then
							tmp1=("${(@)tmp1%%/*}") 
							_list_files tmp1 "$prepath$realpath$testpath"
							compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp2" -s "/${tmp3#*/}${Uopt:+$ISUFFIX}" -W "$prepath$realpath$testpath" "$pfxsfx[@]" $Mopts $listopts -a tmp1
						else
							tmp1=("${(@)^tmp1%%/*}/${tmp3#*/}") 
							_list_files tmp1 "$prepath$realpath$testpath"
							compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp2" -s "${Uopt:+$ISUFFIX}" -W "$prepath$realpath$testpath" "$pfxsfx[@]" $Mopts $listopts -a tmp1
						fi
					else
						_list_files tmp1 "$prepath$realpath$testpath"
						compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp2" -s "${Uopt:+$ISUFFIX}" -W "$prepath$realpath$testpath" "$pfxsfx[@]" $Mopts $listopts -a tmp1
					fi
				else
					if [[ "$tmp3" = */* ]]
					then
						tmp4=($Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp2" -W "$prepath$realpath$testpath" "$pfxsfx[@]" $Mopts) 
						if [[ -z "$listsfx" ]]
						then
							for i in "$tmp1[@]"
							do
								tmpdisp=("$i") 
								_list_files tmpdisp "$prepath$realpath$testpath"
								compadd "$tmp4[@]" -s "${Uopt:+$ISUFFIX}" $listopts - "$tmpdisp"
							done
						else
							[[ -n "$compstate[pattern_match]" ]] && SUFFIX="${SUFFIX:s./.*/}*" 
							for i in "$tmp1[@]"
							do
								_list_files i "$prepath$realpath$testpath"
								compadd "$tmp4[@]" $listopts - "$i"
							done
						fi
					else
						_list_files tmp1 "$prepath$realpath$testpath"
						compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp2" -s "${Uopt:+$ISUFFIX}" -W "$prepath$realpath$testpath" "$pfxsfx[@]" $Mopts $listopts -a tmp1
					fi
				fi
				tmp4=- 
				break
			fi
			if [[ "$tmp3" != */* ]]
			then
				tmp4= 
				break
			fi
			testpath="${testpath}${tmp1[1]%%/*}/" 
			tmp3="${tmp3#*/}" 
			if [[ "$tpre" = */* ]]
			then
				if [[ -z "$_comp_correct" && -n "$compstate[pattern_match]" && "$tmp2" = (|*[^\\])[][*?#~^\|\<\>]* ]]
				then
					cpre="${cpre}${tmp1[1]%%/*}/" 
				else
					cpre="${cpre}${tpre%%/*}/" 
				fi
				tpre="${tpre#*/}" 
			elif [[ "$tsuf" = */* ]]
			then
				[[ "$tsuf" != /* ]] && mid="$testpath" 
				if [[ -z "$_comp_correct" && -n "$compstate[pattern_match]" && "$tmp2" = (|*[^\\])[][*?#~^\|\<\>]* ]]
				then
					cpre="${cpre}${tmp1[1]%%/*}/" 
				else
					cpre="${cpre}${tpre}/" 
				fi
				tpre="${tsuf#*/}" 
				tsuf= 
			else
				tpre= 
				tsuf= 
			fi
			tmp1=("${(@)tmp1#*/}") 
		done
		if [[ -z "$tmp4" ]]
		then
			if [[ "$mid" = */ ]]
			then
				PREFIX="${opre}" 
				SUFFIX="${osuf}" 
				tmp4="${testpath#${mid}}" 
				if [[ $mid = */*/* ]]
				then
					tmp3="${mid%/*/}" 
					tmp2="${${mid%/}##*/}" 
					if [[ -n "$linepath" ]]
					then
						compquote -p tmp3
					else
						compquote tmp3
					fi
					compquote tmp4 tmp2 tmp1
					for i in "$tmp1[@]"
					do
						_list_files tmp2 "$prepath$realpath${mid%/*/}"
						compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp3/" -s "/$tmp4$i${Uopt:+$ISUFFIX}" -W "$prepath$realpath${mid%/*/}/" "$pfxsfx[@]" $Mopts $listopts - "$tmp2"
					done
				else
					tmp2="${${mid%/}##*/}" 
					compquote tmp4 tmp2 tmp1
					for i in "$tmp1[@]"
					do
						_list_files tmp2 "$prepath$realpath${mid%/*/}"
						compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath" -s "/$tmp4$i${Uopt:+$ISUFFIX}" -W "$prepath$realpath" "$pfxsfx[@]" $Mopts $listopts - "$tmp2"
					done
				fi
			else
				if [[ "$osuf" = */* ]]
				then
					PREFIX="${opre}${osuf}" 
					SUFFIX= 
				else
					PREFIX="${opre}" 
					SUFFIX="${osuf}" 
				fi
				tmp4="$testpath" 
				if [[ -n "$linepath" ]]
				then
					compquote -p tmp4 tmp1
				elif [[ -n "$tmp4" ]]
				then
					compquote -p tmp1
					compquote tmp4
				else
					compquote tmp4 tmp1
				fi
				if [[ -z "$_comp_correct" && -n "$compstate[pattern_match]" && "${PREFIX#\~}$SUFFIX" = (|*[^\\])[][*?#~^\|\<\>]* ]]
				then
					tmp1=("$linepath$tmp4${(@)^tmp1}") 
					_list_files tmp1 "$prepath$realpath"
					compadd -Qf -W "$prepath$realpath" "$pfxsfx[@]" "$mopts[@]" -M "r:|/=* r:|=*" $listopts -a tmp1
				else
					_list_files tmp1 "$prepath$realpath$testpath"
					compadd $Uopt -Qf -p "${Uopt:+$IPREFIX}$linepath$tmp4" -s "${Uopt:+$ISUFFIX}" -W "$prepath$realpath$testpath" "$pfxsfx[@]" "$mopts[@]" $Mopts $listopts -a tmp1
				fi
			fi
		fi
	done
	if [[ _matcher_num -eq ${#_matchers} ]] && zstyle -t ":completion:${curcontext}:paths" expand prefix && [[ nm -eq compstate[nmatches] && $#exppaths -ne 0 && "$linepath$exppaths" != "$eorig" ]]
	then
		PREFIX="${opre}" 
		SUFFIX="${osuf}" 
		compadd -Q "$mopts[@]" -S '' -M "r:|/=* r:|=*" -p "$linepath" -a exppaths
	fi
	[[ nm -ne compstate[nmatches] ]]
}
_pax () {
	# undefined
	builtin autoload -XUz
}
_pbcopy () {
	# undefined
	builtin autoload -XUz
}
_pbm () {
	# undefined
	builtin autoload -XUz
}
_pbuilder () {
	# undefined
	builtin autoload -XUz
}
_pdf () {
	# undefined
	builtin autoload -XUz
}
_pdftk () {
	# undefined
	builtin autoload -XUz
}
_perforce () {
	# undefined
	builtin autoload -XUz
}
_perl () {
	# undefined
	builtin autoload -XUz
}
_perl_basepods () {
	# undefined
	builtin autoload -XUz
}
_perl_modules () {
	# undefined
	builtin autoload -XUz
}
_perldoc () {
	# undefined
	builtin autoload -XUz
}
_pfctl () {
	# undefined
	builtin autoload -XUz
}
_pfexec () {
	# undefined
	builtin autoload -XUz
}
_pgrep () {
	# undefined
	builtin autoload -XUz
}
_php () {
	# undefined
	builtin autoload -XUz
}
_physical_volumes () {
	# undefined
	builtin autoload -XUz
}
_pick_variant () {
	local output cmd pat
	local -a var
	local -A opts
	(( $+_cmd_variant )) || typeset -gA _cmd_variant
	zparseopts -D -A opts b: c: r:
	: ${opts[-c]:=$words[1]}
	while [[ $1 = *=* ]]
	do
		var+=("${1%%\=*}" "${1#*=}") 
		shift
	done
	if (( $+_cmd_variant[$opts[-c]] ))
	then
		(( $+opts[-r] )) && eval "${opts[-r]}=${_cmd_variant[$opts[-c]]}"
		[[ $_cmd_variant[$opts[-c]] = "$1" ]] && return 1
		return 0
	fi
	if [[ $+opts[-b] -eq 1 && -n $builtins[$opts[-c]] ]]
	then
		_cmd_variant[$opts[-c]]=$opts[-b] 
		(( $+opts[-r] )) && eval "${opts[-r]}=${_cmd_variant[$opts[-c]]}"
		return 0
	fi
	output="$(_call_program variant $opts[-c] "${@[2,-1]}" </dev/null 2>&1)" 
	for cmd pat in "$var[@]"
	do
		if [[ $output = *$~pat* ]]
		then
			(( $+opts[-r] )) && eval "${opts[-r]}=$cmd"
			_cmd_variant[$opts[-c]]="$cmd" 
			return 0
		fi
	done
	(( $+opts[-r] )) && eval "${opts[-r]}=$1"
	_cmd_variant[$opts[-c]]="$1" 
	return 1
}
_picocom () {
	# undefined
	builtin autoload -XUz
}
_pidof () {
	# undefined
	builtin autoload -XUz
}
_pids () {
	# undefined
	builtin autoload -XUz
}
_pine () {
	# undefined
	builtin autoload -XUz
}
_ping () {
	# undefined
	builtin autoload -XUz
}
_piuparts () {
	# undefined
	builtin autoload -XUz
}
_pkg-config () {
	# undefined
	builtin autoload -XUz
}
_pkg5 () {
	# undefined
	builtin autoload -XUz
}
_pkg_instance () {
	# undefined
	builtin autoload -XUz
}
_pkgadd () {
	# undefined
	builtin autoload -XUz
}
_pkginfo () {
	# undefined
	builtin autoload -XUz
}
_pkgrm () {
	# undefined
	builtin autoload -XUz
}
_pkgtool () {
	# undefined
	builtin autoload -XUz
}
_plutil () {
	# undefined
	builtin autoload -XUz
}
_pon () {
	# undefined
	builtin autoload -XUz
}
_portaudit () {
	# undefined
	builtin autoload -XUz
}
_portlint () {
	# undefined
	builtin autoload -XUz
}
_portmaster () {
	# undefined
	builtin autoload -XUz
}
_ports () {
	# undefined
	builtin autoload -XUz
}
_portsnap () {
	# undefined
	builtin autoload -XUz
}
_postfix () {
	# undefined
	builtin autoload -XUz
}
_postscript () {
	# undefined
	builtin autoload -XUz
}
_powerd () {
	# undefined
	builtin autoload -XUz
}
_prcs () {
	# undefined
	builtin autoload -XUz
}
_precommand () {
	# undefined
	builtin autoload -XUz
}
_prefix () {
	# undefined
	builtin autoload -XUz
}
_print () {
	# undefined
	builtin autoload -XUz
}
_printenv () {
	# undefined
	builtin autoload -XUz
}
_printers () {
	# undefined
	builtin autoload -XUz
}
_process_names () {
	# undefined
	builtin autoload -XUz
}
_procstat () {
	# undefined
	builtin autoload -XUz
}
_prompt () {
	# undefined
	builtin autoload -XUz
}
_prove () {
	# undefined
	builtin autoload -XUz
}
_prstat () {
	# undefined
	builtin autoload -XUz
}
_ps () {
	# undefined
	builtin autoload -XUz
}
_ps1234 () {
	# undefined
	builtin autoload -XUz
}
_pscp () {
	# undefined
	builtin autoload -XUz
}
_pspdf () {
	# undefined
	builtin autoload -XUz
}
_psutils () {
	# undefined
	builtin autoload -XUz
}
_ptree () {
	# undefined
	builtin autoload -XUz
}
_pump () {
	# undefined
	builtin autoload -XUz
}
_putclip () {
	# undefined
	builtin autoload -XUz
}
_pwgen () {
	# undefined
	builtin autoload -XUz
}
_pydoc () {
	# undefined
	builtin autoload -XUz
}
_python () {
	# undefined
	builtin autoload -XUz
}
_python_modules () {
	# undefined
	builtin autoload -XUz
}
_qdbus () {
	# undefined
	builtin autoload -XUz
}
_qemu () {
	# undefined
	builtin autoload -XUz
}
_qiv () {
	# undefined
	builtin autoload -XUz
}
_qtplay () {
	# undefined
	builtin autoload -XUz
}
_quilt () {
	# undefined
	builtin autoload -XUz
}
_raggle () {
	# undefined
	builtin autoload -XUz
}
_rake () {
	# undefined
	builtin autoload -XUz
}
_ranlib () {
	# undefined
	builtin autoload -XUz
}
_rar () {
	# undefined
	builtin autoload -XUz
}
_rbenv () {
	local words completions
	read -cA words
	if [ "${#words}" -eq 2 ]
	then
		completions="$(rbenv commands)" 
	else
		completions="$(rbenv completions ${words[2,-2]})" 
	fi
	reply=("${(ps:\n:)completions}") 
}
_rcctl () {
	# undefined
	builtin autoload -XUz
}
_rcs () {
	# undefined
	builtin autoload -XUz
}
_rdesktop () {
	# undefined
	builtin autoload -XUz
}
_read () {
	# undefined
	builtin autoload -XUz
}
_read_comp () {
	# undefined
	builtin autoload -XUz
}
_readelf () {
	# undefined
	builtin autoload -XUz
}
_readlink () {
	# undefined
	builtin autoload -XUz
}
_readshortcut () {
	# undefined
	builtin autoload -XUz
}
_rebootin () {
	# undefined
	builtin autoload -XUz
}
_redirect () {
	# undefined
	builtin autoload -XUz
}
_regex_arguments () {
	# undefined
	builtin autoload -XUz
}
_regex_words () {
	# undefined
	builtin autoload -XUz
}
_remote_files () {
	# undefined
	builtin autoload -XUz
}
_renice () {
	# undefined
	builtin autoload -XUz
}
_reprepro () {
	# undefined
	builtin autoload -XUz
}
_requested () {
	local __gopt
	__gopt=() 
	zparseopts -D -a __gopt 1 2 V J x
	if comptags -R "$1"
	then
		if [[ $# -gt 3 ]]
		then
			_all_labels - "$__gopt[@]" "$@" || return 1
		elif [[ $# -gt 1 ]]
		then
			_description "$__gopt[@]" "$@"
		fi
		return 0
	else
		return 1
	fi
}
_retrieve_cache () {
	# undefined
	builtin autoload -XUz
}
_retrieve_mac_apps () {
	# undefined
	builtin autoload -XUz
}
_ri () {
	# undefined
	builtin autoload -XUz
}
_rlogin () {
	# undefined
	builtin autoload -XUz
}
_rm () {
	# undefined
	builtin autoload -XUz
}
_rmdir () {
	# undefined
	builtin autoload -XUz
}
_route () {
	# undefined
	builtin autoload -XUz
}
_rpm () {
	# undefined
	builtin autoload -XUz
}
_rpmbuild () {
	# undefined
	builtin autoload -XUz
}
_rrdtool () {
	# undefined
	builtin autoload -XUz
}
_rsync () {
	# undefined
	builtin autoload -XUz
}
_rubber () {
	# undefined
	builtin autoload -XUz
}
_ruby () {
	# undefined
	builtin autoload -XUz
}
_ruby_version () {
	if {
			echo $fpath | grep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn} -q "plugins/rvm"
		}
	then
		echo "%{$fg[grey]%}$(rvm_prompt_info)%{$reset_color%}"
	elif {
			echo $fpath | grep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn} -q "plugins/rbenv"
		}
	then
		echo "%{$fg[grey]%}$(rbenv_prompt_info)%{$reset_color%}"
	fi
}
_run-help () {
	# undefined
	builtin autoload -XUz
}
_runit () {
	# undefined
	builtin autoload -XUz
}
_sablotron () {
	# undefined
	builtin autoload -XUz
}
_samba () {
	# undefined
	builtin autoload -XUz
}
_savecore () {
	# undefined
	builtin autoload -XUz
}
_say () {
	# undefined
	builtin autoload -XUz
}
_sc_usage () {
	# undefined
	builtin autoload -XUz
}
_sccs () {
	# undefined
	builtin autoload -XUz
}
_sched () {
	# undefined
	builtin autoload -XUz
}
_schedtool () {
	# undefined
	builtin autoload -XUz
}
_schroot () {
	# undefined
	builtin autoload -XUz
}
_scl () {
	# undefined
	builtin autoload -XUz
}
_scons () {
	# undefined
	builtin autoload -XUz
}
_screen () {
	# undefined
	builtin autoload -XUz
}
_script () {
	# undefined
	builtin autoload -XUz
}
_scselect () {
	# undefined
	builtin autoload -XUz
}
_scutil () {
	# undefined
	builtin autoload -XUz
}
_sed () {
	# undefined
	builtin autoload -XUz
}
_sep_parts () {
	# undefined
	builtin autoload -XUz
}
_seq () {
	# undefined
	builtin autoload -XUz
}
_sequence () {
	# undefined
	builtin autoload -XUz
}
_service () {
	# undefined
	builtin autoload -XUz
}
_services () {
	# undefined
	builtin autoload -XUz
}
_set () {
	# undefined
	builtin autoload -XUz
}
_set_command () {
	local command
	command="$words[1]" 
	[[ -z "$command" ]] && return
	if (( $+builtins[$command] + $+functions[$command] ))
	then
		_comp_command1="$command" 
		_comp_command="$_comp_command1" 
	elif [[ "$command[1]" = '=' ]]
	then
		eval _comp_command2\=$command
		_comp_command1="$command[2,-1]" 
		_comp_command="$_comp_command2" 
	elif [[ "$command" = ..#/* ]]
	then
		_comp_command1="${PWD}/$command" 
		_comp_command2="${command:t}" 
		_comp_command="$_comp_command2" 
	elif [[ "$command" = */* ]]
	then
		_comp_command1="$command" 
		_comp_command2="${command:t}" 
		_comp_command="$_comp_command2" 
	else
		_comp_command1="$command" 
		_comp_command2="$commands[$command]" 
		_comp_command="$_comp_command1" 
	fi
}
_setfacl () {
	# undefined
	builtin autoload -XUz
}
_setopt () {
	# undefined
	builtin autoload -XUz
}
_setsid () {
	# undefined
	builtin autoload -XUz
}
_setup () {
	local val nm="$compstate[nmatches]" 
	[[ $# -eq 1 ]] && 2="$1" 
	if zstyle -a ":completion:${curcontext}:$1" list-colors val
	then
		zmodload -i zsh/complist
		if [[ "$1" = default ]]
		then
			_comp_colors=("$val[@]") 
		else
			_comp_colors+=("(${2})${(@)^val:#(|\(*\)*)}" "${(M@)val:#\(*\)*}") 
		fi
	elif [[ "$1" = default ]]
	then
		unset ZLS_COLORS ZLS_COLOURS
	fi
	if zstyle -s ":completion:${curcontext}:$1" show-ambiguity val
	then
		zmodload -i zsh/complist
		[[ $val = (yes|true|on) ]] && _ambiguous_color=4  || _ambiguous_color=$val 
	fi
	if zstyle -t ":completion:${curcontext}:$1" list-packed
	then
		compstate[list]="${compstate[list]} packed" 
	elif [[ $? -eq 1 ]]
	then
		compstate[list]="${compstate[list]:gs/packed//}" 
	else
		compstate[list]="$_saved_list" 
	fi
	if zstyle -t ":completion:${curcontext}:$1" list-rows-first
	then
		compstate[list]="${compstate[list]} rows" 
	elif [[ $? -eq 1 ]]
	then
		compstate[list]="${compstate[list]:gs/rows//}" 
	else
		compstate[list]="$_saved_list" 
	fi
	if zstyle -t ":completion:${curcontext}:$1" last-prompt
	then
		compstate[last_prompt]=yes 
	elif [[ $? -eq 1 ]]
	then
		compstate[last_prompt]='' 
	else
		compstate[last_prompt]="$_saved_lastprompt" 
	fi
	if zstyle -t ":completion:${curcontext}:$1" accept-exact
	then
		compstate[exact]=accept 
	elif [[ $? -eq 1 ]]
	then
		compstate[exact]='' 
	else
		compstate[exact]="$_saved_exact" 
	fi
	[[ _last_nmatches -ge 0 && _last_nmatches -ne nm ]] && _menu_style=("$_last_menu_style[@]" "$_menu_style[@]") 
	if zstyle -a ":completion:${curcontext}:$1" menu val
	then
		_last_nmatches=$nm 
		_last_menu_style=("$val[@]") 
	else
		_last_nmatches=-1 
	fi
	[[ "$_comp_force_list" != always ]] && zstyle -s ":completion:${curcontext}:$1" force-list val && [[ "$val" = always || ( "$val" = [0-9]## && ( -z "$_comp_force_list" || _comp_force_list -gt val ) ) ]] && _comp_force_list="$val" 
}
_setxkbmap () {
	# undefined
	builtin autoload -XUz
}
_sh () {
	# undefined
	builtin autoload -XUz
}
_shasum () {
	# undefined
	builtin autoload -XUz
}
_showmount () {
	# undefined
	builtin autoload -XUz
}
_shred () {
	# undefined
	builtin autoload -XUz
}
_shuf () {
	# undefined
	builtin autoload -XUz
}
_shutdown () {
	# undefined
	builtin autoload -XUz
}
_signals () {
	# undefined
	builtin autoload -XUz
}
_signify () {
	# undefined
	builtin autoload -XUz
}
_sisu () {
	# undefined
	builtin autoload -XUz
}
_slrn () {
	# undefined
	builtin autoload -XUz
}
_smartmontools () {
	# undefined
	builtin autoload -XUz
}
_smit () {
	# undefined
	builtin autoload -XUz
}
_snoop () {
	# undefined
	builtin autoload -XUz
}
_socket () {
	# undefined
	builtin autoload -XUz
}
_sockstat () {
	# undefined
	builtin autoload -XUz
}
_softwareupdate () {
	# undefined
	builtin autoload -XUz
}
_sort () {
	# undefined
	builtin autoload -XUz
}
_source () {
	# undefined
	builtin autoload -XUz
}
_spamassassin () {
	# undefined
	builtin autoload -XUz
}
_split () {
	# undefined
	builtin autoload -XUz
}
_sqlite () {
	# undefined
	builtin autoload -XUz
}
_sqsh () {
	# undefined
	builtin autoload -XUz
}
_ss () {
	# undefined
	builtin autoload -XUz
}
_ssh () {
	# undefined
	builtin autoload -XUz
}
_ssh_hosts () {
	# undefined
	builtin autoload -XUz
}
_sshfs () {
	# undefined
	builtin autoload -XUz
}
_stat () {
	# undefined
	builtin autoload -XUz
}
_stdbuf () {
	# undefined
	builtin autoload -XUz
}
_stgit () {
	# undefined
	builtin autoload -XUz
}
_store_cache () {
	# undefined
	builtin autoload -XUz
}
_strace () {
	# undefined
	builtin autoload -XUz
}
_strftime () {
	# undefined
	builtin autoload -XUz
}
_strings () {
	# undefined
	builtin autoload -XUz
}
_strip () {
	# undefined
	builtin autoload -XUz
}
_stty () {
	# undefined
	builtin autoload -XUz
}
_su () {
	# undefined
	builtin autoload -XUz
}
_sub_commands () {
	# undefined
	builtin autoload -XUz
}
_sublimetext () {
	# undefined
	builtin autoload -XUz
}
_subscript () {
	# undefined
	builtin autoload -XUz
}
_subversion () {
	# undefined
	builtin autoload -XUz
}
_sudo () {
	# undefined
	builtin autoload -XUz
}
_suffix_alias_files () {
	# undefined
	builtin autoload -XUz
}
_surfraw () {
	# undefined
	builtin autoload -XUz
}
_svcadm () {
	# undefined
	builtin autoload -XUz
}
_svccfg () {
	# undefined
	builtin autoload -XUz
}
_svcprop () {
	# undefined
	builtin autoload -XUz
}
_svcs () {
	# undefined
	builtin autoload -XUz
}
_svcs_fmri () {
	# undefined
	builtin autoload -XUz
}
_svn-buildpackage () {
	# undefined
	builtin autoload -XUz
}
_sw_vers () {
	# undefined
	builtin autoload -XUz
}
_swaks () {
	# undefined
	builtin autoload -XUz
}
_swanctl () {
	# undefined
	builtin autoload -XUz
}
_swift () {
	# undefined
	builtin autoload -XUz
}
_sys_calls () {
	# undefined
	builtin autoload -XUz
}
_sysctl () {
	# undefined
	builtin autoload -XUz
}
_sysrc () {
	# undefined
	builtin autoload -XUz
}
_sysstat () {
	# undefined
	builtin autoload -XUz
}
_systat () {
	# undefined
	builtin autoload -XUz
}
_system_profiler () {
	# undefined
	builtin autoload -XUz
}
_tac () {
	# undefined
	builtin autoload -XUz
}
_tags () {
	local prev
	if [[ "$1" = -- ]]
	then
		prev=- 
		shift
	fi
	if (( $# ))
	then
		local curcontext="$curcontext" order tag nodef tmp 
		if [[ "$1" = -C?* ]]
		then
			curcontext="${curcontext%:*}:${1[3,-1]}" 
			shift
		elif [[ "$1" = -C ]]
		then
			curcontext="${curcontext%:*}:${2}" 
			shift 2
		fi
		[[ "$1" = -(|-) ]] && shift
		zstyle -a ":completion:${curcontext}:" group-order order && compgroups "$order[@]"
		comptags "-i$prev" "$curcontext" "$@"
		if [[ -n "$_sort_tags" ]]
		then
			"$_sort_tags" "$@"
		else
			zstyle -a ":completion:${curcontext}:" tag-order order || (( ! ${@[(I)options]} )) || order=('(|*-)argument-* (|*-)option[-+]* values' options) 
			for tag in $order
			do
				case $tag in
					(-) nodef=yes  ;;
					(\!*) comptry "${(@)argv:#(${(j:|:)~${=~tag[2,-1]}})}" ;;
					(?*) comptry -m "$tag" ;;
				esac
			done
			[[ -z "$nodef" ]] && comptry "$@"
		fi
		comptags "-T$prev"
		return
	fi
	comptags "-N$prev"
}
_tail () {
	# undefined
	builtin autoload -XUz
}
_tar () {
	# undefined
	builtin autoload -XUz
}
_tar_archive () {
	# undefined
	builtin autoload -XUz
}
_tardy () {
	# undefined
	builtin autoload -XUz
}
_tcpdump () {
	# undefined
	builtin autoload -XUz
}
_tcpsys () {
	# undefined
	builtin autoload -XUz
}
_tcptraceroute () {
	# undefined
	builtin autoload -XUz
}
_tee () {
	# undefined
	builtin autoload -XUz
}
_telnet () {
	# undefined
	builtin autoload -XUz
}
_terminals () {
	# undefined
	builtin autoload -XUz
}
_tex () {
	# undefined
	builtin autoload -XUz
}
_texi () {
	# undefined
	builtin autoload -XUz
}
_texinfo () {
	# undefined
	builtin autoload -XUz
}
_tidy () {
	# undefined
	builtin autoload -XUz
}
_tiff () {
	# undefined
	builtin autoload -XUz
}
_tilde () {
	# undefined
	builtin autoload -XUz
}
_tilde_files () {
	# undefined
	builtin autoload -XUz
}
_time_zone () {
	# undefined
	builtin autoload -XUz
}
_timeout () {
	# undefined
	builtin autoload -XUz
}
_tin () {
	# undefined
	builtin autoload -XUz
}
_tla () {
	# undefined
	builtin autoload -XUz
}
_tmux () {
	# undefined
	builtin autoload -XUz
}
_todo.sh () {
	# undefined
	builtin autoload -XUz
}
_toilet () {
	# undefined
	builtin autoload -XUz
}
_toolchain-source () {
	# undefined
	builtin autoload -XUz
}
_top () {
	# undefined
	builtin autoload -XUz
}
_topgit () {
	# undefined
	builtin autoload -XUz
}
_totd () {
	# undefined
	builtin autoload -XUz
}
_touch () {
	# undefined
	builtin autoload -XUz
}
_tpb () {
	# undefined
	builtin autoload -XUz
}
_tpconfig () {
	# undefined
	builtin autoload -XUz
}
_tput () {
	# undefined
	builtin autoload -XUz
}
_tr () {
	# undefined
	builtin autoload -XUz
}
_tracepath () {
	# undefined
	builtin autoload -XUz
}
_trap () {
	# undefined
	builtin autoload -XUz
}
_tree () {
	# undefined
	builtin autoload -XUz
}
_truss () {
	# undefined
	builtin autoload -XUz
}
_tty () {
	# undefined
	builtin autoload -XUz
}
_ttyctl () {
	# undefined
	builtin autoload -XUz
}
_ttys () {
	# undefined
	builtin autoload -XUz
}
_tune2fs () {
	# undefined
	builtin autoload -XUz
}
_twidge () {
	# undefined
	builtin autoload -XUz
}
_twisted () {
	# undefined
	builtin autoload -XUz
}
_typeset () {
	# undefined
	builtin autoload -XUz
}
_ulimit () {
	# undefined
	builtin autoload -XUz
}
_uml () {
	# undefined
	builtin autoload -XUz
}
_umountable () {
	# undefined
	builtin autoload -XUz
}
_unace () {
	# undefined
	builtin autoload -XUz
}
_uname () {
	# undefined
	builtin autoload -XUz
}
_unexpand () {
	# undefined
	builtin autoload -XUz
}
_unhash () {
	# undefined
	builtin autoload -XUz
}
_uniq () {
	# undefined
	builtin autoload -XUz
}
_unison () {
	# undefined
	builtin autoload -XUz
}
_units () {
	# undefined
	builtin autoload -XUz
}
_update-alternatives () {
	# undefined
	builtin autoload -XUz
}
_update-rc.d () {
	# undefined
	builtin autoload -XUz
}
_uptime () {
	# undefined
	builtin autoload -XUz
}
_urls () {
	# undefined
	builtin autoload -XUz
}
_urpmi () {
	# undefined
	builtin autoload -XUz
}
_urxvt () {
	# undefined
	builtin autoload -XUz
}
_uscan () {
	# undefined
	builtin autoload -XUz
}
_user_admin () {
	# undefined
	builtin autoload -XUz
}
_user_at_host () {
	# undefined
	builtin autoload -XUz
}
_user_expand () {
	# undefined
	builtin autoload -XUz
}
_user_host () {
	if [[ -n $SSH_CONNECTION ]]
	then
		me="%n@%m" 
	elif [[ $LOGNAME != $USER ]]
	then
		me="%n" 
	fi
	if [[ -n $me ]]
	then
		echo "%{$fg[cyan]%}$me%{$reset_color%}:"
	fi
}
_user_math_func () {
	# undefined
	builtin autoload -XUz
}
_users () {
	# undefined
	builtin autoload -XUz
}
_users_on () {
	# undefined
	builtin autoload -XUz
}
_uzbl () {
	# undefined
	builtin autoload -XUz
}
_valgrind () {
	# undefined
	builtin autoload -XUz
}
_value () {
	# undefined
	builtin autoload -XUz
}
_values () {
	# undefined
	builtin autoload -XUz
}
_vared () {
	# undefined
	builtin autoload -XUz
}
_vars () {
	# undefined
	builtin autoload -XUz
}
_vcsh () {
	# undefined
	builtin autoload -XUz
}
_vi_status () {
	if {
			echo $fpath | grep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn} -q "plugins/vi-mode"
		}
	then
		echo "$(vi_mode_prompt_info)"
	fi
}
_vim () {
	# undefined
	builtin autoload -XUz
}
_vim-addons () {
	# undefined
	builtin autoload -XUz
}
_visudo () {
	# undefined
	builtin autoload -XUz
}
_vmctl () {
	# undefined
	builtin autoload -XUz
}
_vmstat () {
	# undefined
	builtin autoload -XUz
}
_vnc () {
	# undefined
	builtin autoload -XUz
}
_volume_groups () {
	# undefined
	builtin autoload -XUz
}
_vorbis () {
	# undefined
	builtin autoload -XUz
}
_vpnc () {
	# undefined
	builtin autoload -XUz
}
_vserver () {
	# undefined
	builtin autoload -XUz
}
_vux () {
	# undefined
	builtin autoload -XUz
}
_w () {
	# undefined
	builtin autoload -XUz
}
_w3m () {
	# undefined
	builtin autoload -XUz
}
_wait () {
	# undefined
	builtin autoload -XUz
}
_wajig () {
	# undefined
	builtin autoload -XUz
}
_wakeup_capable_devices () {
	# undefined
	builtin autoload -XUz
}
_wanna-build () {
	# undefined
	builtin autoload -XUz
}
_wanted () {
	local -a __targs __gopt
	zparseopts -D -a __gopt 1 2 V J x C:=__targs
	_tags "$__targs[@]" "$1"
	while _tags
	do
		_all_labels "$__gopt[@]" "$@" && return 0
	done
	return 1
}
_watch () {
	# undefined
	builtin autoload -XUz
}
_watch-snoop () {
	# undefined
	builtin autoload -XUz
}
_wc () {
	# undefined
	builtin autoload -XUz
}
_webbrowser () {
	# undefined
	builtin autoload -XUz
}
_wget () {
	# undefined
	builtin autoload -XUz
}
_whereis () {
	# undefined
	builtin autoload -XUz
}
_which () {
	# undefined
	builtin autoload -XUz
}
_who () {
	# undefined
	builtin autoload -XUz
}
_whois () {
	# undefined
	builtin autoload -XUz
}
_widgets () {
	# undefined
	builtin autoload -XUz
}
_wiggle () {
	# undefined
	builtin autoload -XUz
}
_wipefs () {
	# undefined
	builtin autoload -XUz
}
_wpa_cli () {
	# undefined
	builtin autoload -XUz
}
_x_arguments () {
	# undefined
	builtin autoload -XUz
}
_x_borderwidth () {
	# undefined
	builtin autoload -XUz
}
_x_color () {
	# undefined
	builtin autoload -XUz
}
_x_colormapid () {
	# undefined
	builtin autoload -XUz
}
_x_cursor () {
	# undefined
	builtin autoload -XUz
}
_x_display () {
	# undefined
	builtin autoload -XUz
}
_x_extension () {
	# undefined
	builtin autoload -XUz
}
_x_font () {
	# undefined
	builtin autoload -XUz
}
_x_geometry () {
	# undefined
	builtin autoload -XUz
}
_x_keysym () {
	# undefined
	builtin autoload -XUz
}
_x_locale () {
	# undefined
	builtin autoload -XUz
}
_x_modifier () {
	# undefined
	builtin autoload -XUz
}
_x_name () {
	# undefined
	builtin autoload -XUz
}
_x_resource () {
	# undefined
	builtin autoload -XUz
}
_x_selection_timeout () {
	# undefined
	builtin autoload -XUz
}
_x_title () {
	# undefined
	builtin autoload -XUz
}
_x_utils () {
	# undefined
	builtin autoload -XUz
}
_x_visual () {
	# undefined
	builtin autoload -XUz
}
_x_window () {
	# undefined
	builtin autoload -XUz
}
_xargs () {
	# undefined
	builtin autoload -XUz
}
_xauth () {
	# undefined
	builtin autoload -XUz
}
_xautolock () {
	# undefined
	builtin autoload -XUz
}
_xclip () {
	# undefined
	builtin autoload -XUz
}
_xcode-select () {
	# undefined
	builtin autoload -XUz
}
_xdvi () {
	# undefined
	builtin autoload -XUz
}
_xfig () {
	# undefined
	builtin autoload -XUz
}
_xft_fonts () {
	# undefined
	builtin autoload -XUz
}
_xloadimage () {
	# undefined
	builtin autoload -XUz
}
_xmlsoft () {
	# undefined
	builtin autoload -XUz
}
_xmlstarlet () {
	# undefined
	builtin autoload -XUz
}
_xmms2 () {
	# undefined
	builtin autoload -XUz
}
_xmodmap () {
	# undefined
	builtin autoload -XUz
}
_xournal () {
	# undefined
	builtin autoload -XUz
}
_xpdf () {
	# undefined
	builtin autoload -XUz
}
_xrandr () {
	# undefined
	builtin autoload -XUz
}
_xscreensaver () {
	# undefined
	builtin autoload -XUz
}
_xset () {
	# undefined
	builtin autoload -XUz
}
_xt_arguments () {
	# undefined
	builtin autoload -XUz
}
_xt_session_id () {
	# undefined
	builtin autoload -XUz
}
_xterm () {
	# undefined
	builtin autoload -XUz
}
_xv () {
	# undefined
	builtin autoload -XUz
}
_xwit () {
	# undefined
	builtin autoload -XUz
}
_xxd () {
	# undefined
	builtin autoload -XUz
}
_xz () {
	# undefined
	builtin autoload -XUz
}
_yafc () {
	# undefined
	builtin autoload -XUz
}
_yast () {
	# undefined
	builtin autoload -XUz
}
_yodl () {
	# undefined
	builtin autoload -XUz
}
_yp () {
	# undefined
	builtin autoload -XUz
}
_yum () {
	# undefined
	builtin autoload -XUz
}
_zargs () {
	# undefined
	builtin autoload -XUz
}
_zathura () {
	# undefined
	builtin autoload -XUz
}
_zattr () {
	# undefined
	builtin autoload -XUz
}
_zcalc () {
	# undefined
	builtin autoload -XUz
}
_zcalc_line () {
	# undefined
	builtin autoload -XUz
}
_zcat () {
	# undefined
	builtin autoload -XUz
}
_zcompile () {
	# undefined
	builtin autoload -XUz
}
_zdump () {
	# undefined
	builtin autoload -XUz
}
_zeal () {
	# undefined
	builtin autoload -XUz
}
_zed () {
	# undefined
	builtin autoload -XUz
}
_zfs () {
	# undefined
	builtin autoload -XUz
}
_zfs_dataset () {
	# undefined
	builtin autoload -XUz
}
_zfs_keysource_props () {
	# undefined
	builtin autoload -XUz
}
_zfs_pool () {
	# undefined
	builtin autoload -XUz
}
_zftp () {
	# undefined
	builtin autoload -XUz
}
_zip () {
	# undefined
	builtin autoload -XUz
}
_zle () {
	# undefined
	builtin autoload -XUz
}
_zlogin () {
	# undefined
	builtin autoload -XUz
}
_zmodload () {
	# undefined
	builtin autoload -XUz
}
_zmv () {
	# undefined
	builtin autoload -XUz
}
_zoneadm () {
	# undefined
	builtin autoload -XUz
}
_zones () {
	# undefined
	builtin autoload -XUz
}
_zpool () {
	# undefined
	builtin autoload -XUz
}
_zpty () {
	# undefined
	builtin autoload -XUz
}
_zsh () {
	# undefined
	builtin autoload -XUz
}
_zsh-mime-handler () {
	# undefined
	builtin autoload -XUz
}
_zsh_autosuggest_accept () {
	local -i max_cursor_pos=$#BUFFER 
	if [[ "$KEYMAP" = "vicmd" ]]
	then
		max_cursor_pos=$((max_cursor_pos - 1)) 
	fi
	if [[ $CURSOR = $max_cursor_pos ]]
	then
		BUFFER="$BUFFER$POSTDISPLAY" 
		unset POSTDISPLAY
		if [[ "$KEYMAP" = "vicmd" ]]
		then
			CURSOR=$(($#BUFFER - 1)) 
		else
			CURSOR=$#BUFFER 
		fi
	fi
	_zsh_autosuggest_invoke_original_widget $@
}
_zsh_autosuggest_async_request () {
	zmodload zsh/system 2> /dev/null
	typeset -g _ZSH_AUTOSUGGEST_ASYNC_FD _ZSH_AUTOSUGGEST_CHILD_PID
	if [[ -n "$_ZSH_AUTOSUGGEST_ASYNC_FD" ]] && {
			true <&$_ZSH_AUTOSUGGEST_ASYNC_FD
		} 2> /dev/null
	then
		exec {_ZSH_AUTOSUGGEST_ASYNC_FD}<&-
		zle -F $_ZSH_AUTOSUGGEST_ASYNC_FD
		if [[ -n "$_ZSH_AUTOSUGGEST_CHILD_PID" ]]
		then
			if [[ -o MONITOR ]]
			then
				kill -TERM -$_ZSH_AUTOSUGGEST_CHILD_PID 2> /dev/null
			else
				kill -TERM $_ZSH_AUTOSUGGEST_CHILD_PID 2> /dev/null
			fi
		fi
	fi
	exec {_ZSH_AUTOSUGGEST_ASYNC_FD}< <(
		# Tell parent process our pid
		echo $sysparams[pid]

		# Fetch and print the suggestion
		local suggestion
		_zsh_autosuggest_fetch_suggestion "$1"
		echo -nE "$suggestion"
	)
	command true
	read _ZSH_AUTOSUGGEST_CHILD_PID <&$_ZSH_AUTOSUGGEST_ASYNC_FD
	zle -F "$_ZSH_AUTOSUGGEST_ASYNC_FD" _zsh_autosuggest_async_response
}
_zsh_autosuggest_async_response () {
	emulate -L zsh
	local suggestion
	if [[ -z "$2" || "$2" == "hup" ]]
	then
		IFS='' read -rd '' -u $1 suggestion
		zle autosuggest-suggest -- "$suggestion"
		exec {1}<&-
	fi
	zle -F "$1"
}
_zsh_autosuggest_bind_widget () {
	typeset -gA _ZSH_AUTOSUGGEST_BIND_COUNTS
	local widget=$1 
	local autosuggest_action=$2 
	local prefix=$ZSH_AUTOSUGGEST_ORIGINAL_WIDGET_PREFIX 
	local -i bind_count
	case $widgets[$widget] in
		(user:_zsh_autosuggest_(bound|orig)_*) bind_count=$((_ZSH_AUTOSUGGEST_BIND_COUNTS[$widget]))  ;;
		(user:*) _zsh_autosuggest_incr_bind_count $widget
			zle -N $prefix$bind_count-$widget ${widgets[$widget]#*:} ;;
		(builtin) _zsh_autosuggest_incr_bind_count $widget
			eval "_zsh_autosuggest_orig_${(q)widget}() { zle .${(q)widget} }"
			zle -N $prefix$bind_count-$widget _zsh_autosuggest_orig_$widget ;;
		(completion:*) _zsh_autosuggest_incr_bind_count $widget
			eval "zle -C $prefix$bind_count-${(q)widget} ${${(s.:.)widgets[$widget]}[2,3]}" ;;
	esac
	eval "_zsh_autosuggest_bound_${bind_count}_${(q)widget}() {
		_zsh_autosuggest_widget_$autosuggest_action $prefix$bind_count-${(q)widget} \$@
	}"
	zle -N -- $widget _zsh_autosuggest_bound_${bind_count}_$widget
}
_zsh_autosuggest_bind_widgets () {
	emulate -L zsh
	local widget
	local ignore_widgets
	ignore_widgets=(.\* _\* autosuggest-\* $ZSH_AUTOSUGGEST_ORIGINAL_WIDGET_PREFIX\* $ZSH_AUTOSUGGEST_IGNORE_WIDGETS) 
	for widget in ${${(f)"$(builtin zle -la)"}:#${(j:|:)~ignore_widgets}}
	do
		if [[ -n ${ZSH_AUTOSUGGEST_CLEAR_WIDGETS[(r)$widget]} ]]
		then
			_zsh_autosuggest_bind_widget $widget clear
		elif [[ -n ${ZSH_AUTOSUGGEST_ACCEPT_WIDGETS[(r)$widget]} ]]
		then
			_zsh_autosuggest_bind_widget $widget accept
		elif [[ -n ${ZSH_AUTOSUGGEST_EXECUTE_WIDGETS[(r)$widget]} ]]
		then
			_zsh_autosuggest_bind_widget $widget execute
		elif [[ -n ${ZSH_AUTOSUGGEST_PARTIAL_ACCEPT_WIDGETS[(r)$widget]} ]]
		then
			_zsh_autosuggest_bind_widget $widget partial_accept
		else
			_zsh_autosuggest_bind_widget $widget modify
		fi
	done
}
_zsh_autosuggest_bound_1_accept-and-hold () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-accept-and-hold $@
}
_zsh_autosuggest_bound_1_accept-and-infer-next-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-accept-and-infer-next-history $@
}
_zsh_autosuggest_bound_1_accept-and-menu-complete () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-accept-and-menu-complete $@
}
_zsh_autosuggest_bound_1_accept-line () {
	_zsh_autosuggest_widget_clear autosuggest-orig-1-accept-line $@
}
_zsh_autosuggest_bound_1_accept-line-and-down-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-accept-line-and-down-history $@
}
_zsh_autosuggest_bound_1_accept-search () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-accept-search $@
}
_zsh_autosuggest_bound_1_argument-base () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-argument-base $@
}
_zsh_autosuggest_bound_1_auto-suffix-remove () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-auto-suffix-remove $@
}
_zsh_autosuggest_bound_1_auto-suffix-retain () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-auto-suffix-retain $@
}
_zsh_autosuggest_bound_1_backward-char () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-backward-char $@
}
_zsh_autosuggest_bound_1_backward-delete-char () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-backward-delete-char $@
}
_zsh_autosuggest_bound_1_backward-delete-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-backward-delete-word $@
}
_zsh_autosuggest_bound_1_backward-kill-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-backward-kill-line $@
}
_zsh_autosuggest_bound_1_backward-kill-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-backward-kill-word $@
}
_zsh_autosuggest_bound_1_backward-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-backward-word $@
}
_zsh_autosuggest_bound_1_beginning-of-buffer-or-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-beginning-of-buffer-or-history $@
}
_zsh_autosuggest_bound_1_beginning-of-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-beginning-of-history $@
}
_zsh_autosuggest_bound_1_beginning-of-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-beginning-of-line $@
}
_zsh_autosuggest_bound_1_beginning-of-line-hist () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-beginning-of-line-hist $@
}
_zsh_autosuggest_bound_1_bracketed-paste () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-bracketed-paste $@
}
_zsh_autosuggest_bound_1_capitalize-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-capitalize-word $@
}
_zsh_autosuggest_bound_1_clear-screen () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-clear-screen $@
}
_zsh_autosuggest_bound_1_complete-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-complete-word $@
}
_zsh_autosuggest_bound_1_copy-prev-shell-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-copy-prev-shell-word $@
}
_zsh_autosuggest_bound_1_copy-prev-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-copy-prev-word $@
}
_zsh_autosuggest_bound_1_copy-region-as-kill () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-copy-region-as-kill $@
}
_zsh_autosuggest_bound_1_deactivate-region () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-deactivate-region $@
}
_zsh_autosuggest_bound_1_delete-char () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-delete-char $@
}
_zsh_autosuggest_bound_1_delete-char-or-list () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-delete-char-or-list $@
}
_zsh_autosuggest_bound_1_delete-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-delete-word $@
}
_zsh_autosuggest_bound_1_describe-key-briefly () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-describe-key-briefly $@
}
_zsh_autosuggest_bound_1_digit-argument () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-digit-argument $@
}
_zsh_autosuggest_bound_1_down-case-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-down-case-word $@
}
_zsh_autosuggest_bound_1_down-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-down-history $@
}
_zsh_autosuggest_bound_1_down-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-down-line $@
}
_zsh_autosuggest_bound_1_down-line-or-beginning-search () {
	_zsh_autosuggest_widget_clear autosuggest-orig-1-down-line-or-beginning-search $@
}
_zsh_autosuggest_bound_1_down-line-or-history () {
	_zsh_autosuggest_widget_clear autosuggest-orig-1-down-line-or-history $@
}
_zsh_autosuggest_bound_1_down-line-or-search () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-down-line-or-search $@
}
_zsh_autosuggest_bound_1_edit-command-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-edit-command-line $@
}
_zsh_autosuggest_bound_1_emacs-backward-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-emacs-backward-word $@
}
_zsh_autosuggest_bound_1_emacs-forward-word () {
	_zsh_autosuggest_widget_partial_accept autosuggest-orig-1-emacs-forward-word $@
}
_zsh_autosuggest_bound_1_end-of-buffer-or-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-end-of-buffer-or-history $@
}
_zsh_autosuggest_bound_1_end-of-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-end-of-history $@
}
_zsh_autosuggest_bound_1_end-of-line () {
	_zsh_autosuggest_widget_accept autosuggest-orig-1-end-of-line $@
}
_zsh_autosuggest_bound_1_end-of-line-hist () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-end-of-line-hist $@
}
_zsh_autosuggest_bound_1_end-of-list () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-end-of-list $@
}
_zsh_autosuggest_bound_1_exchange-point-and-mark () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-exchange-point-and-mark $@
}
_zsh_autosuggest_bound_1_execute-last-named-cmd () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-execute-last-named-cmd $@
}
_zsh_autosuggest_bound_1_execute-named-cmd () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-execute-named-cmd $@
}
_zsh_autosuggest_bound_1_expand-cmd-path () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-expand-cmd-path $@
}
_zsh_autosuggest_bound_1_expand-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-expand-history $@
}
_zsh_autosuggest_bound_1_expand-or-complete () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-expand-or-complete $@
}
_zsh_autosuggest_bound_1_expand-or-complete-prefix () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-expand-or-complete-prefix $@
}
_zsh_autosuggest_bound_1_expand-or-complete-with-dots () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-expand-or-complete-with-dots $@
}
_zsh_autosuggest_bound_1_expand-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-expand-word $@
}
_zsh_autosuggest_bound_1_forward-char () {
	_zsh_autosuggest_widget_accept autosuggest-orig-1-forward-char $@
}
_zsh_autosuggest_bound_1_forward-word () {
	_zsh_autosuggest_widget_partial_accept autosuggest-orig-1-forward-word $@
}
_zsh_autosuggest_bound_1_get-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-get-line $@
}
_zsh_autosuggest_bound_1_gosmacs-transpose-chars () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-gosmacs-transpose-chars $@
}
_zsh_autosuggest_bound_1_history-beginning-search-backward () {
	_zsh_autosuggest_widget_clear autosuggest-orig-1-history-beginning-search-backward $@
}
_zsh_autosuggest_bound_1_history-beginning-search-forward () {
	_zsh_autosuggest_widget_clear autosuggest-orig-1-history-beginning-search-forward $@
}
_zsh_autosuggest_bound_1_history-incremental-pattern-search-backward () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-history-incremental-pattern-search-backward $@
}
_zsh_autosuggest_bound_1_history-incremental-pattern-search-forward () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-history-incremental-pattern-search-forward $@
}
_zsh_autosuggest_bound_1_history-incremental-search-backward () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-history-incremental-search-backward $@
}
_zsh_autosuggest_bound_1_history-incremental-search-forward () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-history-incremental-search-forward $@
}
_zsh_autosuggest_bound_1_history-search-backward () {
	_zsh_autosuggest_widget_clear autosuggest-orig-1-history-search-backward $@
}
_zsh_autosuggest_bound_1_history-search-forward () {
	_zsh_autosuggest_widget_clear autosuggest-orig-1-history-search-forward $@
}
_zsh_autosuggest_bound_1_history-substring-search-down () {
	_zsh_autosuggest_widget_clear autosuggest-orig-1-history-substring-search-down $@
}
_zsh_autosuggest_bound_1_history-substring-search-up () {
	_zsh_autosuggest_widget_clear autosuggest-orig-1-history-substring-search-up $@
}
_zsh_autosuggest_bound_1_infer-next-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-infer-next-history $@
}
_zsh_autosuggest_bound_1_insert-last-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-insert-last-word $@
}
_zsh_autosuggest_bound_1_kill-buffer () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-kill-buffer $@
}
_zsh_autosuggest_bound_1_kill-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-kill-line $@
}
_zsh_autosuggest_bound_1_kill-region () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-kill-region $@
}
_zsh_autosuggest_bound_1_kill-whole-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-kill-whole-line $@
}
_zsh_autosuggest_bound_1_kill-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-kill-word $@
}
_zsh_autosuggest_bound_1_list-choices () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-list-choices $@
}
_zsh_autosuggest_bound_1_list-expand () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-list-expand $@
}
_zsh_autosuggest_bound_1_magic-space () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-magic-space $@
}
_zsh_autosuggest_bound_1_menu-complete () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-menu-complete $@
}
_zsh_autosuggest_bound_1_menu-expand-or-complete () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-menu-expand-or-complete $@
}
_zsh_autosuggest_bound_1_menu-select () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-menu-select $@
}
_zsh_autosuggest_bound_1_neg-argument () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-neg-argument $@
}
_zsh_autosuggest_bound_1_overwrite-mode () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-overwrite-mode $@
}
_zsh_autosuggest_bound_1_pound-insert () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-pound-insert $@
}
_zsh_autosuggest_bound_1_push-input () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-push-input $@
}
_zsh_autosuggest_bound_1_push-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-push-line $@
}
_zsh_autosuggest_bound_1_push-line-or-edit () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-push-line-or-edit $@
}
_zsh_autosuggest_bound_1_put-replace-selection () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-put-replace-selection $@
}
_zsh_autosuggest_bound_1_quote-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-quote-line $@
}
_zsh_autosuggest_bound_1_quote-region () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-quote-region $@
}
_zsh_autosuggest_bound_1_quoted-insert () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-quoted-insert $@
}
_zsh_autosuggest_bound_1_read-command () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-read-command $@
}
_zsh_autosuggest_bound_1_recursive-edit () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-recursive-edit $@
}
_zsh_autosuggest_bound_1_redisplay () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-redisplay $@
}
_zsh_autosuggest_bound_1_redo () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-redo $@
}
_zsh_autosuggest_bound_1_reset-prompt () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-reset-prompt $@
}
_zsh_autosuggest_bound_1_reverse-menu-complete () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-reverse-menu-complete $@
}
_zsh_autosuggest_bound_1_select-a-blank-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-select-a-blank-word $@
}
_zsh_autosuggest_bound_1_select-a-shell-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-select-a-shell-word $@
}
_zsh_autosuggest_bound_1_select-a-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-select-a-word $@
}
_zsh_autosuggest_bound_1_select-in-blank-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-select-in-blank-word $@
}
_zsh_autosuggest_bound_1_select-in-shell-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-select-in-shell-word $@
}
_zsh_autosuggest_bound_1_select-in-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-select-in-word $@
}
_zsh_autosuggest_bound_1_self-insert () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-self-insert $@
}
_zsh_autosuggest_bound_1_self-insert-unmeta () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-self-insert-unmeta $@
}
_zsh_autosuggest_bound_1_send-break () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-send-break $@
}
_zsh_autosuggest_bound_1_set-mark-command () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-set-mark-command $@
}
_zsh_autosuggest_bound_1_spell-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-spell-word $@
}
_zsh_autosuggest_bound_1_split-undo () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-split-undo $@
}
_zsh_autosuggest_bound_1_transpose-chars () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-transpose-chars $@
}
_zsh_autosuggest_bound_1_transpose-words () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-transpose-words $@
}
_zsh_autosuggest_bound_1_undefined-key () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-undefined-key $@
}
_zsh_autosuggest_bound_1_undo () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-undo $@
}
_zsh_autosuggest_bound_1_universal-argument () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-universal-argument $@
}
_zsh_autosuggest_bound_1_up-case-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-up-case-word $@
}
_zsh_autosuggest_bound_1_up-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-up-history $@
}
_zsh_autosuggest_bound_1_up-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-up-line $@
}
_zsh_autosuggest_bound_1_up-line-or-beginning-search () {
	_zsh_autosuggest_widget_clear autosuggest-orig-1-up-line-or-beginning-search $@
}
_zsh_autosuggest_bound_1_up-line-or-history () {
	_zsh_autosuggest_widget_clear autosuggest-orig-1-up-line-or-history $@
}
_zsh_autosuggest_bound_1_up-line-or-search () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-up-line-or-search $@
}
_zsh_autosuggest_bound_1_vi-add-eol () {
	_zsh_autosuggest_widget_accept autosuggest-orig-1-vi-add-eol $@
}
_zsh_autosuggest_bound_1_vi-add-next () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-add-next $@
}
_zsh_autosuggest_bound_1_vi-backward-blank-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-backward-blank-word $@
}
_zsh_autosuggest_bound_1_vi-backward-blank-word-end () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-backward-blank-word-end $@
}
_zsh_autosuggest_bound_1_vi-backward-char () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-backward-char $@
}
_zsh_autosuggest_bound_1_vi-backward-delete-char () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-backward-delete-char $@
}
_zsh_autosuggest_bound_1_vi-backward-kill-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-backward-kill-word $@
}
_zsh_autosuggest_bound_1_vi-backward-word () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-backward-word $@
}
_zsh_autosuggest_bound_1_vi-backward-word-end () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-backward-word-end $@
}
_zsh_autosuggest_bound_1_vi-beginning-of-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-beginning-of-line $@
}
_zsh_autosuggest_bound_1_vi-caps-lock-panic () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-caps-lock-panic $@
}
_zsh_autosuggest_bound_1_vi-change () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-change $@
}
_zsh_autosuggest_bound_1_vi-change-eol () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-change-eol $@
}
_zsh_autosuggest_bound_1_vi-change-whole-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-change-whole-line $@
}
_zsh_autosuggest_bound_1_vi-cmd-mode () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-cmd-mode $@
}
_zsh_autosuggest_bound_1_vi-delete () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-delete $@
}
_zsh_autosuggest_bound_1_vi-delete-char () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-delete-char $@
}
_zsh_autosuggest_bound_1_vi-digit-or-beginning-of-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-digit-or-beginning-of-line $@
}
_zsh_autosuggest_bound_1_vi-down-case () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-down-case $@
}
_zsh_autosuggest_bound_1_vi-down-line-or-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-down-line-or-history $@
}
_zsh_autosuggest_bound_1_vi-end-of-line () {
	_zsh_autosuggest_widget_accept autosuggest-orig-1-vi-end-of-line $@
}
_zsh_autosuggest_bound_1_vi-fetch-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-fetch-history $@
}
_zsh_autosuggest_bound_1_vi-find-next-char () {
	_zsh_autosuggest_widget_partial_accept autosuggest-orig-1-vi-find-next-char $@
}
_zsh_autosuggest_bound_1_vi-find-next-char-skip () {
	_zsh_autosuggest_widget_partial_accept autosuggest-orig-1-vi-find-next-char-skip $@
}
_zsh_autosuggest_bound_1_vi-find-prev-char () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-find-prev-char $@
}
_zsh_autosuggest_bound_1_vi-find-prev-char-skip () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-find-prev-char-skip $@
}
_zsh_autosuggest_bound_1_vi-first-non-blank () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-first-non-blank $@
}
_zsh_autosuggest_bound_1_vi-forward-blank-word () {
	_zsh_autosuggest_widget_partial_accept autosuggest-orig-1-vi-forward-blank-word $@
}
_zsh_autosuggest_bound_1_vi-forward-blank-word-end () {
	_zsh_autosuggest_widget_partial_accept autosuggest-orig-1-vi-forward-blank-word-end $@
}
_zsh_autosuggest_bound_1_vi-forward-char () {
	_zsh_autosuggest_widget_accept autosuggest-orig-1-vi-forward-char $@
}
_zsh_autosuggest_bound_1_vi-forward-word () {
	_zsh_autosuggest_widget_partial_accept autosuggest-orig-1-vi-forward-word $@
}
_zsh_autosuggest_bound_1_vi-forward-word-end () {
	_zsh_autosuggest_widget_partial_accept autosuggest-orig-1-vi-forward-word-end $@
}
_zsh_autosuggest_bound_1_vi-goto-column () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-goto-column $@
}
_zsh_autosuggest_bound_1_vi-goto-mark () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-goto-mark $@
}
_zsh_autosuggest_bound_1_vi-goto-mark-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-goto-mark-line $@
}
_zsh_autosuggest_bound_1_vi-history-search-backward () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-history-search-backward $@
}
_zsh_autosuggest_bound_1_vi-history-search-forward () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-history-search-forward $@
}
_zsh_autosuggest_bound_1_vi-indent () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-indent $@
}
_zsh_autosuggest_bound_1_vi-insert () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-insert $@
}
_zsh_autosuggest_bound_1_vi-insert-bol () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-insert-bol $@
}
_zsh_autosuggest_bound_1_vi-join () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-join $@
}
_zsh_autosuggest_bound_1_vi-kill-eol () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-kill-eol $@
}
_zsh_autosuggest_bound_1_vi-kill-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-kill-line $@
}
_zsh_autosuggest_bound_1_vi-match-bracket () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-match-bracket $@
}
_zsh_autosuggest_bound_1_vi-open-line-above () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-open-line-above $@
}
_zsh_autosuggest_bound_1_vi-open-line-below () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-open-line-below $@
}
_zsh_autosuggest_bound_1_vi-oper-swap-case () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-oper-swap-case $@
}
_zsh_autosuggest_bound_1_vi-pound-insert () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-pound-insert $@
}
_zsh_autosuggest_bound_1_vi-put-after () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-put-after $@
}
_zsh_autosuggest_bound_1_vi-put-before () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-put-before $@
}
_zsh_autosuggest_bound_1_vi-quoted-insert () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-quoted-insert $@
}
_zsh_autosuggest_bound_1_vi-repeat-change () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-repeat-change $@
}
_zsh_autosuggest_bound_1_vi-repeat-find () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-repeat-find $@
}
_zsh_autosuggest_bound_1_vi-repeat-search () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-repeat-search $@
}
_zsh_autosuggest_bound_1_vi-replace () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-replace $@
}
_zsh_autosuggest_bound_1_vi-replace-chars () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-replace-chars $@
}
_zsh_autosuggest_bound_1_vi-rev-repeat-find () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-rev-repeat-find $@
}
_zsh_autosuggest_bound_1_vi-rev-repeat-search () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-rev-repeat-search $@
}
_zsh_autosuggest_bound_1_vi-set-buffer () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-set-buffer $@
}
_zsh_autosuggest_bound_1_vi-set-mark () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-set-mark $@
}
_zsh_autosuggest_bound_1_vi-substitute () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-substitute $@
}
_zsh_autosuggest_bound_1_vi-swap-case () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-swap-case $@
}
_zsh_autosuggest_bound_1_vi-undo-change () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-undo-change $@
}
_zsh_autosuggest_bound_1_vi-unindent () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-unindent $@
}
_zsh_autosuggest_bound_1_vi-up-case () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-up-case $@
}
_zsh_autosuggest_bound_1_vi-up-line-or-history () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-up-line-or-history $@
}
_zsh_autosuggest_bound_1_vi-yank () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-yank $@
}
_zsh_autosuggest_bound_1_vi-yank-eol () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-yank-eol $@
}
_zsh_autosuggest_bound_1_vi-yank-whole-line () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-vi-yank-whole-line $@
}
_zsh_autosuggest_bound_1_visual-line-mode () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-visual-line-mode $@
}
_zsh_autosuggest_bound_1_visual-mode () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-visual-mode $@
}
_zsh_autosuggest_bound_1_what-cursor-position () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-what-cursor-position $@
}
_zsh_autosuggest_bound_1_where-is () {
	_zsh_autosuggest_widget_modify autosuggest-orig-1-where-is $@
}
_zsh_autosuggest_capture_completion_async () {
	_zsh_autosuggest_capture_setup
	zmodload zsh/parameter 2> /dev/null || return
	autoload +X _complete
	functions[_original_complete]=$functions[_complete] 
	_complete () {
		unset 'compstate[vared]'
		_original_complete "$@"
	}
	vared 1
}
_zsh_autosuggest_capture_completion_sync () {
	_zsh_autosuggest_capture_setup
	zle autosuggest-capture-completion
}
_zsh_autosuggest_capture_completion_widget () {
	local -a +h comppostfuncs
	comppostfuncs=(_zsh_autosuggest_capture_postcompletion) 
	CURSOR=$#BUFFER 
	zle -- ${(k)widgets[(r)completion:.complete-word:_main_complete]}
	if is-at-least 5.0.3
	then
		stty -onlcr -ocrnl -F /dev/tty
	fi
	echo -nE - $'\0'$BUFFER$'\0'
}
_zsh_autosuggest_capture_postcompletion () {
	compstate[insert]=1 
	unset 'compstate[list]'
}
_zsh_autosuggest_capture_setup () {
	autoload -Uz is-at-least
	if ! is-at-least 5.4
	then
		zshexit () {
			kill -KILL $$ 2>&- || command kill -KILL $$
			sleep 1
		}
	fi
	zstyle ':completion:*' matcher-list ''
	zstyle ':completion:*' path-completion false
	zstyle ':completion:*' max-errors 0 not-numeric
	bindkey '^I' autosuggest-capture-completion
}
_zsh_autosuggest_clear () {
	unset POSTDISPLAY
	_zsh_autosuggest_invoke_original_widget $@
}
_zsh_autosuggest_disable () {
	typeset -g _ZSH_AUTOSUGGEST_DISABLED
	_zsh_autosuggest_clear
}
_zsh_autosuggest_enable () {
	unset _ZSH_AUTOSUGGEST_DISABLED
	if (( $#BUFFER ))
	then
		_zsh_autosuggest_fetch
	fi
}
_zsh_autosuggest_escape_command () {
	setopt localoptions EXTENDED_GLOB
	echo -E "${1//(#m)[\"\'\\()\[\]|*?~]/\\$MATCH}"
}
_zsh_autosuggest_execute () {
	BUFFER="$BUFFER$POSTDISPLAY" 
	unset POSTDISPLAY
	_zsh_autosuggest_invoke_original_widget "accept-line"
}
_zsh_autosuggest_fetch () {
	if (( ${+ZSH_AUTOSUGGEST_USE_ASYNC} ))
	then
		_zsh_autosuggest_async_request "$BUFFER"
	else
		local suggestion
		_zsh_autosuggest_fetch_suggestion "$BUFFER"
		_zsh_autosuggest_suggest "$suggestion"
	fi
}
_zsh_autosuggest_fetch_suggestion () {
	typeset -g suggestion
	local -a strategies
	local strategy
	strategies=(${=ZSH_AUTOSUGGEST_STRATEGY}) 
	for strategy in $strategies
	do
		_zsh_autosuggest_strategy_$strategy "$1"
		[[ "$suggestion" != "$1"* ]] && unset suggestion
		[[ -n "$suggestion" ]] && break
	done
}
_zsh_autosuggest_highlight_apply () {
	typeset -g _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT
	if (( $#POSTDISPLAY ))
	then
		typeset -g _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT="$#BUFFER $(($#BUFFER + $#POSTDISPLAY)) $ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE" 
		region_highlight+=("$_ZSH_AUTOSUGGEST_LAST_HIGHLIGHT") 
	else
		unset _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT
	fi
}
_zsh_autosuggest_highlight_reset () {
	typeset -g _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT
	if [[ -n "$_ZSH_AUTOSUGGEST_LAST_HIGHLIGHT" ]]
	then
		region_highlight=("${(@)region_highlight:#$_ZSH_AUTOSUGGEST_LAST_HIGHLIGHT}") 
		unset _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT
	fi
}
_zsh_autosuggest_incr_bind_count () {
	typeset -gi bind_count=$((_ZSH_AUTOSUGGEST_BIND_COUNTS[$1]+1)) 
	_ZSH_AUTOSUGGEST_BIND_COUNTS[$1]=$bind_count 
}
_zsh_autosuggest_invoke_original_widget () {
	(( $# )) || return 0
	local original_widget_name="$1" 
	shift
	if (( ${+widgets[$original_widget_name]} ))
	then
		zle $original_widget_name -- $@
	fi
}
_zsh_autosuggest_modify () {
	local -i retval
	local -i KEYS_QUEUED_COUNT
	local orig_buffer="$BUFFER" 
	local orig_postdisplay="$POSTDISPLAY" 
	unset POSTDISPLAY
	_zsh_autosuggest_invoke_original_widget $@
	retval=$? 
	emulate -L zsh
	if (( $PENDING > 0 )) || (( $KEYS_QUEUED_COUNT > 0 ))
	then
		POSTDISPLAY="$orig_postdisplay" 
		return $retval
	fi
	if (( $#BUFFER > $#orig_buffer ))
	then
		local added=${BUFFER#$orig_buffer} 
		if [[ "$added" = "${orig_postdisplay:0:$#added}" ]]
		then
			POSTDISPLAY="${orig_postdisplay:$#added}" 
			return $retval
		fi
	fi
	if [[ "$BUFFER" = "$orig_buffer" ]]
	then
		POSTDISPLAY="$orig_postdisplay" 
		return $retval
	fi
	if [[ -n "${_ZSH_AUTOSUGGEST_DISABLED+x}" ]]
	then
		return $?
	fi
	if (( $#BUFFER > 0 ))
	then
		if [[ -z "$ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE" ]] || (( $#BUFFER <= $ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE ))
		then
			_zsh_autosuggest_fetch
		fi
	fi
	return $retval
}
_zsh_autosuggest_partial_accept () {
	local -i retval cursor_loc
	local original_buffer="$BUFFER" 
	BUFFER="$BUFFER$POSTDISPLAY" 
	_zsh_autosuggest_invoke_original_widget $@
	retval=$? 
	cursor_loc=$CURSOR 
	if [[ "$KEYMAP" = "vicmd" ]]
	then
		cursor_loc=$((cursor_loc + 1)) 
	fi
	if (( $cursor_loc > $#original_buffer ))
	then
		POSTDISPLAY="${BUFFER[$(($cursor_loc + 1)),$#BUFFER]}" 
		BUFFER="${BUFFER[1,$cursor_loc]}" 
	else
		BUFFER="$original_buffer" 
	fi
	return $retval
}
_zsh_autosuggest_start () {
	if (( ${+ZSH_AUTOSUGGEST_MANUAL_REBIND} ))
	then
		add-zsh-hook -d precmd _zsh_autosuggest_start
	fi
	_zsh_autosuggest_bind_widgets
}
_zsh_autosuggest_strategy_completion () {
	typeset -g suggestion
	local line REPLY
	whence compdef > /dev/null || return
	zmodload zsh/zpty 2> /dev/null || return
	if zle
	then
		zpty $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME _zsh_autosuggest_capture_completion_sync
	else
		zpty $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME _zsh_autosuggest_capture_completion_async "\$1"
		zpty -w $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME $'\t'
	fi
	{
		zpty -r $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME line '*'$'\0''*'$'\0'
		suggestion="${${line#*$'\0'}%$'\0'*}" 
	} always {
		zpty -d $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME
	}
}
_zsh_autosuggest_strategy_history () {
	emulate -L zsh
	setopt EXTENDED_GLOB
	local prefix="${1//(#m)[\\*?[\]<>()|^~#]/\\$MATCH}" 
	typeset -g suggestion="${history[(r)${prefix}*]}" 
}
_zsh_autosuggest_strategy_match_prev_cmd () {
	emulate -L zsh
	setopt EXTENDED_GLOB
	local prefix="${1//(#m)[\\*?[\]<>()|^~#]/\\$MATCH}" 
	local history_match_keys
	history_match_keys=(${(k)history[(R)$prefix*]}) 
	local histkey="${history_match_keys[1]}" 
	local prev_cmd="$(_zsh_autosuggest_escape_command "${history[$((HISTCMD-1))]}")" 
	for key in "${(@)history_match_keys[1,200]}"
	do
		[[ $key -gt 1 ]] || break
		if [[ "${history[$((key - 1))]}" == "$prev_cmd" ]]
		then
			histkey="$key" 
			break
		fi
	done
	typeset -g suggestion="$history[$histkey]" 
}
_zsh_autosuggest_suggest () {
	emulate -L zsh
	local suggestion="$1" 
	if [[ -n "$suggestion" ]] && (( $#BUFFER ))
	then
		POSTDISPLAY="${suggestion#$BUFFER}" 
	else
		unset POSTDISPLAY
	fi
}
_zsh_autosuggest_toggle () {
	if [[ -n "${_ZSH_AUTOSUGGEST_DISABLED+x}" ]]
	then
		_zsh_autosuggest_enable
	else
		_zsh_autosuggest_disable
	fi
}
_zsh_autosuggest_widget_accept () {
	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_accept $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval
}
_zsh_autosuggest_widget_clear () {
	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_clear $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval
}
_zsh_autosuggest_widget_disable () {
	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_disable $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval
}
_zsh_autosuggest_widget_enable () {
	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_enable $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval
}
_zsh_autosuggest_widget_execute () {
	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_execute $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval
}
_zsh_autosuggest_widget_fetch () {
	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_fetch $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval
}
_zsh_autosuggest_widget_modify () {
	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_modify $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval
}
_zsh_autosuggest_widget_partial_accept () {
	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_partial_accept $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval
}
_zsh_autosuggest_widget_suggest () {
	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_suggest $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval
}
_zsh_autosuggest_widget_toggle () {
	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_toggle $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval
}
_zsh_highlight () {
	local ret=$? 
	if [[ $WIDGET == zle-isearch-update ]] && {
			$zsh_highlight__pat_static_bug || ! (( $+ISEARCHMATCH_ACTIVE ))
		}
	then
		region_highlight=() 
		return $ret
	fi
	local -A zsyh_user_options
	if zmodload -e zsh/parameter
	then
		zsyh_user_options=("${(@kv)options}") 
	else
		local canonical_options onoff option raw_options
		raw_options=(${(f)"$(emulate -R zsh; set -o)"}) 
		canonical_options=(${${${(M)raw_options:#*off}%% *}#no} ${${(M)raw_options:#*on}%% *}) 
		for option in $canonical_options
		do
			[[ -o $option ]]
			onoff=${${=:-off on}[2-$?]} 
			zsyh_user_options+=($option $onoff) 
		done
	fi
	typeset -r zsyh_user_options
	emulate -L zsh
	setopt localoptions warncreateglobal nobashrematch
	local REPLY
	[[ -n ${ZSH_HIGHLIGHT_MAXLENGTH:-} ]] && [[ $#BUFFER -gt $ZSH_HIGHLIGHT_MAXLENGTH ]] && return $ret
	[[ $PENDING -gt 0 ]] && return $ret
	typeset -ga region_highlight
	region_highlight=() 
	{
		local cache_place
		local -a region_highlight_copy
		local highlighter
		for highlighter in $ZSH_HIGHLIGHT_HIGHLIGHTERS
		do
			cache_place="_zsh_highlight__highlighter_${highlighter}_cache" 
			typeset -ga ${cache_place}
			if ! type "_zsh_highlight_highlighter_${highlighter}_predicate" >&/dev/null
			then
				echo "zsh-syntax-highlighting: warning: disabling the ${(qq)highlighter} highlighter as it has not been loaded" >&2
				ZSH_HIGHLIGHT_HIGHLIGHTERS=(${ZSH_HIGHLIGHT_HIGHLIGHTERS:#${highlighter}}) 
			elif "_zsh_highlight_highlighter_${highlighter}_predicate"
			then
				region_highlight_copy=("${region_highlight[@]}") 
				region_highlight=() 
				{
					"_zsh_highlight_highlighter_${highlighter}_paint"
				} always {
					: ${(AP)cache_place::="${region_highlight[@]}"}
				}
				region_highlight=("${region_highlight_copy[@]}") 
			fi
			region_highlight+=("${(@P)cache_place}") 
		done
		() {
			(( REGION_ACTIVE )) || return
			integer min max
			if (( MARK > CURSOR ))
			then
				min=$CURSOR max=$MARK 
			else
				min=$MARK max=$CURSOR 
			fi
			if (( REGION_ACTIVE == 1 ))
			then
				[[ $KEYMAP = vicmd ]] && (( max++ ))
			elif (( REGION_ACTIVE == 2 ))
			then
				local needle=$'\n' 
				(( min = ${BUFFER[(Ib:min:)$needle]} ))
				(( max = ${BUFFER[(ib:max:)$needle]} - 1 ))
			fi
			_zsh_highlight_apply_zle_highlight region standout "$min" "$max"
		}
		(( $+YANK_ACTIVE )) && (( YANK_ACTIVE )) && _zsh_highlight_apply_zle_highlight paste standout "$YANK_START" "$YANK_END"
		(( $+ISEARCHMATCH_ACTIVE )) && (( ISEARCHMATCH_ACTIVE )) && _zsh_highlight_apply_zle_highlight isearch underline "$ISEARCHMATCH_START" "$ISEARCHMATCH_END"
		(( $+SUFFIX_ACTIVE )) && (( SUFFIX_ACTIVE )) && _zsh_highlight_apply_zle_highlight suffix bold "$SUFFIX_START" "$SUFFIX_END"
		return $ret
	} always {
		typeset -g _ZSH_HIGHLIGHT_PRIOR_BUFFER="$BUFFER" 
		typeset -gi _ZSH_HIGHLIGHT_PRIOR_CURSOR=$CURSOR 
	}
}
_zsh_highlight_add_highlight () {
	local -i start end
	local highlight
	start=$1 
	end=$2 
	shift 2
	for highlight
	do
		if (( $+ZSH_HIGHLIGHT_STYLES[$highlight] ))
		then
			region_highlight+=("$start $end $ZSH_HIGHLIGHT_STYLES[$highlight]") 
			break
		fi
	done
}
_zsh_highlight_apply_zle_highlight () {
	local entry="$1" default="$2" 
	integer first="$3" second="$4" 
	local region="${zle_highlight[(r)${entry}:*]-}" 
	if [[ -z "$region" ]]
	then
		region=$default 
	else
		region="${region#${entry}:}" 
		if [[ -z "$region" ]] || [[ "$region" == none ]]
		then
			return
		fi
	fi
	integer start end
	if (( first < second ))
	then
		start=$first end=$second 
	else
		start=$second end=$first 
	fi
	region_highlight+=("$start $end $region") 
}
_zsh_highlight_bind_widgets () {
	setopt localoptions noksharrays
	typeset -F SECONDS
	local prefix=orig-s$SECONDS-r$RANDOM 
	zmodload zsh/zleparameter 2> /dev/null || {
		print -r -- 'zsh-syntax-highlighting: failed loading zsh/zleparameter.' >&2
		return 1
	}
	local -U widgets_to_bind
	widgets_to_bind=(${${(k)widgets}:#(.*|run-help|which-command|beep|set-local-history|yank|yank-pop)}) 
	widgets_to_bind+=(zle-line-finish) 
	widgets_to_bind+=(zle-isearch-update) 
	local cur_widget
	for cur_widget in $widgets_to_bind
	do
		case ${widgets[$cur_widget]:-""} in
			(user:_zsh_highlight_widget_*)  ;;
			(user:*) zle -N $prefix-$cur_widget ${widgets[$cur_widget]#*:}
				eval "_zsh_highlight_widget_${(q)prefix}-${(q)cur_widget}() { _zsh_highlight_call_widget ${(q)prefix}-${(q)cur_widget} -- \"\$@\" }"
				zle -N $cur_widget _zsh_highlight_widget_$prefix-$cur_widget ;;
			(completion:*) zle -C $prefix-$cur_widget ${${(s.:.)widgets[$cur_widget]}[2,3]}
				eval "_zsh_highlight_widget_${(q)prefix}-${(q)cur_widget}() { _zsh_highlight_call_widget ${(q)prefix}-${(q)cur_widget} -- \"\$@\" }"
				zle -N $cur_widget _zsh_highlight_widget_$prefix-$cur_widget ;;
			(builtin) eval "_zsh_highlight_widget_${(q)prefix}-${(q)cur_widget}() { _zsh_highlight_call_widget .${(q)cur_widget} -- \"\$@\" }"
				zle -N $cur_widget _zsh_highlight_widget_$prefix-$cur_widget ;;
			(*) if [[ $cur_widget == zle-* ]] && (( ! ${+widgets[$cur_widget]} ))
				then
					_zsh_highlight_widget_${cur_widget} () {
						:
						_zsh_highlight
					}
					zle -N $cur_widget _zsh_highlight_widget_$cur_widget
				else
					print -r -- "zsh-syntax-highlighting: unhandled ZLE widget ${(qq)cur_widget}" >&2
					print -r -- "zsh-syntax-highlighting: (This is sometimes caused by doing \`bindkey <keys> ${(q-)cur_widget}\` without creating the ${(qq)cur_widget} widget with \`zle -N\` or \`zle -C\`.)" >&2
				fi ;;
		esac
	done
}
_zsh_highlight_brackets_match () {
	case $BUFFER[$1] in
		(\() [[ $BUFFER[$2] == \) ]] ;;
		(\[) [[ $BUFFER[$2] == \] ]] ;;
		(\{) [[ $BUFFER[$2] == \} ]] ;;
		(*) false ;;
	esac
}
_zsh_highlight_buffer_modified () {
	[[ "${_ZSH_HIGHLIGHT_PRIOR_BUFFER:-}" != "$BUFFER" ]]
}
_zsh_highlight_call_widget () {
	builtin zle "$@" && _zsh_highlight
}
_zsh_highlight_cursor_moved () {
	[[ -n $CURSOR ]] && [[ -n ${_ZSH_HIGHLIGHT_PRIOR_CURSOR-} ]] && (($_ZSH_HIGHLIGHT_PRIOR_CURSOR != $CURSOR))
}
_zsh_highlight_highlighter_brackets_paint () {
	local char style
	local -i bracket_color_size=${#ZSH_HIGHLIGHT_STYLES[(I)bracket-level-*]} buflen=${#BUFFER} level=0 matchingpos pos 
	local -A levelpos lastoflevel matching
	for ((pos = 1; pos <= buflen; pos++ )) do
		char=$BUFFER[pos] 
		case $char in
			(["([{"]) levelpos[$pos]=$((++level)) 
				lastoflevel[$level]=$pos  ;;
			([")]}"]) if (( level > 0 ))
				then
					matchingpos=$lastoflevel[$level] 
					levelpos[$pos]=$((level--)) 
					if _zsh_highlight_brackets_match $matchingpos $pos
					then
						matching[$matchingpos]=$pos 
						matching[$pos]=$matchingpos 
					fi
				else
					levelpos[$pos]=-1 
				fi ;;
		esac
	done
	for pos in ${(k)levelpos}
	do
		if (( $+matching[$pos] ))
		then
			if (( bracket_color_size ))
			then
				_zsh_highlight_add_highlight $((pos - 1)) $pos bracket-level-$(( (levelpos[$pos] - 1) % bracket_color_size + 1 ))
			fi
		else
			_zsh_highlight_add_highlight $((pos - 1)) $pos bracket-error
		fi
	done
	if [[ $WIDGET != zle-line-finish ]]
	then
		pos=$((CURSOR + 1)) 
		if (( $+levelpos[$pos] )) && (( $+matching[$pos] ))
		then
			local -i otherpos=$matching[$pos] 
			_zsh_highlight_add_highlight $((otherpos - 1)) $otherpos cursor-matchingbracket
		fi
	fi
}
_zsh_highlight_highlighter_brackets_predicate () {
	[[ $WIDGET == zle-line-finish ]] || _zsh_highlight_cursor_moved || _zsh_highlight_buffer_modified
}
_zsh_highlight_highlighter_cursor_paint () {
	[[ $WIDGET == zle-line-finish ]] && return
	_zsh_highlight_add_highlight $CURSOR $(( $CURSOR + 1 )) cursor
}
_zsh_highlight_highlighter_cursor_predicate () {
	[[ $WIDGET == zle-line-finish ]] || _zsh_highlight_cursor_moved
}
_zsh_highlight_highlighter_line_paint () {
	_zsh_highlight_add_highlight 0 $#BUFFER line
}
_zsh_highlight_highlighter_line_predicate () {
	_zsh_highlight_buffer_modified
}
_zsh_highlight_highlighter_main_paint () {
	setopt localoptions extendedglob
	if [[ $CONTEXT == (select|vared) ]]
	then
		return
	fi
	typeset -a ZSH_HIGHLIGHT_TOKENS_COMMANDSEPARATOR
	typeset -a ZSH_HIGHLIGHT_TOKENS_CONTROL_FLOW
	local -a options_to_set reply
	local REPLY
	local flags_with_argument
	local flags_sans_argument
	local -A precommand_options
	precommand_options=('-' '' 'builtin' '' 'command' :pvV 'exec' a:cl 'nocorrect' '' 'noglob' '' 'doas' aCu:Lns 'nice' n: 'pkexec' '' 'sudo' Cgprtu:AEHKPSVbhiklnsv 'stdbuf' ioe:) 
	if [[ $zsyh_user_options[ignorebraces] == on || ${zsyh_user_options[ignoreclosebraces]:-off} == on ]]
	then
		local right_brace_is_recognised_everywhere=false 
	else
		local right_brace_is_recognised_everywhere=true 
	fi
	if [[ $zsyh_user_options[pathdirs] == on ]]
	then
		options_to_set+=(PATH_DIRS) 
	fi
	ZSH_HIGHLIGHT_TOKENS_COMMANDSEPARATOR=('|' '||' ';' '&' '&&' '|&' '&!' '&|') 
	ZSH_HIGHLIGHT_TOKENS_CONTROL_FLOW=($'\x7b' $'\x28' '()' 'while' 'until' 'if' 'then' 'elif' 'else' 'do' 'time' 'coproc' '!') 
	if (( $+X_ZSH_HIGHLIGHT_DIRS_BLACKLIST ))
	then
		print 'zsh-syntax-highlighting: X_ZSH_HIGHLIGHT_DIRS_BLACKLIST is deprecated. Please use ZSH_HIGHLIGHT_DIRS_BLACKLIST.' >&2
		ZSH_HIGHLIGHT_DIRS_BLACKLIST=($X_ZSH_HIGHLIGHT_DIRS_BLACKLIST) 
		unset X_ZSH_HIGHLIGHT_DIRS_BLACKLIST
	fi
	_zsh_highlight_main_highlighter_highlight_list -$#PREBUFFER '' 1 "$PREBUFFER$BUFFER"
	local start end_ style
	for start end_ style in $reply
	do
		(( start >= end_ )) && {
			print -r -- "zsh-syntax-highlighting: BUG: _zsh_highlight_highlighter_main_paint: start($start) >= end($end_)" >&2
			return
		}
		(( end_ <= 0 )) && continue
		(( start < 0 )) && start=0 
		_zsh_highlight_main_calculate_fallback $style
		_zsh_highlight_add_highlight $start $end_ $reply
	done
}
_zsh_highlight_highlighter_main_predicate () {
	[[ $WIDGET == zle-line-finish ]] || _zsh_highlight_buffer_modified
}
_zsh_highlight_highlighter_pattern_paint () {
	setopt localoptions extendedglob
	local pattern
	for pattern in ${(k)ZSH_HIGHLIGHT_PATTERNS}
	do
		_zsh_highlight_pattern_highlighter_loop "$BUFFER" "$pattern"
	done
}
_zsh_highlight_highlighter_pattern_predicate () {
	_zsh_highlight_buffer_modified
}
_zsh_highlight_highlighter_regexp_paint () {
	setopt localoptions extendedglob
	local pattern
	for pattern in ${(k)ZSH_HIGHLIGHT_REGEXP}
	do
		_zsh_highlight_regexp_highlighter_loop "$BUFFER" "$pattern"
	done
}
_zsh_highlight_highlighter_regexp_predicate () {
	_zsh_highlight_buffer_modified
}
_zsh_highlight_highlighter_root_paint () {
	if (( EUID == 0 ))
	then
		_zsh_highlight_add_highlight 0 $#BUFFER root
	fi
}
_zsh_highlight_highlighter_root_predicate () {
	_zsh_highlight_buffer_modified
}
_zsh_highlight_load_highlighters () {
	setopt localoptions noksharrays bareglobqual
	[[ -d "$1" ]] || {
		print -r -- "zsh-syntax-highlighting: highlighters directory ${(qq)1} not found." >&2
		return 1
	}
	local highlighter highlighter_dir
	for highlighter_dir in $1/*/(/)
	do
		highlighter="${highlighter_dir:t}" 
		[[ -f "$highlighter_dir${highlighter}-highlighter.zsh" ]] && . "$highlighter_dir${highlighter}-highlighter.zsh"
		if type "_zsh_highlight_highlighter_${highlighter}_paint" &> /dev/null && type "_zsh_highlight_highlighter_${highlighter}_predicate" &> /dev/null
		then
			
		elif type "_zsh_highlight_${highlighter}_highlighter" &> /dev/null && type "_zsh_highlight_${highlighter}_highlighter_predicate" &> /dev/null
		then
			if false
			then
				print -r -- "zsh-syntax-highlighting: warning: ${(qq)highlighter} highlighter uses deprecated entry point names; please ask its maintainer to update it: https://github.com/zsh-users/zsh-syntax-highlighting/issues/329" >&2
			fi
			eval "_zsh_highlight_highlighter_${(q)highlighter}_paint() { _zsh_highlight_${(q)highlighter}_highlighter \"\$@\" }"
			eval "_zsh_highlight_highlighter_${(q)highlighter}_predicate() { _zsh_highlight_${(q)highlighter}_highlighter_predicate \"\$@\" }"
		else
			print -r -- "zsh-syntax-highlighting: ${(qq)highlighter} highlighter should define both required functions '_zsh_highlight_highlighter_${highlighter}_paint' and '_zsh_highlight_highlighter_${highlighter}_predicate' in ${(qq):-"$highlighter_dir${highlighter}-highlighter.zsh"}." >&2
		fi
	done
}
_zsh_highlight_main__is_redirection () {
	[[ $1 == (<0-9>|)(\<|\>)* ]] && [[ $1 != (\<|\>)$'\x28'* ]] && [[ $1 != *'<'*'-'*'>'* ]]
}
_zsh_highlight_main__is_runnable () {
	if _zsh_highlight_main__type "$1"
	then
		[[ $REPLY != none ]]
	else
		return 2
	fi
}
_zsh_highlight_main__precmd_hook () {
	_zsh_highlight_main__command_type_cache=() 
}
_zsh_highlight_main__resolve_alias () {
	if zmodload -e zsh/parameter
	then
		REPLY=${aliases[$arg]} 
	else
		REPLY="${"$(alias -- $arg)"#*=}" 
	fi
}
_zsh_highlight_main__stack_pop () {
	if [[ $braces_stack[1] == $1 ]]
	then
		braces_stack=${braces_stack:1} 
		if (( $+2 ))
		then
			style=$2 
		fi
		return 0
	else
		style=unknown-token 
		return 1
	fi
}
_zsh_highlight_main__type () {
	integer -r aliases_allowed=${2-1} 
	integer may_cache=1 
	if (( $+_zsh_highlight_main__command_type_cache ))
	then
		REPLY=$_zsh_highlight_main__command_type_cache[(e)$1] 
		if [[ -n "$REPLY" ]]
		then
			return
		fi
	fi
	if (( $#options_to_set ))
	then
		setopt localoptions $options_to_set
	fi
	unset REPLY
	if zmodload -e zsh/parameter
	then
		if (( $+aliases[(e)$1] ))
		then
			may_cache=0 
		fi
		if (( $+aliases[(e)$1] )) && (( aliases_allowed ))
		then
			REPLY=alias 
		elif [[ $1 == *.* && -n ${1%.*} ]] && (( $+saliases[(e)${1##*.}] ))
		then
			REPLY='suffix alias' 
		elif (( $reswords[(Ie)$1] ))
		then
			REPLY=reserved 
		elif (( $+functions[(e)$1] ))
		then
			REPLY=function 
		elif (( $+builtins[(e)$1] ))
		then
			REPLY=builtin 
		elif (( $+commands[(e)$1] ))
		then
			REPLY=command 
		elif {
				[[ $1 != */* ]] || is-at-least 5.3
			} && ! (
				builtin type -w -- $1
			) > /dev/null 2>&1
		then
			REPLY=none 
		fi
	fi
	if ! (( $+REPLY ))
	then
		REPLY="${$(:; (( aliases_allowed )) || unalias -- $1 2>/dev/null; LC_ALL=C builtin type -w -- $1 2>/dev/null)##*: }" 
		if [[ $REPLY == 'alias' ]]
		then
			may_cache=0 
		fi
	fi
	if (( may_cache )) && (( $+_zsh_highlight_main__command_type_cache ))
	then
		_zsh_highlight_main__command_type_cache[(e)$1]=$REPLY 
	fi
	[[ -n $REPLY ]]
	return $?
}
_zsh_highlight_main_add_many_region_highlights () {
	for 1 2 3
	do
		_zsh_highlight_main_add_region_highlight $1 $2 $3
	done
}
_zsh_highlight_main_add_region_highlight () {
	integer start=$1 end=$2 
	shift 2
	if (( in_alias ))
	then
		[[ $1 == unknown-token ]] && alias_style=unknown-token 
		return
	fi
	(( start += buf_offset ))
	(( end += buf_offset ))
	list_highlights+=($start $end $1) 
}
_zsh_highlight_main_calculate_fallback () {
	local -A fallback_of
	fallback_of=(alias arg0 suffix-alias arg0 builtin arg0 function arg0 command arg0 precommand arg0 hashed-command arg0 arg0_\* arg0 path_prefix path path_pathseparator path path_prefix_pathseparator path_prefix single-quoted-argument{-unclosed,} double-quoted-argument{-unclosed,} dollar-quoted-argument{-unclosed,} back-quoted-argument{-unclosed,} command-substitution{-quoted,,-unquoted,} command-substitution-delimiter{-quoted,,-unquoted,} command-substitution{-delimiter,} process-substitution{-delimiter,} back-quoted-argument{-delimiter,}) 
	local needle=$1 value 
	reply=($1) 
	while [[ -n ${value::=$fallback_of[(k)$needle]} ]]
	do
		unset "fallback_of[$needle]"
		reply+=($value) 
		needle=$value 
	done
}
_zsh_highlight_main_highlighter_check_assign () {
	setopt localoptions extended_glob
	[[ $arg == [[:alpha:]_][[:alnum:]_]#(|\[*\])(|[+])=* ]] || [[ $arg == [0-9]##(|[+])=* ]]
}
_zsh_highlight_main_highlighter_check_path () {
	_zsh_highlight_main_highlighter_expand_path "$1"
	local expanded_path="$REPLY" tmp_path 
	REPLY=path 
	[[ -z $expanded_path ]] && return 1
	if [[ $expanded_path[1] == / ]]
	then
		tmp_path=$expanded_path 
	else
		tmp_path=$PWD/$expanded_path 
	fi
	tmp_path=$tmp_path:a 
	while [[ $tmp_path != / ]]
	do
		[[ -n ${(M)ZSH_HIGHLIGHT_DIRS_BLACKLIST:#$tmp_path} ]] && return 1
		tmp_path=$tmp_path:h 
	done
	[[ -L $expanded_path ]] && return 0
	[[ -e $expanded_path ]] && return 0
	local cdpath_dir
	for cdpath_dir in $cdpath
	do
		[[ -e "$cdpath_dir/$expanded_path" ]] && return 0
	done
	[[ ! -d ${expanded_path:h} ]] && return 1
	if (( has_end && (len == end_pos) )) && [[ $WIDGET != zle-line-finish ]]
	then
		local -a tmp
		tmp=(${expanded_path}*(N)) 
		(( $#tmp > 0 )) && REPLY=path_prefix  && return 0
	fi
	return 1
}
_zsh_highlight_main_highlighter_expand_path () {
	(( $# == 1 )) || print -r -- "zsh-syntax-highlighting: BUG: _zsh_highlight_main_highlighter_expand_path: called without argument" >&2
	setopt localoptions nonomatch
	unset REPLY
	: ${REPLY:=${(Q)${~1}}}
}
_zsh_highlight_main_highlighter_highlight_argument () {
	local base_style=default i=$1 option_eligible=${2:-1} path_eligible=1 ret start style 
	local -a highlights
	local -a match mbegin mend
	local MATCH
	integer MBEGIN MEND
	case "$arg[i]" in
		('%') if [[ $arg[i+1] == '?' ]]
			then
				(( i += 2 ))
			fi ;;
		('-') if (( option_eligible ))
			then
				if [[ $arg[i+1] == - ]]
				then
					base_style=double-hyphen-option 
				else
					base_style=single-hyphen-option 
				fi
				path_eligible=0 
			fi ;;
		('=') if [[ $arg[i+1] == $'\x28' ]]
			then
				(( i += 2 ))
				_zsh_highlight_main_highlighter_highlight_list $(( start_pos + i - 1 )) S $has_end $arg[i,-1]
				ret=$? 
				(( i += REPLY ))
				highlights+=($(( start_pos + $1 - 1 )) $(( start_pos + i )) process-substitution $(( start_pos + $1 - 1 )) $(( start_pos + $1 + 1 )) process-substitution-delimiter $reply) 
				if (( ret == 0 ))
				then
					highlights+=($(( start_pos + i - 1 )) $(( start_pos + i )) process-substitution-delimiter) 
				fi
			fi ;;
	esac
	for ((; i <= $#arg ; i += 1 )) do
		case "$arg[$i]" in
			("\\") (( i += 1 ))
				continue ;;
			("'") _zsh_highlight_main_highlighter_highlight_single_quote $i
				(( i = REPLY ))
				highlights+=($reply)  ;;
			('"') _zsh_highlight_main_highlighter_highlight_double_quote $i
				(( i = REPLY ))
				highlights+=($reply)  ;;
			('`') _zsh_highlight_main_highlighter_highlight_backtick $i
				(( i = REPLY ))
				highlights+=($reply)  ;;
			('$') if [[ $arg[i+1] != "'" ]]
				then
					path_eligible=0 
				fi
				if [[ $arg[i+1] == "'" ]]
				then
					_zsh_highlight_main_highlighter_highlight_dollar_quote $i
					(( i = REPLY ))
					highlights+=($reply) 
					continue
				elif [[ $arg[i+1] == $'\x28' ]]
				then
					start=$i 
					(( i += 2 ))
					_zsh_highlight_main_highlighter_highlight_list $(( start_pos + i - 1 )) S $has_end $arg[i,-1]
					ret=$? 
					(( i += REPLY ))
					highlights+=($(( start_pos + start - 1)) $(( start_pos + i )) command-substitution-unquoted $(( start_pos + start - 1)) $(( start_pos + start + 1)) command-substitution-delimiter-unquoted $reply) 
					if (( ret == 0 ))
					then
						highlights+=($(( start_pos + i - 1)) $(( start_pos + i )) command-substitution-delimiter-unquoted) 
					fi
					continue
				fi
				while [[ $arg[i+1] == [\^=~#+] ]]
				do
					(( i += 1 ))
				done
				if [[ $arg[i+1] == [*@#?$!-] ]]
				then
					(( i += 1 ))
				fi ;;
			([\<\>]) if [[ $arg[i+1] == $'\x28' ]]
				then
					start=$i 
					(( i += 2 ))
					_zsh_highlight_main_highlighter_highlight_list $(( start_pos + i - 1 )) S $has_end $arg[i,-1]
					ret=$? 
					(( i += REPLY ))
					highlights+=($(( start_pos + start - 1)) $(( start_pos + i )) process-substitution $(( start_pos + start - 1)) $(( start_pos + start + 1 )) process-substitution-delimiter $reply) 
					if (( ret == 0 ))
					then
						highlights+=($(( start_pos + i - 1)) $(( start_pos + i )) process-substitution-delimiter) 
					fi
					continue
				fi ;|
			(*) if $highlight_glob && [[ ${arg[$i]} =~ ^[*?] || ${arg:$i-1} =~ ^\<[0-9]*-[0-9]*\> ]]
				then
					highlights+=($(( start_pos + i - 1 )) $(( start_pos + i + $#MATCH - 1)) globbing) 
					(( i += $#MATCH - 1 ))
					path_eligible=0 
				else
					continue
				fi ;;
		esac
	done
	if (( path_eligible )) && _zsh_highlight_main_highlighter_check_path $arg[$1,-1]
	then
		base_style=$REPLY 
		_zsh_highlight_main_highlighter_highlight_path_separators $base_style
		highlights+=($reply) 
	fi
	highlights=($(( start_pos + $1 - 1 )) $end_pos $base_style $highlights) 
	_zsh_highlight_main_add_many_region_highlights $highlights
}
_zsh_highlight_main_highlighter_highlight_backtick () {
	local buf highlight style=back-quoted-argument-unclosed style_end 
	local -i arg1=$1 end_ i=$1 last offset=0 start subshell_has_end=0 
	local -a highlight_zone highlights offsets
	reply=() 
	last=$(( arg1 + 1 )) 
	while i=$arg[(ib:i+1:)[\\\\\`]] 
	do
		if (( i > $#arg ))
		then
			buf=$buf$arg[last,i] 
			offsets[i-arg1-offset]='' 
			(( i-- ))
			subshell_has_end=$(( has_end && (start_pos + i == len) )) 
			break
		fi
		if [[ $arg[i] == '\' ]]
		then
			(( i++ ))
			if [[ $arg[i] == ('$'|'`'|'\') ]]
			then
				buf=$buf$arg[last,i-2] 
				(( offset++ ))
				offsets[i-arg1-offset]=$offset 
			else
				buf=$buf$arg[last,i-1] 
			fi
		else
			style=back-quoted-argument 
			style_end=back-quoted-argument-delimiter 
			buf=$buf$arg[last,i-1] 
			offsets[i-arg1-offset]='' 
			break
		fi
		last=$i 
	done
	_zsh_highlight_main_highlighter_highlight_list 0 '' $subshell_has_end $buf
	for start end_ highlight in $reply
	do
		start=$(( start_pos + arg1 + start + offsets[(Rb:start:)?*] )) 
		end_=$(( start_pos + arg1 + end_ + offsets[(Rb:end_:)?*] )) 
		highlights+=($start $end_ $highlight) 
		if [[ $highlight == back-quoted-argument-unclosed && $style == back-quoted-argument ]]
		then
			style_end=unknown-token 
		fi
	done
	reply=($(( start_pos + arg1 - 1 )) $(( start_pos + i )) $style $(( start_pos + arg1 - 1 )) $(( start_pos + arg1 )) back-quoted-argument-delimiter $highlights) 
	if (( $#style_end ))
	then
		reply+=($(( start_pos + i - 1)) $(( start_pos + i )) $style_end) 
	fi
	REPLY=$i 
}
_zsh_highlight_main_highlighter_highlight_dollar_quote () {
	local -a match mbegin mend
	local MATCH
	integer MBEGIN MEND
	local i j k style
	local AA
	integer c
	reply=() 
	for ((i = $1 + 2 ; i <= $#arg ; i += 1 )) do
		(( j = i + start_pos - 1 ))
		(( k = j + 1 ))
		case "$arg[$i]" in
			("'") break ;;
			("\\") style=back-dollar-quoted-argument 
				for ((c = i + 1 ; c <= $#arg ; c += 1 )) do
					[[ "$arg[$c]" != ([0-9xXuUa-fA-F]) ]] && break
				done
				AA=$arg[$i+1,$c-1] 
				if [[ "$AA" =~ "^(x|X)[0-9a-fA-F]{1,2}" || "$AA" =~ "^[0-7]{1,3}" || "$AA" =~ "^u[0-9a-fA-F]{1,4}" || "$AA" =~ "^U[0-9a-fA-F]{1,8}" ]]
				then
					(( k += $#MATCH ))
					(( i += $#MATCH ))
				else
					if (( $#arg > $i+1 )) && [[ $arg[$i+1] == [xXuU] ]]
					then
						style=unknown-token 
					fi
					(( k += 1 ))
					(( i += 1 ))
				fi ;;
			(*) continue ;;
		esac
		reply+=($j $k $style) 
	done
	if [[ $arg[i] == "'" ]]
	then
		style=dollar-quoted-argument 
	else
		(( i-- ))
		style=dollar-quoted-argument-unclosed 
	fi
	reply=($(( start_pos + $1 - 1 )) $(( start_pos + i )) $style $reply) 
	REPLY=$i 
}
_zsh_highlight_main_highlighter_highlight_double_quote () {
	local -a breaks match mbegin mend saved_reply
	local MATCH
	integer last_break=$(( start_pos + $1 - 1 )) MBEGIN MEND 
	local i j k ret style
	reply=() 
	for ((i = $1 + 1 ; i <= $#arg ; i += 1 )) do
		(( j = i + start_pos - 1 ))
		(( k = j + 1 ))
		case "$arg[$i]" in
			('"') break ;;
			('`') saved_reply=($reply) 
				_zsh_highlight_main_highlighter_highlight_backtick $i
				(( i = REPLY ))
				reply=($saved_reply $reply) 
				continue ;;
			('$') style=dollar-double-quoted-argument 
				if [[ ${arg:$i} =~ ^([A-Za-z_][A-Za-z0-9_]*|[0-9]+) ]]
				then
					(( k += $#MATCH ))
					(( i += $#MATCH ))
				elif [[ ${arg:$i} =~ ^[{]([A-Za-z_][A-Za-z0-9_]*|[0-9]+)[}] ]]
				then
					(( k += $#MATCH ))
					(( i += $#MATCH ))
				elif [[ $arg[i+1] == '$' ]]
				then
					(( k += 1 ))
					(( i += 1 ))
				elif [[ $arg[i+1] == [-#*@?] ]]
				then
					(( k += 1 ))
					(( i += 1 ))
				elif [[ $arg[i+1] == $'\x28' ]]
				then
					breaks+=($last_break $(( start_pos + i - 1 ))) 
					(( i += 2 ))
					saved_reply=($reply) 
					_zsh_highlight_main_highlighter_highlight_list $(( start_pos + i - 1 )) S $has_end $arg[i,-1]
					ret=$? 
					(( i += REPLY ))
					last_break=$(( start_pos + i )) 
					reply=($saved_reply $j $(( start_pos + i )) command-substitution-quoted $j $(( j + 2 )) command-substitution-delimiter-quoted $reply) 
					if (( ret == 0 ))
					then
						reply+=($(( start_pos + i - 1 )) $(( start_pos + i )) command-substitution-delimiter-quoted) 
					fi
					continue
				else
					continue
				fi ;;
			("\\") style=back-double-quoted-argument 
				if [[ \\\`\"\$${histchars[1]} == *$arg[$i+1]* ]]
				then
					(( k += 1 ))
					(( i += 1 ))
				else
					continue
				fi ;;
			($histchars[1]) if [[ $arg[i+1] != ('='|$'\x28'|$'\x7b'|[[:blank:]]) ]]
				then
					style=history-expansion 
				else
					continue
				fi ;;
			(*) continue ;;
		esac
		reply+=($j $k $style) 
	done
	if [[ $arg[i] == '"' ]]
	then
		style=double-quoted-argument 
	else
		(( i-- ))
		style=double-quoted-argument-unclosed 
	fi
	(( last_break != start_pos + i )) && breaks+=($last_break $(( start_pos + i ))) 
	saved_reply=($reply) 
	reply=() 
	for 1 2 in $breaks
	do
		(( $1 != $2 )) && reply+=($1 $2 $style) 
	done
	reply+=($saved_reply) 
	REPLY=$i 
}
_zsh_highlight_main_highlighter_highlight_list () {
	integer start_pos end_pos=0 buf_offset=$1 has_end=$3 
	local alias_style arg buf=$4 highlight_glob=true last_alias style 
	local in_array_assignment=false 
	integer in_alias=0 len=$#buf 
	local -a match mbegin mend list_highlights
	local -A seen_alias
	readonly parameter_name_pattern='([A-Za-z_][A-Za-z0-9_]*|[0-9]+)' 
	list_highlights=() 
	local braces_stack=$2 
	local this_word next_word=':start::start_of_pipeline:' 
	integer in_redirection
	local proc_buf="$buf" 
	local -a args
	if [[ $zsyh_user_options[interactivecomments] == on ]]
	then
		args=(${(zZ+c+)buf}) 
	else
		args=(${(z)buf}) 
	fi
	while (( $#args ))
	do
		arg=$args[1] 
		shift args
		if (( in_alias ))
		then
			(( in_alias-- ))
			if (( in_alias == 0 ))
			then
				last_alias= seen_alias=() 
				_zsh_highlight_main_add_region_highlight $start_pos $end_pos $alias_style
			fi
		fi
		if (( in_redirection == 0 ))
		then
			this_word=$next_word 
			next_word=':regular:' 
		else
			(( --in_redirection ))
		fi
		style=unknown-token 
		if [[ $this_word == *':start:'* ]]
		then
			in_array_assignment=false 
			if [[ $arg == 'noglob' ]]
			then
				highlight_glob=false 
			fi
		fi
		if (( in_alias == 0 ))
		then
			[[ "$proc_buf" = (#b)(#s)(([ $'\t']|\\$'\n')#)* ]]
			integer offset="${#match[1]}" 
			(( start_pos = end_pos + offset ))
			(( end_pos = start_pos + $#arg ))
			proc_buf="${proc_buf[offset + $#arg + 1,len]}" 
		fi
		if [[ $zsyh_user_options[interactivecomments] == on && $arg[1] == $histchars[3] ]]
		then
			if [[ $this_word == *(':regular:'|':start:')* ]]
			then
				style=comment 
			else
				style=unknown-token 
			fi
			_zsh_highlight_main_add_region_highlight $start_pos $end_pos $style
			in_redirection=1 
			continue
		fi
		if [[ $this_word == *:start:* ]] && ! (( in_redirection ))
		then
			_zsh_highlight_main__type "$arg"
			local res="$REPLY" 
			if [[ $res == "alias" ]] && [[ $last_alias != $arg ]]
			then
				if (( $+seen_alias[$arg] )) || [[ $arg == ?*=* ]]
				then
					(( in_alias == 0 )) && in_alias=1 
					_zsh_highlight_main_add_region_highlight $start_pos $end_pos unknown-token
					continue
				fi
				seen_alias[$arg]=1 
				last_alias=$arg 
				_zsh_highlight_main__resolve_alias $arg
				local -a alias_args
				if [[ $zsyh_user_options[interactivecomments] == on ]]
				then
					alias_args=(${(zZ+c+)REPLY}) 
				else
					alias_args=(${(z)REPLY}) 
				fi
				args=($alias_args $args) 
				if (( in_alias == 0 ))
				then
					alias_style=alias 
					(( in_alias += $#alias_args + 1 ))
				else
					(( in_alias += $#alias_args ))
				fi
				(( in_redirection++ ))
				continue
			else
				_zsh_highlight_main_highlighter_expand_path $arg
				arg=$REPLY 
				_zsh_highlight_main__type "$arg" 0
				res="$REPLY" 
			fi
		fi
		if _zsh_highlight_main__is_redirection $arg
		then
			if (( in_redirection == 1 ))
			then
				_zsh_highlight_main_add_region_highlight $start_pos $end_pos unknown-token
			else
				in_redirection=2 
				_zsh_highlight_main_add_region_highlight $start_pos $end_pos redirection
			fi
			continue
		elif [[ $arg == '{'${~parameter_name_pattern}'}' ]] && _zsh_highlight_main__is_redirection $args[1]
		then
			in_redirection=3 
			_zsh_highlight_main_add_region_highlight $start_pos $end_pos named-fd
			continue
		fi
		() {
			local -a match mbegin mend
			local MATCH
			integer MBEGIN MEND
			local parameter_name
			if [[ $arg[1] == '$' ]] && [[ ${arg[2]} == '{' ]] && [[ ${arg[-1]} == '}' ]]
			then
				parameter_name=${${arg:2}%?} 
			elif [[ $arg[1] == '$' ]]
			then
				parameter_name=${arg:1} 
			fi
			if [[ $res == none ]] && zmodload -e zsh/parameter && [[ ${parameter_name} =~ ^${~parameter_name_pattern}$ ]] && (( ${+parameters[(e)${MATCH}]} )) && [[ ${parameters[(e)$MATCH]} != *special* ]]
			then
				case ${(tP)MATCH} in
					(*array*|*assoc*) local -a words
						words=(${(P)MATCH}) 
						arg=${words[1]}  ;;
					(*) arg=${(P)MATCH}  ;;
				esac
				_zsh_highlight_main__type "$arg" 0
				res=$REPLY 
			fi
		}
		if (( ! in_redirection ))
		then
			if [[ $this_word == *':sudo_opt:'* ]]
			then
				if [[ -n $flags_with_argument ]] && {
						[[ -n $flags_sans_argument ]] && [[ $arg == '-'[$flags_sans_argument]#[$flags_with_argument] ]] || [[ $arg == '-'[$flags_with_argument] ]]
					}
				then
					this_word=${this_word//:start:/} 
					next_word=':sudo_arg:' 
				elif [[ -n $flags_with_argument ]] && {
						[[ -n $flags_sans_argument ]] && [[ $arg == '-'[$flags_sans_argument]#[$flags_with_argument]* ]] || [[ $arg == '-'[$flags_with_argument]* ]]
					}
				then
					this_word=${this_word//:start:/} 
					next_word+=':start:' 
					next_word+=':sudo_opt:' 
				elif [[ -n $flags_sans_argument ]] && [[ $arg == '-'[$flags_sans_argument]# ]]
				then
					this_word=:sudo_opt: 
					next_word+=':start:' 
					next_word+=':sudo_opt:' 
				elif [[ $arg == '-'* ]]
				then
					this_word=:sudo_opt: 
					next_word+=':start:' 
					next_word+=':sudo_opt:' 
					_zsh_highlight_main_add_region_highlight $start_pos $end_pos unknown-token
					continue
				else
					this_word=${this_word//:sudo_opt:/} 
				fi
			elif [[ $this_word == *':sudo_arg:'* ]]
			then
				next_word+=':sudo_opt:' 
				next_word+=':start:' 
			fi
		fi
		if [[ -n ${(M)ZSH_HIGHLIGHT_TOKENS_COMMANDSEPARATOR:#"$arg"} ]]
		then
			if _zsh_highlight_main__stack_pop T || _zsh_highlight_main__stack_pop Q
			then
				style=unknown-token 
			elif [[ $this_word == *':regular:'* ]]
			then
				style=commandseparator 
			else
				style=unknown-token 
			fi
			if [[ $arg == ';' ]] && $in_array_assignment
			then
				next_word=':regular:' 
			else
				next_word=':start:' 
				highlight_glob=true 
				if [[ $arg != '|' && $arg != '|&' ]]
				then
					next_word+=':start_of_pipeline:' 
				fi
			fi
		elif ! (( in_redirection)) && [[ $this_word == *':always:'* && $arg == 'always' ]]
		then
			style=reserved-word 
			next_word=':start:' 
		elif ! (( in_redirection)) && [[ $this_word == *':start:'* ]]
		then
			if (( ${+precommand_options[$arg]} )) && _zsh_highlight_main__is_runnable $arg
			then
				style=precommand 
				flags_with_argument=${precommand_options[$arg]%:*} 
				flags_sans_argument=${precommand_options[$arg]#*:} 
				next_word=${next_word//:regular:/} 
				next_word+=':sudo_opt:' 
				next_word+=':start:' 
			else
				case $res in
					(reserved) style=reserved-word 
						case $arg in
							($'\x7b') braces_stack='Y'"$braces_stack"  ;;
							($'\x7d') _zsh_highlight_main__stack_pop 'Y' reserved-word
								if [[ $style == reserved-word ]]
								then
									next_word+=':always:' 
								fi ;;
							($'\x5b\x5b') braces_stack='T'"$braces_stack"  ;;
							('do') braces_stack='D'"$braces_stack"  ;;
							('done') _zsh_highlight_main__stack_pop 'D' reserved-word ;;
							('if') braces_stack=':?'"$braces_stack"  ;;
							('then') _zsh_highlight_main__stack_pop ':' reserved-word ;;
							('elif') if [[ ${braces_stack[1]} == '?' ]]
								then
									braces_stack=':'"$braces_stack" 
								else
									style=unknown-token 
								fi ;;
							('else') if [[ ${braces_stack[1]} == '?' ]]
								then
									:
								else
									style=unknown-token 
								fi ;;
							('fi') _zsh_highlight_main__stack_pop '?' ;;
							('foreach') braces_stack='$'"$braces_stack"  ;;
							('end') _zsh_highlight_main__stack_pop '$' reserved-word ;;
							('repeat') in_redirection=2 
								this_word=':start::regular:'  ;;
							('!') if [[ $this_word != *':start_of_pipeline:'* ]]
								then
									style=unknown-token 
								else
									
								fi ;;
						esac ;;
					('suffix alias') style=suffix-alias  ;;
					(alias) : ;;
					(builtin) style=builtin 
						[[ $arg == $'\x5b' ]] && braces_stack='Q'"$braces_stack"  ;;
					(function) style=function  ;;
					(command) style=command  ;;
					(hashed) style=hashed-command  ;;
					(none) if _zsh_highlight_main_highlighter_check_assign
						then
							_zsh_highlight_main_add_region_highlight $start_pos $end_pos assign
							local i=$(( arg[(i)=] + 1 )) 
							if [[ $arg[i] == '(' ]]
							then
								in_array_assignment=true 
							else
								next_word+=':start:' 
								if (( i <= $#arg ))
								then
									() {
										local highlight_glob=false 
										[[ $zsyh_user_options[globassign] == on ]] && highlight_glob=true 
										_zsh_highlight_main_highlighter_highlight_argument $i
									}
								fi
							fi
							continue
						elif [[ $arg[0,1] = $histchars[0,1] ]] && (( $#arg[0,2] == 2 ))
						then
							style=history-expansion 
						elif [[ $arg[0,1] == $histchars[2,2] ]]
						then
							style=history-expansion 
						elif [[ $arg[1,2] == '((' ]]
						then
							_zsh_highlight_main_add_region_highlight $start_pos $((start_pos + 2)) reserved-word
							if [[ $arg[-2,-1] == '))' ]]
							then
								_zsh_highlight_main_add_region_highlight $((end_pos - 2)) $end_pos reserved-word
							fi
							continue
						elif [[ $arg == '()' ]]
						then
							style=reserved-word 
						elif [[ $arg == $'\x28' ]]
						then
							style=reserved-word 
							braces_stack='R'"$braces_stack" 
						elif [[ $arg == $'\x29' ]]
						then
							if _zsh_highlight_main__stack_pop 'S'
							then
								REPLY=$start_pos 
								reply=($list_highlights) 
								return 0
							fi
							_zsh_highlight_main__stack_pop 'R' reserved-word
						else
							if _zsh_highlight_main_highlighter_check_path $arg
							then
								style=$REPLY 
							else
								style=unknown-token 
							fi
						fi ;;
					(*) _zsh_highlight_main_add_region_highlight $start_pos $end_pos arg0_$res
						continue ;;
				esac
			fi
			if [[ -n ${(M)ZSH_HIGHLIGHT_TOKENS_CONTROL_FLOW:#"$arg"} ]]
			then
				next_word=':start::start_of_pipeline:' 
			fi
		else
			case $arg in
				($'\x29') if $in_array_assignment
					then
						style=assign 
						in_array_assignment=false 
						next_word+=':start:' 
					elif (( in_redirection ))
					then
						style=unknown-token 
					else
						if _zsh_highlight_main__stack_pop 'S'
						then
							REPLY=$start_pos 
							reply=($list_highlights) 
							return 0
						fi
						_zsh_highlight_main__stack_pop 'R' reserved-word
					fi ;;
				($'\x28\x29') if (( in_redirection )) || $in_array_assignment
					then
						style=unknown-token 
					else
						if [[ $zsyh_user_options[multifuncdef] == on ]] || false
						then
							next_word+=':start::start_of_pipeline:' 
						fi
						style=reserved-word 
					fi ;;
				(*) if false
					then
						
					elif [[ $arg = $'\x7d' ]] && $right_brace_is_recognised_everywhere
					then
						if (( in_redirection )) || $in_array_assignment
						then
							style=unknown-token 
						else
							_zsh_highlight_main__stack_pop 'Y' reserved-word
							if [[ $style == reserved-word ]]
							then
								next_word+=':always:' 
							fi
						fi
					elif [[ $arg[0,1] = $histchars[0,1] ]] && (( $#arg[0,2] == 2 ))
					then
						style=history-expansion 
					elif [[ $arg == $'\x5d\x5d' ]] && _zsh_highlight_main__stack_pop 'T' reserved-word
					then
						:
					elif [[ $arg == $'\x5d' ]] && _zsh_highlight_main__stack_pop 'Q' builtin
					then
						:
					else
						_zsh_highlight_main_highlighter_highlight_argument 1 $(( 1 != in_redirection ))
						continue
					fi ;;
			esac
		fi
		_zsh_highlight_main_add_region_highlight $start_pos $end_pos $style
	done
	(( in_alias == 1 )) && in_alias=0 _zsh_highlight_main_add_region_highlight $start_pos $end_pos $alias_style
	[[ "$proc_buf" = (#b)(#s)(([[:space:]]|\\$'\n')#) ]]
	REPLY=$(( end_pos + ${#match[1]} - 1 )) 
	reply=($list_highlights) 
	return $(( $#braces_stack > 0 ))
}
_zsh_highlight_main_highlighter_highlight_path_separators () {
	local pos style_pathsep
	style_pathsep=$1_pathseparator 
	reply=() 
	[[ -z "$ZSH_HIGHLIGHT_STYLES[$style_pathsep]" || "$ZSH_HIGHLIGHT_STYLES[$1]" == "$ZSH_HIGHLIGHT_STYLES[$style_pathsep]" ]] && return 0
	for ((pos = start_pos; $pos <= end_pos; pos++ )) do
		if [[ $BUFFER[pos] == / ]]
		then
			reply+=($((pos - 1)) $pos $style_pathsep) 
		fi
	done
}
_zsh_highlight_main_highlighter_highlight_single_quote () {
	local arg1=$1 i q=\' style 
	i=$arg[(ib:arg1+1:)$q] 
	reply=() 
	if [[ $zsyh_user_options[rcquotes] == on ]]
	then
		while [[ $arg[i+1] == "'" ]]
		do
			reply+=($(( start_pos + i - 1 )) $(( start_pos + i + 1 )) rc-quote) 
			(( i++ ))
			i=$arg[(ib:i+1:)$q] 
		done
	fi
	if [[ $arg[i] == "'" ]]
	then
		style=single-quoted-argument 
	else
		(( i-- ))
		style=single-quoted-argument-unclosed 
	fi
	reply=($(( start_pos + arg1 - 1 )) $(( start_pos + i )) $style $reply) 
	REPLY=$i 
}
_zsh_highlight_pattern_highlighter_loop () {
	local buf="$1" pat="$2" 
	local -a match mbegin mend
	local MATCH
	integer MBEGIN MEND
	if [[ "$buf" == (#b)(*)(${~pat})* ]]
	then
		region_highlight+=("$((mbegin[2] - 1)) $mend[2] $ZSH_HIGHLIGHT_PATTERNS[$pat]") 
		"$0" "$match[1]" "$pat"
		return $?
	fi
}
_zsh_highlight_preexec_hook () {
	typeset -g _ZSH_HIGHLIGHT_PRIOR_BUFFER= 
	typeset -gi _ZSH_HIGHLIGHT_PRIOR_CURSOR= 
}
_zsh_highlight_regexp_highlighter_loop () {
	local buf="$1" pat="$2" 
	integer OFFSET=0 
	local MATCH
	integer MBEGIN MEND
	local -a match mbegin mend
	while true
	do
		[[ "$buf" =~ "$pat" ]] || return
		region_highlight+=("$((MBEGIN - 1 + OFFSET)) $((MEND + OFFSET)) $ZSH_HIGHLIGHT_REGEXP[$pat]") 
		buf="$buf[$(($MEND+1)),-1]" 
		OFFSET=$((MEND+OFFSET)) 
	done
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_bash_complete-word () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_bash_complete-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_bash_list-choices () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_bash_list-choices -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_complete_debug () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_complete_debug -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_complete_help () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_complete_help -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_complete_tag () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_complete_tag -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_correct_filename () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_correct_filename -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_correct_word () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_correct_word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_expand_alias () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_expand_alias -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_expand_word () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_expand_word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_history-complete-newer () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_history-complete-newer -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_history-complete-older () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_history-complete-older -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_list_expansions () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_list_expansions -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_most_recent_file () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_most_recent_file -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_next_tags () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_next_tags -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-_read_comp () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-_read_comp -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-accept-and-hold () {
	_zsh_highlight_call_widget .accept-and-hold -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-accept-and-infer-next-history () {
	_zsh_highlight_call_widget .accept-and-infer-next-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-accept-and-menu-complete () {
	_zsh_highlight_call_widget .accept-and-menu-complete -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-accept-line () {
	_zsh_highlight_call_widget .accept-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-accept-line-and-down-history () {
	_zsh_highlight_call_widget .accept-line-and-down-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-accept-search () {
	_zsh_highlight_call_widget .accept-search -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-argument-base () {
	_zsh_highlight_call_widget .argument-base -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-auto-suffix-remove () {
	_zsh_highlight_call_widget .auto-suffix-remove -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-auto-suffix-retain () {
	_zsh_highlight_call_widget .auto-suffix-retain -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-backward-char () {
	_zsh_highlight_call_widget .backward-char -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-backward-delete-char () {
	_zsh_highlight_call_widget .backward-delete-char -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-backward-delete-word () {
	_zsh_highlight_call_widget .backward-delete-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-backward-kill-line () {
	_zsh_highlight_call_widget .backward-kill-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-backward-kill-word () {
	_zsh_highlight_call_widget .backward-kill-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-backward-word () {
	_zsh_highlight_call_widget .backward-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-beginning-of-buffer-or-history () {
	_zsh_highlight_call_widget .beginning-of-buffer-or-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-beginning-of-history () {
	_zsh_highlight_call_widget .beginning-of-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-beginning-of-line () {
	_zsh_highlight_call_widget .beginning-of-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-beginning-of-line-hist () {
	_zsh_highlight_call_widget .beginning-of-line-hist -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-bracketed-paste () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-bracketed-paste -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-capitalize-word () {
	_zsh_highlight_call_widget .capitalize-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-clear-screen () {
	_zsh_highlight_call_widget .clear-screen -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-complete-word () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-complete-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-copy-prev-shell-word () {
	_zsh_highlight_call_widget .copy-prev-shell-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-copy-prev-word () {
	_zsh_highlight_call_widget .copy-prev-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-copy-region-as-kill () {
	_zsh_highlight_call_widget .copy-region-as-kill -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-deactivate-region () {
	_zsh_highlight_call_widget .deactivate-region -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-delete-char () {
	_zsh_highlight_call_widget .delete-char -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-delete-char-or-list () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-delete-char-or-list -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-delete-word () {
	_zsh_highlight_call_widget .delete-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-describe-key-briefly () {
	_zsh_highlight_call_widget .describe-key-briefly -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-digit-argument () {
	_zsh_highlight_call_widget .digit-argument -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-down-case-word () {
	_zsh_highlight_call_widget .down-case-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-down-history () {
	_zsh_highlight_call_widget .down-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-down-line () {
	_zsh_highlight_call_widget .down-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-down-line-or-beginning-search () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-down-line-or-beginning-search -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-down-line-or-history () {
	_zsh_highlight_call_widget .down-line-or-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-down-line-or-search () {
	_zsh_highlight_call_widget .down-line-or-search -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-edit-command-line () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-edit-command-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-emacs-backward-word () {
	_zsh_highlight_call_widget .emacs-backward-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-emacs-forward-word () {
	_zsh_highlight_call_widget .emacs-forward-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-end-of-buffer-or-history () {
	_zsh_highlight_call_widget .end-of-buffer-or-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-end-of-history () {
	_zsh_highlight_call_widget .end-of-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-end-of-line () {
	_zsh_highlight_call_widget .end-of-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-end-of-line-hist () {
	_zsh_highlight_call_widget .end-of-line-hist -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-end-of-list () {
	_zsh_highlight_call_widget .end-of-list -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-exchange-point-and-mark () {
	_zsh_highlight_call_widget .exchange-point-and-mark -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-execute-last-named-cmd () {
	_zsh_highlight_call_widget .execute-last-named-cmd -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-execute-named-cmd () {
	_zsh_highlight_call_widget .execute-named-cmd -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-expand-cmd-path () {
	_zsh_highlight_call_widget .expand-cmd-path -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-expand-history () {
	_zsh_highlight_call_widget .expand-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-expand-or-complete () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-expand-or-complete -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-expand-or-complete-prefix () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-expand-or-complete-prefix -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-expand-or-complete-with-dots () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-expand-or-complete-with-dots -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-expand-word () {
	_zsh_highlight_call_widget .expand-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-forward-char () {
	_zsh_highlight_call_widget .forward-char -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-forward-word () {
	_zsh_highlight_call_widget .forward-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-get-line () {
	_zsh_highlight_call_widget .get-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-gosmacs-transpose-chars () {
	_zsh_highlight_call_widget .gosmacs-transpose-chars -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-history-beginning-search-backward () {
	_zsh_highlight_call_widget .history-beginning-search-backward -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-history-beginning-search-forward () {
	_zsh_highlight_call_widget .history-beginning-search-forward -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-history-incremental-pattern-search-backward () {
	_zsh_highlight_call_widget .history-incremental-pattern-search-backward -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-history-incremental-pattern-search-forward () {
	_zsh_highlight_call_widget .history-incremental-pattern-search-forward -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-history-incremental-search-backward () {
	_zsh_highlight_call_widget .history-incremental-search-backward -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-history-incremental-search-forward () {
	_zsh_highlight_call_widget .history-incremental-search-forward -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-history-search-backward () {
	_zsh_highlight_call_widget .history-search-backward -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-history-search-forward () {
	_zsh_highlight_call_widget .history-search-forward -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-infer-next-history () {
	_zsh_highlight_call_widget .infer-next-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-insert-last-word () {
	_zsh_highlight_call_widget .insert-last-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-kill-buffer () {
	_zsh_highlight_call_widget .kill-buffer -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-kill-line () {
	_zsh_highlight_call_widget .kill-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-kill-region () {
	_zsh_highlight_call_widget .kill-region -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-kill-whole-line () {
	_zsh_highlight_call_widget .kill-whole-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-kill-word () {
	_zsh_highlight_call_widget .kill-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-list-choices () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-list-choices -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-list-expand () {
	_zsh_highlight_call_widget .list-expand -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-magic-space () {
	_zsh_highlight_call_widget .magic-space -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-menu-complete () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-menu-complete -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-menu-expand-or-complete () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-menu-expand-or-complete -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-menu-select () {
	_zsh_highlight_call_widget .menu-select -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-neg-argument () {
	_zsh_highlight_call_widget .neg-argument -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-overwrite-mode () {
	_zsh_highlight_call_widget .overwrite-mode -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-pound-insert () {
	_zsh_highlight_call_widget .pound-insert -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-push-input () {
	_zsh_highlight_call_widget .push-input -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-push-line () {
	_zsh_highlight_call_widget .push-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-push-line-or-edit () {
	_zsh_highlight_call_widget .push-line-or-edit -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-put-replace-selection () {
	_zsh_highlight_call_widget .put-replace-selection -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-quote-line () {
	_zsh_highlight_call_widget .quote-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-quote-region () {
	_zsh_highlight_call_widget .quote-region -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-quoted-insert () {
	_zsh_highlight_call_widget .quoted-insert -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-read-command () {
	_zsh_highlight_call_widget .read-command -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-recursive-edit () {
	_zsh_highlight_call_widget .recursive-edit -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-redisplay () {
	_zsh_highlight_call_widget .redisplay -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-redo () {
	_zsh_highlight_call_widget .redo -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-reset-prompt () {
	_zsh_highlight_call_widget .reset-prompt -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-reverse-menu-complete () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-reverse-menu-complete -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-select-a-blank-word () {
	_zsh_highlight_call_widget .select-a-blank-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-select-a-shell-word () {
	_zsh_highlight_call_widget .select-a-shell-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-select-a-word () {
	_zsh_highlight_call_widget .select-a-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-select-in-blank-word () {
	_zsh_highlight_call_widget .select-in-blank-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-select-in-shell-word () {
	_zsh_highlight_call_widget .select-in-shell-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-select-in-word () {
	_zsh_highlight_call_widget .select-in-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-self-insert () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-self-insert -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-self-insert-unmeta () {
	_zsh_highlight_call_widget .self-insert-unmeta -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-send-break () {
	_zsh_highlight_call_widget .send-break -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-set-mark-command () {
	_zsh_highlight_call_widget .set-mark-command -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-spell-word () {
	_zsh_highlight_call_widget .spell-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-split-undo () {
	_zsh_highlight_call_widget .split-undo -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-transpose-chars () {
	_zsh_highlight_call_widget .transpose-chars -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-transpose-words () {
	_zsh_highlight_call_widget .transpose-words -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-undefined-key () {
	_zsh_highlight_call_widget .undefined-key -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-undo () {
	_zsh_highlight_call_widget .undo -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-universal-argument () {
	_zsh_highlight_call_widget .universal-argument -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-up-case-word () {
	_zsh_highlight_call_widget .up-case-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-up-history () {
	_zsh_highlight_call_widget .up-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-up-line () {
	_zsh_highlight_call_widget .up-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-up-line-or-beginning-search () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-up-line-or-beginning-search -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-up-line-or-history () {
	_zsh_highlight_call_widget .up-line-or-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-up-line-or-search () {
	_zsh_highlight_call_widget .up-line-or-search -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-add-eol () {
	_zsh_highlight_call_widget .vi-add-eol -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-add-next () {
	_zsh_highlight_call_widget .vi-add-next -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-backward-blank-word () {
	_zsh_highlight_call_widget .vi-backward-blank-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-backward-blank-word-end () {
	_zsh_highlight_call_widget .vi-backward-blank-word-end -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-backward-char () {
	_zsh_highlight_call_widget .vi-backward-char -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-backward-delete-char () {
	_zsh_highlight_call_widget .vi-backward-delete-char -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-backward-kill-word () {
	_zsh_highlight_call_widget .vi-backward-kill-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-backward-word () {
	_zsh_highlight_call_widget .vi-backward-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-backward-word-end () {
	_zsh_highlight_call_widget .vi-backward-word-end -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-beginning-of-line () {
	_zsh_highlight_call_widget .vi-beginning-of-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-caps-lock-panic () {
	_zsh_highlight_call_widget .vi-caps-lock-panic -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-change () {
	_zsh_highlight_call_widget .vi-change -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-change-eol () {
	_zsh_highlight_call_widget .vi-change-eol -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-change-whole-line () {
	_zsh_highlight_call_widget .vi-change-whole-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-cmd-mode () {
	_zsh_highlight_call_widget .vi-cmd-mode -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-delete () {
	_zsh_highlight_call_widget .vi-delete -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-delete-char () {
	_zsh_highlight_call_widget .vi-delete-char -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-digit-or-beginning-of-line () {
	_zsh_highlight_call_widget .vi-digit-or-beginning-of-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-down-case () {
	_zsh_highlight_call_widget .vi-down-case -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-down-line-or-history () {
	_zsh_highlight_call_widget .vi-down-line-or-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-end-of-line () {
	_zsh_highlight_call_widget .vi-end-of-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-fetch-history () {
	_zsh_highlight_call_widget .vi-fetch-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-find-next-char () {
	_zsh_highlight_call_widget .vi-find-next-char -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-find-next-char-skip () {
	_zsh_highlight_call_widget .vi-find-next-char-skip -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-find-prev-char () {
	_zsh_highlight_call_widget .vi-find-prev-char -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-find-prev-char-skip () {
	_zsh_highlight_call_widget .vi-find-prev-char-skip -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-first-non-blank () {
	_zsh_highlight_call_widget .vi-first-non-blank -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-forward-blank-word () {
	_zsh_highlight_call_widget .vi-forward-blank-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-forward-blank-word-end () {
	_zsh_highlight_call_widget .vi-forward-blank-word-end -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-forward-char () {
	_zsh_highlight_call_widget .vi-forward-char -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-forward-word () {
	_zsh_highlight_call_widget .vi-forward-word -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-forward-word-end () {
	_zsh_highlight_call_widget .vi-forward-word-end -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-goto-column () {
	_zsh_highlight_call_widget .vi-goto-column -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-goto-mark () {
	_zsh_highlight_call_widget .vi-goto-mark -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-goto-mark-line () {
	_zsh_highlight_call_widget .vi-goto-mark-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-history-search-backward () {
	_zsh_highlight_call_widget .vi-history-search-backward -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-history-search-forward () {
	_zsh_highlight_call_widget .vi-history-search-forward -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-indent () {
	_zsh_highlight_call_widget .vi-indent -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-insert () {
	_zsh_highlight_call_widget .vi-insert -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-insert-bol () {
	_zsh_highlight_call_widget .vi-insert-bol -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-join () {
	_zsh_highlight_call_widget .vi-join -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-kill-eol () {
	_zsh_highlight_call_widget .vi-kill-eol -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-kill-line () {
	_zsh_highlight_call_widget .vi-kill-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-match-bracket () {
	_zsh_highlight_call_widget .vi-match-bracket -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-open-line-above () {
	_zsh_highlight_call_widget .vi-open-line-above -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-open-line-below () {
	_zsh_highlight_call_widget .vi-open-line-below -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-oper-swap-case () {
	_zsh_highlight_call_widget .vi-oper-swap-case -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-pound-insert () {
	_zsh_highlight_call_widget .vi-pound-insert -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-put-after () {
	_zsh_highlight_call_widget .vi-put-after -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-put-before () {
	_zsh_highlight_call_widget .vi-put-before -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-quoted-insert () {
	_zsh_highlight_call_widget .vi-quoted-insert -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-repeat-change () {
	_zsh_highlight_call_widget .vi-repeat-change -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-repeat-find () {
	_zsh_highlight_call_widget .vi-repeat-find -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-repeat-search () {
	_zsh_highlight_call_widget .vi-repeat-search -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-replace () {
	_zsh_highlight_call_widget .vi-replace -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-replace-chars () {
	_zsh_highlight_call_widget .vi-replace-chars -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-rev-repeat-find () {
	_zsh_highlight_call_widget .vi-rev-repeat-find -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-rev-repeat-search () {
	_zsh_highlight_call_widget .vi-rev-repeat-search -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-set-buffer () {
	_zsh_highlight_call_widget .vi-set-buffer -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-set-mark () {
	_zsh_highlight_call_widget .vi-set-mark -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-substitute () {
	_zsh_highlight_call_widget .vi-substitute -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-swap-case () {
	_zsh_highlight_call_widget .vi-swap-case -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-undo-change () {
	_zsh_highlight_call_widget .vi-undo-change -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-unindent () {
	_zsh_highlight_call_widget .vi-unindent -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-up-case () {
	_zsh_highlight_call_widget .vi-up-case -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-up-line-or-history () {
	_zsh_highlight_call_widget .vi-up-line-or-history -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-yank () {
	_zsh_highlight_call_widget .vi-yank -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-yank-eol () {
	_zsh_highlight_call_widget .vi-yank-eol -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-vi-yank-whole-line () {
	_zsh_highlight_call_widget .vi-yank-whole-line -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-visual-line-mode () {
	_zsh_highlight_call_widget .visual-line-mode -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-visual-mode () {
	_zsh_highlight_call_widget .visual-mode -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-what-cursor-position () {
	_zsh_highlight_call_widget .what-cursor-position -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-where-is () {
	_zsh_highlight_call_widget .where-is -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-zle-line-finish () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-zle-line-finish -- "$@"
}
_zsh_highlight_widget_orig-s0.0000030000-r9640-zle-line-init () {
	_zsh_highlight_call_widget orig-s0.0000030000-r9640-zle-line-init -- "$@"
}
_zsh_highlight_widget_zle-isearch-update () {
	:
	_zsh_highlight
}
_zsocket () {
	# undefined
	builtin autoload -XUz
}
_zstyle () {
	# undefined
	builtin autoload -XUz
}
_ztodo () {
	# undefined
	builtin autoload -XUz
}
_zypper () {
	# undefined
	builtin autoload -XUz
}
add-zsh-hook () {
	emulate -L zsh
	local -a hooktypes
	hooktypes=(chpwd precmd preexec periodic zshaddhistory zshexit zsh_directory_name) 
	local usage="Usage: add-zsh-hook hook function\nValid hooks are:\n  $hooktypes" 
	local opt
	local -a autoopts
	integer del list help
	while getopts "dDhLUzk" opt
	do
		case $opt in
			(d) del=1  ;;
			(D) del=2  ;;
			(h) help=1  ;;
			(L) list=1  ;;
			([Uzk]) autoopts+=(-$opt)  ;;
			(*) return 1 ;;
		esac
	done
	shift $(( OPTIND - 1 ))
	if (( list ))
	then
		typeset -mp "(${1:-${(@j:|:)hooktypes}})_functions"
		return $?
	elif (( help || $# != 2 || ${hooktypes[(I)$1]} == 0 ))
	then
		print -u$(( 2 - help )) $usage
		return $(( 1 - help ))
	fi
	local hook="${1}_functions" 
	local fn="$2" 
	if (( del ))
	then
		if (( ${(P)+hook} ))
		then
			if (( del == 2 ))
			then
				set -A $hook ${(P)hook:#${~fn}}
			else
				set -A $hook ${(P)hook:#$fn}
			fi
			if (( ! ${(P)#hook} ))
			then
				unset $hook
			fi
		fi
	else
		if (( ${(P)+hook} ))
		then
			if (( ${${(P)hook}[(I)$fn]} == 0 ))
			then
				typeset -ga $hook
				set -A $hook ${(P)hook} $fn
			fi
		else
			typeset -ga $hook
			set -A $hook $fn
		fi
		autoload $autoopts -- $fn
	fi
}
alias_value () {
	(( $+aliases[$1] )) && echo $aliases[$1]
}
backward-extend-paste () {
	emulate -L zsh
	integer bep_mark=$MARK bep_region=$REGION_ACTIVE 
	if (( REGION_ACTIVE && MARK < CURSOR ))
	then
		zle .exchange-point-and-mark
	fi
	if (( CURSOR ))
	then
		local -a bep_words=(${(z)LBUFFER}) 
		if [[ -n $bep_words[-1] && $LBUFFER = *$bep_words[-1] ]]
		then
			PASTED=$bep_words[-1]$PASTED 
			LBUFFER=${LBUFFER%${bep_words[-1]}} 
		fi
	fi
	if (( MARK > bep_mark ))
	then
		zle .exchange-point-and-mark
	fi
	REGION_ACTIVE=$bep_region 
}
bracketed-paste-magic () {
	if [[ "$LASTWIDGET" = *vi-set-buffer ]]
	then
		zle .bracketed-paste
		return
	else
		local PASTED REPLY
		zle .bracketed-paste PASTED
	fi
	local bpm_emulate="$(emulate)" bpm_opts="$-" 
	emulate -L zsh
	local -a bpm_hooks bpm_inactive
	local bpm_func bpm_active bpm_keymap=$KEYMAP 
	if zstyle -a :bracketed-paste-magic paste-init bpm_hooks
	then
		for bpm_func in $bpm_hooks
		do
			if (( $+functions[$bpm_func] ))
			then
				() {
					emulate -L $bpm_emulate
					set -$bpm_opts
					$bpm_func || break
				}
			fi
		done
	fi
	zstyle -a :bracketed-paste-magic inactive-keys bpm_inactive
	if zstyle -s :bracketed-paste-magic active-widgets bpm_active '|'
	then
		integer bpm_mark=$MARK bpm_region=$REGION_ACTIVE 
		integer bpm_numeric=${NUMERIC:-1} 
		integer bpm_limit=$UNDO_LIMIT_NO bpm_undo=$UNDO_CHANGE_NO 
		zle .split-undo
		UNDO_LIMIT_NO=$UNDO_CHANGE_NO 
		BUFFER= 
		CURSOR=1 
		fc -p -a /dev/null 0 0
		if [[ $bmp_keymap = vicmd ]]
		then
			zle -K viins
		fi
		NUMERIC=1 
		zle -U - $PASTED
		while [[ -n $PASTED ]] && zle .read-command
		do
			PASTED=${PASTED#$KEYS} 
			if [[ $KEYS = ${(~j:|:)${(b)bpm_inactive}} ]]
			then
				zle .self-insert
			else
				case $REPLY in
					(${~bpm_active}) () {
							emulate -L $bpm_emulate
							set -$bpm_opts
							zle $REPLY -w
						} ;;
					(*) zle .self-insert ;;
				esac
			fi
		done
		PASTED=$BUFFER 
		zle -K $bpm_keymap
		fc -P
		MARK=$bpm_mark 
		REGION_ACTIVE=$bpm_region 
		NUMERIC=$bpm_numeric 
		zle .undo $bpm_undo
		UNDO_LIMIT_NO=$bpm_limit 
	fi
	if zstyle -a :bracketed-paste-magic paste-finish bpm_hooks
	then
		for bpm_func in $bpm_hooks
		do
			if (( $+functions[$bpm_func] ))
			then
				() {
					emulate -L $bpm_emulate
					set -$bpm_opts
					$bpm_func || break
				}
			fi
		done
	fi
	zle -U - $PASTED$'\e[201~'
	zle .bracketed-paste -- "$@"
	zle .split-undo
	if [[ -z $zle_highlight || -n ${(M)zle_highlight:#paste:*} ]]
	then
		zle -R
		zle .read-command && zle -U - $KEYS
	fi
}
bzr_prompt_info () {
	BZR_CB=`bzr nick 2> /dev/null | grep -v "ERROR" | cut -d ":" -f2 | awk -F / '{print "bzr::"$1}'` 
	if [ -n "$BZR_CB" ]
	then
		BZR_DIRTY="" 
		[[ -n `bzr status` ]] && BZR_DIRTY=" %{$fg[red]%} * %{$fg[green]%}" 
		echo "$ZSH_THEME_SCM_PROMPT_PREFIX$BZR_CB$BZR_DIRTY$ZSH_THEME_GIT_PROMPT_SUFFIX"
	fi
}
cdf () {
	cd "$(pfd)"
}
chruby_prompt_info () {
	return 1
}
clipcopy () {
	emulate -L zsh
	local file=$1 
	if [[ $OSTYPE == darwin* ]]
	then
		if [[ -z $file ]]
		then
			pbcopy
		else
			cat $file | pbcopy
		fi
	elif [[ $OSTYPE == cygwin* ]]
	then
		if [[ -z $file ]]
		then
			cat > /dev/clipboard
		else
			cat $file > /dev/clipboard
		fi
	else
		if (( $+commands[xclip] ))
		then
			if [[ -z $file ]]
			then
				xclip -in -selection clipboard
			else
				xclip -in -selection clipboard $file
			fi
		elif (( $+commands[xsel] ))
		then
			if [[ -z $file ]]
			then
				xsel --clipboard --input
			else
				cat "$file" | xsel --clipboard --input
			fi
		else
			print "clipcopy: Platform $OSTYPE not supported or xclip/xsel not installed" >&2
			return 1
		fi
	fi
}
clippaste () {
	emulate -L zsh
	if [[ $OSTYPE == darwin* ]]
	then
		pbpaste
	elif [[ $OSTYPE == cygwin* ]]
	then
		cat /dev/clipboard
	else
		if (( $+commands[xclip] ))
		then
			xclip -out -selection clipboard
		elif (( $+commands[xsel] ))
		then
			xsel --clipboard --output
		else
			print "clipcopy: Platform $OSTYPE not supported or xclip/xsel not installed" >&2
			return 1
		fi
	fi
}
colors () {
	emulate -L zsh
	typeset -Ag color colour
	color=(00 none 01 bold 02 faint 22 normal 03 standout 23 no-standout 04 underline 24 no-underline 05 blink 25 no-blink 07 reverse 27 no-reverse 08 conceal 28 no-conceal 30 black 40 bg-black 31 red 41 bg-red 32 green 42 bg-green 33 yellow 43 bg-yellow 34 blue 44 bg-blue 35 magenta 45 bg-magenta 36 cyan 46 bg-cyan 37 white 47 bg-white 39 default 49 bg-default) 
	local k
	for k in ${(k)color}
	do
		color[${color[$k]}]=$k 
	done
	for k in ${color[(I)3?]}
	do
		color[fg-${color[$k]}]=$k 
	done
	color[grey]=${color[black]} 
	color[fg-grey]=${color[grey]} 
	color[bg-grey]=${color[bg-black]} 
	colour=(${(kv)color}) 
	local lc=$'\e[' rc=m 
	typeset -Hg reset_color bold_color
	reset_color="$lc${color[none]}$rc" 
	bold_color="$lc${color[bold]}$rc" 
	typeset -AHg fg fg_bold fg_no_bold
	for k in ${(k)color[(I)fg-*]}
	do
		fg[${k#fg-}]="$lc${color[$k]}$rc" 
		fg_bold[${k#fg-}]="$lc${color[bold]};${color[$k]}$rc" 
		fg_no_bold[${k#fg-}]="$lc${color[normal]};${color[$k]}$rc" 
	done
	typeset -AHg bg bg_bold bg_no_bold
	for k in ${(k)color[(I)bg-*]}
	do
		bg[${k#bg-}]="$lc${color[$k]}$rc" 
		bg_bold[${k#bg-}]="$lc${color[bold]};${color[$k]}$rc" 
		bg_no_bold[${k#bg-}]="$lc${color[normal]};${color[$k]}$rc" 
	done
}
compaudit () {
	# undefined
	builtin autoload -XUz
}
compdef () {
	local opt autol type func delete eval new i ret=0 cmd svc 
	local -a match mbegin mend
	emulate -L zsh
	setopt extendedglob
	if (( ! $# ))
	then
		print -u2 "$0: I need arguments"
		return 1
	fi
	while getopts "anpPkKde" opt
	do
		case "$opt" in
			(a) autol=yes  ;;
			(n) new=yes  ;;
			([pPkK]) if [[ -n "$type" ]]
				then
					print -u2 "$0: type already set to $type"
					return 1
				fi
				if [[ "$opt" = p ]]
				then
					type=pattern 
				elif [[ "$opt" = P ]]
				then
					type=postpattern 
				elif [[ "$opt" = K ]]
				then
					type=widgetkey 
				else
					type=key 
				fi ;;
			(d) delete=yes  ;;
			(e) eval=yes  ;;
		esac
	done
	shift OPTIND-1
	if (( ! $# ))
	then
		print -u2 "$0: I need arguments"
		return 1
	fi
	if [[ -z "$delete" ]]
	then
		if [[ -z "$eval" ]] && [[ "$1" = *\=* ]]
		then
			while (( $# ))
			do
				if [[ "$1" = *\=* ]]
				then
					cmd="${1%%\=*}" 
					svc="${1#*\=}" 
					func="$_comps[${_services[(r)$svc]:-$svc}]" 
					[[ -n ${_services[$svc]} ]] && svc=${_services[$svc]} 
					[[ -z "$func" ]] && func="${${_patcomps[(K)$svc][1]}:-${_postpatcomps[(K)$svc][1]}}" 
					if [[ -n "$func" ]]
					then
						_comps[$cmd]="$func" 
						_services[$cmd]="$svc" 
					else
						print -u2 "$0: unknown command or service: $svc"
						ret=1 
					fi
				else
					print -u2 "$0: invalid argument: $1"
					ret=1 
				fi
				shift
			done
			return ret
		fi
		func="$1" 
		[[ -n "$autol" ]] && autoload -Uz "$func"
		shift
		case "$type" in
			(widgetkey) while [[ -n $1 ]]
				do
					if [[ $# -lt 3 ]]
					then
						print -u2 "$0: compdef -K requires <widget> <comp-widget> <key>"
						return 1
					fi
					[[ $1 = _* ]] || 1="_$1" 
					[[ $2 = .* ]] || 2=".$2" 
					[[ $2 = .menu-select ]] && zmodload -i zsh/complist
					zle -C "$1" "$2" "$func"
					if [[ -n $new ]]
					then
						bindkey "$3" | IFS=$' \t' read -A opt
						[[ $opt[-1] = undefined-key ]] && bindkey "$3" "$1"
					else
						bindkey "$3" "$1"
					fi
					shift 3
				done ;;
			(key) if [[ $# -lt 2 ]]
				then
					print -u2 "$0: missing keys"
					return 1
				fi
				if [[ $1 = .* ]]
				then
					[[ $1 = .menu-select ]] && zmodload -i zsh/complist
					zle -C "$func" "$1" "$func"
				else
					[[ $1 = menu-select ]] && zmodload -i zsh/complist
					zle -C "$func" ".$1" "$func"
				fi
				shift
				for i
				do
					if [[ -n $new ]]
					then
						bindkey "$i" | IFS=$' \t' read -A opt
						[[ $opt[-1] = undefined-key ]] || continue
					fi
					bindkey "$i" "$func"
				done ;;
			(*) while (( $# ))
				do
					if [[ "$1" = -N ]]
					then
						type=normal 
					elif [[ "$1" = -p ]]
					then
						type=pattern 
					elif [[ "$1" = -P ]]
					then
						type=postpattern 
					else
						case "$type" in
							(pattern) if [[ $1 = (#b)(*)=(*) ]]
								then
									_patcomps[$match[1]]="=$match[2]=$func" 
								else
									_patcomps[$1]="$func" 
								fi ;;
							(postpattern) if [[ $1 = (#b)(*)=(*) ]]
								then
									_postpatcomps[$match[1]]="=$match[2]=$func" 
								else
									_postpatcomps[$1]="$func" 
								fi ;;
							(*) if [[ "$1" = *\=* ]]
								then
									cmd="${1%%\=*}" 
									svc=yes 
								else
									cmd="$1" 
									svc= 
								fi
								if [[ -z "$new" || -z "${_comps[$1]}" ]]
								then
									_comps[$cmd]="$func" 
									[[ -n "$svc" ]] && _services[$cmd]="${1#*\=}" 
								fi ;;
						esac
					fi
					shift
				done ;;
		esac
	else
		case "$type" in
			(pattern) unset "_patcomps[$^@]" ;;
			(postpattern) unset "_postpatcomps[$^@]" ;;
			(key) print -u2 "$0: cannot restore key bindings"
				return 1 ;;
			(*) unset "_comps[$^@]" ;;
		esac
	fi
}
compdump () {
	# undefined
	builtin autoload -XUz
}
compinit () {
	# undefined
	builtin autoload -XUz
}
compinstall () {
	# undefined
	builtin autoload -XUz
}
current_branch () {
	git_current_branch
}
d () {
	if [[ -n $1 ]]
	then
		dirs "$@"
	else
		dirs -v | head -10
	fi
}
default () {
	(( $+parameters[$1] )) && return 0
	typeset -g "$1"="$2" && return 3
}
down-line-or-beginning-search () {
	emulate -L zsh
	typeset -g __searching __savecursor
	if [[ ${+NUMERIC} -eq 0 && ( $LASTWIDGET = $__searching || $RBUFFER != *$'\n'* ) ]]
	then
		[[ $LASTWIDGET = $__searching ]] && CURSOR=$__savecursor 
		__searching=$WIDGET 
		__savecursor=$CURSOR 
		if zle .history-beginning-search-forward
		then
			[[ $RBUFFER = *$'\n'* ]] || zstyle -T ':zle:down-line-or-beginning-search' leave-cursor && zle .end-of-line
			return
		fi
		[[ $RBUFFER = *$'\n'* ]] || return
	fi
	__searching='' 
	zle .down-line-or-history
}
download_brew_packages () {
	brew update
	echo -e "
    ---------------
    Downloading Brew packages from `brew` file
    ---------------
    "
	brew install $(cat brew)
}
edit-command-line () {
	# undefined
	builtin autoload -XU
}
env_default () {
	(( ${${(@f):-$(typeset +xg)}[(I)$1]} )) && return 0
	export "$1=$2" && return 3
}
expand-or-complete-with-dots () {
	[[ -n "$terminfo[rmam]" && -n "$terminfo[smam]" ]] && echoti rmam
	print -Pn "%{%F{red}......%f%}"
	[[ -n "$terminfo[rmam]" && -n "$terminfo[smam]" ]] && echoti smam
	zle expand-or-complete
	zle redisplay
}
file_exists_at_url () {
	(
		if [[ -n "${1:-}" ]]
		then
			unset curl
			file_exists_at_url_command "$1" --insecure || {
				\typeset __ret=$?
				case ${__ret} in
					(60) file_exists_at_url_command "$1" || return $?
						return 0 ;;
					(*) return ${__ret} ;;
				esac
			}
		else
			rvm_warn "Warning: URL was not passed to file_exists_at_url"
			return 1
		fi
	)
}
file_exists_at_url_command () {
	__rvm_curl --silent --insecure --location --list-only --max-time ${rvm_max_time_flag:-5} --head "$@" 2>&1 | __rvm_grep -E 'HTTP/[0-9\.]+ 200' > /dev/null 2>&1 || {
		\typeset __ret=$?
		case ${__ret} in
			(28) rvm_warn "RVM was not able to check existence of remote files with timeout of ${rvm_max_time_flag:-3} seconds
you can increase the timeout by setting it in ~/.rvmrc => rvm_max_time_flag=10" ;;
		esac
		return ${__ret}
	}
}
func () {
	functions >> .functions
}
gdv () {
	git diff -w "$@" | view -
}
gem () {
	\typeset result
	(
		\typeset rvmrc
		rvm_rvmrc_files=("/etc/rvmrc" "$HOME/.rvmrc") 
		if [[ -n "${rvm_prefix:-}" ]] && ! [[ "$HOME/.rvmrc" -ef "${rvm_prefix}/.rvmrc" ]]
		then
			rvm_rvmrc_files+=("${rvm_prefix}/.rvmrc") 
		fi
		for rvmrc in "${rvm_rvmrc_files[@]}"
		do
			[[ -s "${rvmrc}" ]] && source "${rvmrc}" || true
		done
		unset rvm_rvmrc_files
		command gem "$@"
	) || result=$? 
	hash -r
	return ${result:-0}
}
gem_install () {
	\typeset gem_name gem_version version_check
	gem_version="" 
	__rvm_parse_gems_args "$@"
	if [[ -z "${gem_version}" ]]
	then
		__rvm_db "gem_${gem_name}_version" "gem_version"
	fi
	if (( ${rvm_force_flag:-0} == 0 )) && is_gem_installed
	then
		rvm_log "gem ${gem_name} ${gem_version:-} is already installed"
		return 0
	else
		gem_install_force || return $?
	fi
	true
}
gem_install_force () {
	\typeset __available_gem
	\typeset -a install_params
	install_params=() 
	__available_gem="$( __rvm_ls -v1 "${rvm_path}/gem-cache"/${gem_name}-${version_check}.gem 2>/dev/null | tail -n 1 )" 
	if [[ -n "${__available_gem}" ]]
	then
		install_params+=(--local) 
	elif [[ -n "${gem_version}" ]]
	then
		install_params+=(-v "${gem_version}") 
	fi
	if __rvm_version_compare "$(\command \gem --version)" -ge 2.2
	then
		install_params+=(--no-document) 
	else
		install_params+=(--no-ri --no-rdoc) 
	fi
	for __gem_option in ${rvm_gem_options}
	do
		case "${__gem_option}" in
			(--no-ri|--no-rdoc|--no-document)  ;;
			(*) install_params+=("${__gem_option}")  ;;
		esac
	done
	__rvm_log_command "gem.install.${gem_name}${gem_version:+-}${gem_version:-}" "installing gem ${__available_gem:-${gem_name}} ${install_params[*]}" \command \gem install "${__available_gem:-${gem_name}}" "${install_params[@]}" || return $?
}
gemset_create () {
	\typeset gem_home gemset gemsets prefix
	[[ -n "$rvm_ruby_string" ]] || __rvm_select
	prefix="${rvm_ruby_gem_home%%${rvm_gemset_separator:-"@"}*}" 
	for gemset in "$@"
	do
		if [[ -z "$rvm_ruby_string" || "$rvm_ruby_string" == "system" ]]
		then
			rvm_error "Can not create gemset when using system ruby.  Try 'rvm use <some ruby>' first."
			return 1
		elif [[ "$gemset" == *"${rvm_gemset_separator:-"@"}"* ]]
		then
			rvm_error "Can not create gemset '$gemset', it contains a \"${rvm_gemset_separator:-"@"}\"."
			return 2
		elif [[ "$gemset" == *"${rvm_gemset_separator:-"@"}" ]]
		then
			rvm_error "Can not create gemset '$gemset', Missing name. "
			return 3
		fi
		gem_home="${prefix}${gemset:+${rvm_gemset_separator:-"@"}}${gemset}" 
		__rvm_remove_broken_symlinks "$gem_home"
		[[ -d "$gem_home/bin" ]] || mkdir -p "$gem_home/bin"
		if [[ ! -d "$gem_home/bin" ]]
		then
			rvm_error "Can not create gemset '$gemset', permissions problem? "
			return 4
		fi
		: rvm_gems_cache_path:${rvm_gems_cache_path:=${rvm_gems_path:-"$rvm_path/gems"}/cache}
		if __rvm_using_gemset_globalcache
		then
			if [[ -d "$gem_home/cache" && ! -L "$gem_home/cache" ]]
			then
				\command \mv -n "$gem_home/cache"/*.gem "$rvm_gems_cache_path/" 2> /dev/null
			fi
			__rvm_rm_rf "$gem_home/cache"
			ln -fs "$rvm_gems_cache_path" "$gem_home/cache"
		else
			__rvm_remove_broken_symlinks "$gem_home/cache"
			mkdir -p "$gem_home/cache"
		fi
		rvm_log "$rvm_ruby_string - #gemset created $gem_home"
		if (( ${rvm_skip_gemsets_flag:-0} == 0 ))
		then
			__rvm_with "${rvm_ruby_string}${gemset:+@}${gemset}" gemset_initial ${gemset:-default}
		fi
	done
	if (( ${rvm_skip_gemsets_flag:-0} != 0 ))
	then
		rvm_log "Skipped importing default gemsets"
	fi
}
gemset_import () {
	\typeset __prefix rvm_file_name
	unset -f gem
	__rvm_select
	__prefix="$1" 
	if [[ -n "${2:-}" ]]
	then
		rvm_file_name="${2%.gems*}.gems" 
	else
		\typeset -a gem_file_names
		gem_file_names=("${rvm_gemset_name}.gems" "default.gems" "system.gems" ".gems") 
		__rvm_find_first_file rvm_file_name "${gem_file_names[@]}" || {
			rvm_error "No *.gems file found."
			return 1
		}
	fi
	[[ -d "$rvm_ruby_gem_home/specifications/" ]] || mkdir -p "$rvm_ruby_gem_home/specifications/"
	[[ -d "$rvm_gems_cache_path" ]] || mkdir -p "$rvm_gems_cache_path"
	\typeset -a lines
	lines=() 
	if [[ -s "$rvm_file_name" ]]
	then
		__rvm_read_lines lines "${rvm_file_name}"
		__rvm_lines_without_comments
	fi
	rvm_debug "lines from ${rvm_file_name}: ${lines[*]}"
	if [[ -n "${3:-}" ]]
	then
		__rvm_lines_without_gems
		__rvm_lines_with_gems "${3}"
		rvm_debug "recalculated lines($3): ${lines[*]}"
	fi
	if (( ${#lines[@]} ))
	then
		__rvm_log_command "gemsets.import${3:+.}${3:-}" "${__prefix} $rvm_file_name" gemset_import_list "${lines[@]}"
	else
		rvm_log "${__prefix}file $rvm_file_name evaluated to empty gem list"
	fi
}
gemset_import_list () {
	case "${rvm_ruby_string}" in
		(*jruby*) \command \gem install "$@" ;;
		(*) \typeset line
			for line
			do
				gem_install $line || rvm_error "there was an error installing gem $line"
			done ;;
	esac
}
gemset_initial () {
	\typeset gemsets gemset _iterator paths _jruby_opts
	_jruby_opts=$JRUBY_OPTS 
	export JRUBY_OPTS="${JRUBY_OPTS} --dev" 
	true ${rvm_gemsets_path:="$rvm_path/gemsets"}
	[[ -d "$rvm_gems_path/${rvm_ruby_string}/cache" ]] || mkdir -p "$rvm_gems_path/${rvm_ruby_string}/cache" 2> /dev/null
	__rvm_ensure_has_environment_files
	paths=($( __rvm_ruby_string_paths_under "$rvm_gemsets_path" | sort -r )) 
	for _iterator in "${paths[@]}"
	do
		if [[ -f "${_iterator}/$1.gems" ]]
		then
			gemset_import "$rvm_ruby_string - #importing gemset" "${_iterator}/$1.gems" "$1"
			break
		else
			rvm_debug "$rvm_ruby_string - #gemset definition does not exist ${_iterator}/$1.gems"
		fi
	done
	__rvm_log_command "gemset.wrappers.$1" "$rvm_ruby_string - #generating ${1} wrappers" run_gem_wrappers regenerate 2> /dev/null || true
	export JRUBY_OPTS=${_jruby_opts} 
}
gemset_pristine () {
	if (
			unset -f gem
			builtin command -v gem > /dev/null
		)
	then
		\typeset _gem _version _platforms
		\typeset -a _failed _pristine_command
		_failed=() 
		_pristine_command=(\command \gem pristine) 
		if __rvm_version_compare "$(\command \gem --version)" -ge 2.2.0
		then
			_pristine_command+=(--extensions) 
		fi
		rvm_log "Restoring gems to pristine condition..."
		while read _gem _version _platforms
		do
			printf "%b" "${_gem}-${_version} "
			"${_pristine_command[@]}" "${_gem}" --version "${_version}" > /dev/null || _failed+=("${_gem} --version ${_version}") 
		done <<< "$(
      GEM_PATH="$GEM_HOME" __rvm_list_gems \
        "${pristine_gems_filter:-"! gem.executables.empty? || ! gem.extensions.empty?"}"
    )"
		if (( ${#_failed[@]} > 0 ))
		then
			rvm_error "\n'${_pristine_command[*]} ${_failed[*]}' failed, you need to fix these gems manually."
			return 1
		else
			rvm_log "\nfinished."
		fi
	else
		rvm_error "'gem' command not found in PATH."
		return 1
	fi
}
gemset_reset_env () {
	(
		export rvm_internal_use_flag=1 
		export rvm_use_flag=0 
		__rvm_use "${1:-}"
		__rvm_ensure_has_environment_files && run_gem_wrappers regenerate || return $?
	)
}
getent () {
	if [[ $1 = hosts ]]
	then
		sed 's/#.*//' /etc/$1 | grep -w $2
	elif [[ $2 = <-> ]]
	then
		grep ":$2:[^:]*$" /etc/$1
	else
		grep "^$2:" /etc/$1
	fi
}
ggf () {
	[[ "$#" != 1 ]] && local b="$(git_current_branch)" 
	git push --force origin "${b:=$1}"
}
ggfl () {
	[[ "$#" != 1 ]] && local b="$(git_current_branch)" 
	git push --force-with-lease origin "${b:=$1}"
}
ggl () {
	if [[ "$#" != 0 ]] && [[ "$#" != 1 ]]
	then
		git pull origin "${*}"
	else
		[[ "$#" == 0 ]] && local b="$(git_current_branch)" 
		git pull origin "${b:=$1}"
	fi
}
ggp () {
	if [[ "$#" != 0 ]] && [[ "$#" != 1 ]]
	then
		git push origin "${*}"
	else
		[[ "$#" == 0 ]] && local b="$(git_current_branch)" 
		git push origin "${b:=$1}"
	fi
}
ggpnp () {
	if [[ "$#" == 0 ]]
	then
		ggl && ggp
	else
		ggl "${*}" && ggp "${*}"
	fi
}
ggu () {
	[[ "$#" != 1 ]] && local b="$(git_current_branch)" 
	git pull --rebase origin "${b:=$1}"
}
git_commits_ahead () {
	if command git rev-parse --git-dir &> /dev/null
	then
		local commits="$(git rev-list --count @{upstream}..HEAD 2>/dev/null)" 
		if [[ -n "$commits" && "$commits" != 0 ]]
		then
			echo "$ZSH_THEME_GIT_COMMITS_AHEAD_PREFIX$commits$ZSH_THEME_GIT_COMMITS_AHEAD_SUFFIX"
		fi
	fi
}
git_commits_behind () {
	if command git rev-parse --git-dir &> /dev/null
	then
		local commits="$(git rev-list --count HEAD..@{upstream} 2>/dev/null)" 
		if [[ -n "$commits" && "$commits" != 0 ]]
		then
			echo "$ZSH_THEME_GIT_COMMITS_BEHIND_PREFIX$commits$ZSH_THEME_GIT_COMMITS_BEHIND_SUFFIX"
		fi
	fi
}
git_current_branch () {
	local ref
	ref=$(command git symbolic-ref --quiet HEAD 2> /dev/null) 
	local ret=$? 
	if [[ $ret != 0 ]]
	then
		[[ $ret == 128 ]] && return
		ref=$(command git rev-parse --short HEAD 2> /dev/null)  || return
	fi
	echo ${ref#refs/heads/}
}
git_current_user_email () {
	command git config user.email 2> /dev/null
}
git_current_user_name () {
	command git config user.name 2> /dev/null
}
git_prompt_ahead () {
	if [[ -n "$(command git rev-list origin/$(git_current_branch)..HEAD 2> /dev/null)" ]]
	then
		echo "$ZSH_THEME_GIT_PROMPT_AHEAD"
	fi
}
git_prompt_behind () {
	if [[ -n "$(command git rev-list HEAD..origin/$(git_current_branch) 2> /dev/null)" ]]
	then
		echo "$ZSH_THEME_GIT_PROMPT_BEHIND"
	fi
}
git_prompt_info () {
	local ref
	if [[ "$(command git config --get oh-my-zsh.hide-status 2>/dev/null)" != "1" ]]
	then
		ref=$(command git symbolic-ref HEAD 2> /dev/null)  || ref=$(command git rev-parse --short HEAD 2> /dev/null)  || return 0
		echo "$ZSH_THEME_GIT_PROMPT_PREFIX${ref#refs/heads/}$ZSH_THEME_GIT_PROMPT_SUFFIX"
	fi
}
git_prompt_long_sha () {
	local SHA
	SHA=$(command git rev-parse HEAD 2> /dev/null)  && echo "$ZSH_THEME_GIT_PROMPT_SHA_BEFORE$SHA$ZSH_THEME_GIT_PROMPT_SHA_AFTER"
}
git_prompt_remote () {
	if [[ -n "$(command git show-ref origin/$(git_current_branch) 2> /dev/null)" ]]
	then
		echo "$ZSH_THEME_GIT_PROMPT_REMOTE_EXISTS"
	else
		echo "$ZSH_THEME_GIT_PROMPT_REMOTE_MISSING"
	fi
}
git_prompt_short_sha () {
	local SHA
	SHA=$(command git rev-parse --short HEAD 2> /dev/null)  && echo "$ZSH_THEME_GIT_PROMPT_SHA_BEFORE$SHA$ZSH_THEME_GIT_PROMPT_SHA_AFTER"
}
git_prompt_status () {
	local INDEX STATUS
	INDEX=$(command git status --porcelain -b 2> /dev/null) 
	STATUS="" 
	if $(echo "$INDEX" | command grep -E '^\?\? ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_UNTRACKED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^A  ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_ADDED$STATUS" 
	elif $(echo "$INDEX" | grep '^M  ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_ADDED$STATUS" 
	elif $(echo "$INDEX" | grep '^MM ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_ADDED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^ M ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS" 
	elif $(echo "$INDEX" | grep '^AM ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS" 
	elif $(echo "$INDEX" | grep '^MM ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS" 
	elif $(echo "$INDEX" | grep '^ T ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^R  ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_RENAMED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^ D ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS" 
	elif $(echo "$INDEX" | grep '^D  ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS" 
	elif $(echo "$INDEX" | grep '^AD ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS" 
	fi
	if $(command git rev-parse --verify refs/stash >/dev/null 2>&1)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_STASHED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^UU ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_UNMERGED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^## [^ ]\+ .*ahead' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_AHEAD$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^## [^ ]\+ .*behind' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_BEHIND$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^## [^ ]\+ .*diverged' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_DIVERGED$STATUS" 
	fi
	echo $STATUS
}
git_remote_status () {
	local remote ahead behind git_remote_status git_remote_status_detailed
	remote=${$(command git rev-parse --verify ${hook_com[branch]}@{upstream} --symbolic-full-name 2>/dev/null)/refs\/remotes\/} 
	if [[ -n ${remote} ]]
	then
		ahead=$(command git rev-list ${hook_com[branch]}@{upstream}..HEAD 2>/dev/null | wc -l) 
		behind=$(command git rev-list HEAD..${hook_com[branch]}@{upstream} 2>/dev/null | wc -l) 
		if [[ $ahead -eq 0 ]] && [[ $behind -eq 0 ]]
		then
			git_remote_status="$ZSH_THEME_GIT_PROMPT_EQUAL_REMOTE" 
		elif [[ $ahead -gt 0 ]] && [[ $behind -eq 0 ]]
		then
			git_remote_status="$ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE" 
			git_remote_status_detailed="$ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE_COLOR$ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE$((ahead))%{$reset_color%}" 
		elif [[ $behind -gt 0 ]] && [[ $ahead -eq 0 ]]
		then
			git_remote_status="$ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE" 
			git_remote_status_detailed="$ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE_COLOR$ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE$((behind))%{$reset_color%}" 
		elif [[ $ahead -gt 0 ]] && [[ $behind -gt 0 ]]
		then
			git_remote_status="$ZSH_THEME_GIT_PROMPT_DIVERGED_REMOTE" 
			git_remote_status_detailed="$ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE_COLOR$ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE$((ahead))%{$reset_color%}$ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE_COLOR$ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE$((behind))%{$reset_color%}" 
		fi
		if [[ -n $ZSH_THEME_GIT_PROMPT_REMOTE_STATUS_DETAILED ]]
		then
			git_remote_status="$ZSH_THEME_GIT_PROMPT_REMOTE_STATUS_PREFIX$remote$git_remote_status_detailed$ZSH_THEME_GIT_PROMPT_REMOTE_STATUS_SUFFIX" 
		fi
		echo $git_remote_status
	fi
}
gpr () {
	git push origin HEAD
	if [ $? -eq 0 ]
	then
		openpr
	else
		echo 'failed to push commits and open a pull request.'
	fi
}
handle_completion_insecurities () {
	local -aU insecure_dirs
	insecure_dirs=(${(f@):-"$(compaudit 2>/dev/null)"}) 
	[[ -z "${insecure_dirs}" ]] && return
	print "[oh-my-zsh] Insecure completion-dependent directories detected:"
	ls -ld "${(@)insecure_dirs}"
	cat <<EOD

[oh-my-zsh] For safety, we will not load completions from these directories until
[oh-my-zsh] you fix their permissions and ownership and restart zsh.
[oh-my-zsh] See the above list for directories with group or other writability.

[oh-my-zsh] To fix your permissions you can do so by disabling
[oh-my-zsh] the write permission of "group" and "others" and making sure that the
[oh-my-zsh] owner of these directories is either root or your current user.
[oh-my-zsh] The following command may help:
[oh-my-zsh]     compaudit | xargs chmod g-w,o-w

[oh-my-zsh] If the above didn't help or you want to skip the verification of
[oh-my-zsh] insecure directories you can set the variable ZSH_DISABLE_COMPFIX to
[oh-my-zsh] "true" before oh-my-zsh is sourced in your zshrc file.

EOD
}
hg_prompt_info () {
	return 1
}
history-substring-search-down () {
	_history-substring-search-begin
	_history-substring-search-down-history || _history-substring-search-down-buffer || _history-substring-search-down-search
	_history-substring-search-end
}
history-substring-search-up () {
	_history-substring-search-begin
	_history-substring-search-up-history || _history-substring-search-up-buffer || _history-substring-search-up-search
	_history-substring-search-end
}
hs () {
	omz_history | grep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn} $*
}
is-at-least () {
	emulate -L zsh
	local IFS=".-" min_cnt=0 ver_cnt=0 part min_ver version order 
	min_ver=(${=1}) 
	version=(${=2:-$ZSH_VERSION} 0) 
	while (( $min_cnt <= ${#min_ver} ))
	do
		while [[ "$part" != <-> ]]
		do
			(( ++ver_cnt > ${#version} )) && return 0
			if [[ ${version[ver_cnt]} = *[0-9][^0-9]* ]]
			then
				order=(${version[ver_cnt]} ${min_ver[ver_cnt]}) 
				if [[ ${version[ver_cnt]} = <->* ]]
				then
					[[ $order != ${${(On)order}} ]] && return 1
				else
					[[ $order != ${${(O)order}} ]] && return 1
				fi
				[[ $order[1] != $order[2] ]] && return 0
			fi
			part=${version[ver_cnt]##*[^0-9]} 
		done
		while true
		do
			(( ++min_cnt > ${#min_ver} )) && return 0
			[[ ${min_ver[min_cnt]} = <-> ]] && break
		done
		(( part > min_ver[min_cnt] )) && return 0
		(( part < min_ver[min_cnt] )) && return 1
		part='' 
	done
}
is_a_function () {
	\typeset -f $1 > /dev/null 2>&1 || return $?
}
is_gem_installed () {
	\typeset gem_spec
	gem_spec="gem '$gem_name'" 
	if [[ -n "${gem_version}" ]]
	then
		gem_spec+=", '$gem_version'" 
		version_check="${gem_version#*=}" 
	else
		version_check="*([[:digit:]\.])" 
	fi
	__rvm_ls -ld "${rvm_ruby_gem_home:-$GEM_HOME}/gems"/${gem_name}-${version_check} > /dev/null 2>&1 || "${rvm_ruby_binary}" -rrubygems -e "$gem_spec" 2> /dev/null || return $?
}
is_parent_of () {
	\typeset name pid ppid pname
	name=$1 
	pid=$2 
	while [[ -n "$pid" && "$pid" != "0" ]]
	do
		case "`uname`" in
			(SunOS) read ppid pname <<< "$(\command \ps -p $pid -o ppid= -o comm=)" ;;
			(*) read ppid pname <<< "$(\command \ps -p $pid -o ppid= -o ucomm=)" ;;
		esac
		if [[ -n "$ppid" && -n "$pname" ]]
		then
			if [[ "$pname" == "$name" ]]
			then
				echo $pid
				return 0
			else
				pid=$ppid 
			fi
		else
			break
		fi
	done
	return 1
}
is_plugin () {
	local base_dir=$1 
	local name=$2 
	test -f $base_dir/plugins/$name/$name.plugin.zsh || test -f $base_dir/plugins/$name/_$name
}
itunes () {
	local opt=$1 
	local playlist=$2 
	shift
	case "$opt" in
		(launch | play | pause | stop | rewind | resume | quit)  ;;
		(mute) opt="set mute to true"  ;;
		(unmute) opt="set mute to false"  ;;
		(next | previous) opt="$opt track"  ;;
		(vol) local new_volume volume=$(osascript -e 'tell application "iTunes" to get sound volume') 
			if [[ $# -eq 0 ]]
			then
				echo "Current volume is ${volume}."
				return 0
			fi
			case $1 in
				(up) new_volume=$((volume + 10 < 100 ? volume + 10 : 100))  ;;
				(down) new_volume=$((volume - 10 > 0 ? volume - 10 : 0))  ;;
				(<0-100>) new_volume=$1  ;;
				(*) echo "'$1' is not valid. Expected <0-100>, up or down."
					return 1 ;;
			esac
			opt="set sound volume to ${new_volume}"  ;;
		(playlist) if [[ ! -z "$playlist" ]]
			then
				osascript -e 'tell application "iTunes"' -e "set new_playlist to \"$playlist\" as string" -e "play playlist new_playlist" -e "end tell" 2> /dev/null
				if [[ $? -eq 0 ]]
				then
					opt="play" 
				else
					opt="stop" 
				fi
			else
				opt="set allPlaylists to (get name of every playlist)" 
			fi ;;
		(playing | status) local state=`osascript -e 'tell application "iTunes" to player state as string'` 
			if [[ "$state" = "playing" ]]
			then
				currenttrack=`osascript -e 'tell application "iTunes" to name of current track as string'` 
				currentartist=`osascript -e 'tell application "iTunes" to artist of current track as string'` 
				echo -E "Listening to $fg[yellow]$currenttrack$reset_color by $fg[yellow]$currentartist$reset_color"
			else
				echo "iTunes is" $state
			fi
			return 0 ;;
		(shuf | shuff | shuffle) local state=$1 
			if [[ -n "$state" && ! "$state" =~ "^(on|off|toggle)$" ]]
			then
				print "Usage: itunes shuffle [on|off|toggle]. Invalid option."
				return 1
			fi
			case "$state" in
				(on | off) osascript > /dev/null 2>&1 <<EOF
tell application "System Events" to perform action "AXPress" of (menu item "${state}" of menu "Shuffle" of menu item "Shuffle" of menu "Controls" of menu bar item "Controls" of menu bar 1 of application process "iTunes" )
EOF
					return 0 ;;
				(toggle | *) osascript > /dev/null 2>&1 <<EOF
tell application "System Events" to perform action "AXPress" of (button 2 of process "iTunes"'s window "iTunes"'s scroll area 1)
EOF
					return 0 ;;
			esac ;;
		("" | -h | --help) echo "Usage: itunes <option>"
			echo "option:"
			echo "\tlaunch|play|pause|stop|rewind|resume|quit"
			echo "\tmute|unmute\tcontrol volume set"
			echo "\tnext|previous\tplay next or previous track"
			echo "\tshuf|shuffle [on|off|toggle]\tSet shuffled playback. Default: toggle. Note: toggle doesn't support the MiniPlayer."
			echo "\tvol [0-100|up|down]\tGet or set the volume. 0 to 100 sets the volume. 'up' / 'down' increases / decreases by 10 points. No argument displays current volume."
			echo "\tplaying|status\tShow what song is currently playing in iTunes."
			echo "\tplaylist [playlist name]\t Play specific playlist"
			echo "\thelp\tshow this message and exit"
			return 0 ;;
		(*) print "Unknown option: $opt"
			return 1 ;;
	esac
	osascript -e "tell application \"iTunes\" to $opt"
}
jenv_prompt_info () {
	return 1
}
load_rvm_scripts () {
	\typeset -a scripts
	scripts=(selector logging support utility init cleanup env rvmrc install environment gemset checksum list) 
	source "${rvm_scripts_path}/initialize"
	for entry in ${scripts[@]}
	do
		[[ " ${rvm_base_except:-} " == *" $entry "* ]] || source "${rvm_scripts_path}/functions/$entry" || return $?
	done
	unset rvm_base_except
}
logs () {
	docker logs -f $(docker ps --filter name="$1" --format="{{.ID}}")
}
man-preview () {
	man -t "$@" | open -f -a Preview
}
node-docs () {
	local section=${1:-all} 
	open_command "https://nodejs.org/docs/$(node --version)/api/$section.html"
}
nvm_prompt_info () {
	[[ -f "$NVM_DIR/nvm.sh" ]] || return
	local nvm_prompt
	nvm_prompt=$(node -v 2>/dev/null) 
	[[ "${nvm_prompt}x" == "x" ]] && return
	nvm_prompt=${nvm_prompt:1} 
	echo "${ZSH_THEME_NVM_PROMPT_PREFIX}${nvm_prompt}${ZSH_THEME_NVM_PROMPT_SUFFIX}"
}
oc_login () {
	cluster=$1 
	if [[ -z "$2" ]]
	then
		env="ci" 
	else
		env="$2" 
	fi
	summon --provider summon-conjur --yaml="
    OPENSHIFT_URL: !var $env/openshift/$cluster/hostname
    OPENSHIFT_USERNAME: !var $env/openshift/$cluster/username
    OPENSHIFT_PASSWORD: !var $env/openshift/$cluster/password
  " sh -c "oc login \$OPENSHIFT_URL:8443 --insecure-skip-tls-verify=true -u \$OPENSHIFT_USERNAME -p \$OPENSHIFT_PASSWORD"
}
omz_diagnostic_dump () {
	emulate -L zsh
	builtin echo "Generating diagnostic dump; please be patient..."
	local thisfcn=omz_diagnostic_dump 
	local -A opts
	local opt_verbose opt_noverbose opt_outfile
	local timestamp=$(date +%Y%m%d-%H%M%S) 
	local outfile=omz_diagdump_$timestamp.txt 
	builtin zparseopts -A opts -D -- "v+=opt_verbose" "V+=opt_noverbose"
	local verbose n_verbose=${#opt_verbose} n_noverbose=${#opt_noverbose} 
	(( verbose = 1 + n_verbose - n_noverbose ))
	if [[ ${#*} > 0 ]]
	then
		opt_outfile=$1 
	fi
	if [[ ${#*} > 1 ]]
	then
		builtin echo "$thisfcn: error: too many arguments" >&2
		return 1
	fi
	if [[ -n "$opt_outfile" ]]
	then
		outfile="$opt_outfile" 
	fi
	_omz_diag_dump_one_big_text &> "$outfile"
	if [[ $? != 0 ]]
	then
		builtin echo "$thisfcn: error while creating diagnostic dump; see $outfile for details"
	fi
	builtin echo
	builtin echo Diagnostic dump file created at: "$outfile"
	builtin echo
	builtin echo To share this with OMZ developers, post it as a gist on GitHub
	builtin echo at "https://gist.github.com" and share the link to the gist.
	builtin echo
	builtin echo "WARNING: This dump file contains all your zsh and omz configuration files,"
	builtin echo "so don't share it publicly if there's sensitive information in them."
	builtin echo
}
omz_history () {
	local clear list
	zparseopts -E c=clear l=list
	if [[ -n "$clear" ]]
	then
		echo -n >| "$HISTFILE"
		echo History file deleted. Reload the session to see its effects. >&2
	elif [[ -n "$list" ]]
	then
		builtin fc "$@"
	else
		[[ ${@[-1]-} = *[0-9]* ]] && builtin fc -l "$@" || builtin fc -l "$@" 1
	fi
}
omz_termsupport_precmd () {
	emulate -L zsh
	if [[ "$DISABLE_AUTO_TITLE" == true ]]
	then
		return
	fi
	title $ZSH_THEME_TERM_TAB_TITLE_IDLE $ZSH_THEME_TERM_TITLE_IDLE
}
omz_termsupport_preexec () {
	emulate -L zsh
	setopt extended_glob
	if [[ "$DISABLE_AUTO_TITLE" == true ]]
	then
		return
	fi
	local CMD=${1[(wr)^(*=*|sudo|ssh|mosh|rake|-*)]:gs/%/%%} 
	local LINE="${2:gs/%/%%}" 
	title '$CMD' '%100>...>$LINE%<<'
}
omz_urldecode () {
	emulate -L zsh
	local encoded_url=$1 
	local caller_encoding=$langinfo[CODESET] 
	local LC_ALL=C 
	export LC_ALL
	local tmp=${encoded_url:gs/+/ /} 
	tmp=${tmp:gs/\\/\\\\/} 
	tmp=${tmp:gs/%/\\x/} 
	local decoded
	eval "decoded=\$'$tmp'"
	local safe_encodings
	safe_encodings=(UTF-8 utf8 US-ASCII) 
	if [[ -z ${safe_encodings[(r)$caller_encoding]} ]]
	then
		decoded=$(echo -E "$decoded" | iconv -f UTF-8 -t $caller_encoding) 
		if [[ $? != 0 ]]
		then
			echo "Error converting string from UTF-8 to $caller_encoding" >&2
			return 1
		fi
	fi
	echo -E "$decoded"
}
omz_urlencode () {
	emulate -L zsh
	zparseopts -D -E -a opts r m P
	local in_str=$1 
	local url_str="" 
	local spaces_as_plus
	if [[ -z $opts[(r)-P] ]]
	then
		spaces_as_plus=1 
	fi
	local str="$in_str" 
	local encoding=$langinfo[CODESET] 
	local safe_encodings
	safe_encodings=(UTF-8 utf8 US-ASCII) 
	if [[ -z ${safe_encodings[(r)$encoding]} ]]
	then
		str=$(echo -E "$str" | iconv -f $encoding -t UTF-8) 
		if [[ $? != 0 ]]
		then
			echo "Error converting string from $encoding to UTF-8" >&2
			return 1
		fi
	fi
	local i byte ord LC_ALL=C 
	export LC_ALL
	local reserved=';/?:@&=+$,' 
	local mark='_.!~*''()-' 
	local dont_escape="[A-Za-z0-9" 
	if [[ -z $opts[(r)-r] ]]
	then
		dont_escape+=$reserved 
	fi
	if [[ -z $opts[(r)-m] ]]
	then
		dont_escape+=$mark 
	fi
	dont_escape+="]" 
	local url_str="" 
	for ((i = 1; i <= ${#str}; ++i )) do
		byte="$str[i]" 
		if [[ "$byte" =~ "$dont_escape" ]]
		then
			url_str+="$byte" 
		else
			if [[ "$byte" == " " && -n $spaces_as_plus ]]
			then
				url_str+="+" 
			else
				ord=$(( [##16] #byte )) 
				url_str+="%$ord" 
			fi
		fi
	done
	echo -E "$url_str"
}
open_command () {
	local open_cmd
	case "$OSTYPE" in
		(darwin*) open_cmd='open'  ;;
		(cygwin*) open_cmd='cygstart'  ;;
		(linux*) [[ "$(uname -r)" != *icrosoft* ]] && open_cmd='nohup xdg-open'  || {
				open_cmd='cmd.exe /c start ""' 
				[[ -e "$1" ]] && {
					1="$(wslpath -w "${1:a}")"  || return 1
				}
			} ;;
		(msys*) open_cmd='start ""'  ;;
		(*) echo "Platform $OSTYPE not supported"
			return 1 ;;
	esac
	${=open_cmd} "$@" &> /dev/null
}
openpr () {
	github_url=`git remote -v | awk '/fetch/{print $2}' | sed -Ee 's#(git@|git://)#https://#' -e 's@com:@com/@' -e 's%\.git$%%' | awk '/github/'` 
	branch_name=`git symbolic-ref HEAD | cut -d"/" -f 3,4` 
	pr_url=$github_url"/compare/master..."$branch_name 
	open $pr_url
}
pfd () {
	osascript 2> /dev/null <<EOF
    tell application "Finder"
      return POSIX path of (target of window 1 as alias)
    end tell
EOF
}
pfs () {
	osascript 2> /dev/null <<EOF
    set output to ""
    tell application "Finder" to set the_selection to selection
    set item_count to count the_selection
    repeat with item_index from 1 to count the_selection
      if item_index is less than item_count then set the_delimiter to "\n"
      if item_index is item_count then set the_delimiter to ""
      set output to output & ((item item_index of the_selection as alias)'s POSIX path) & the_delimiter
    end repeat
EOF
}
pushdf () {
	pushd "$(pfd)"
}
pyenv_prompt_info () {
	return 1
}
quick-look () {
	(( $# > 0 )) && qlmanage -p $* &> /dev/null &
}
quote-paste () {
	emulate -L zsh
	local qstyle
	zstyle -s :bracketed-paste-magic:finish quote-style qstyle && NUMERIC=1 
	case $qstyle in
		(b) PASTED=${(b)PASTED}  ;;
		(q-) PASTED=${(q-)PASTED}  ;;
		(\\|q) PASTED=${(q)PASTED}  ;;
		(\'|qq) PASTED=${(qq)PASTED}  ;;
		(\"|qqq) PASTED=${(qqq)PASTED}  ;;
		(\$|qqqq) PASTED=${(qqqq)PASTED}  ;;
		(Q) PASTED=${(Q)PASTED}  ;;
	esac
}
rbenv () {
	local command
	command="${1:-}" 
	if [ "$#" -gt 0 ]
	then
		shift
	fi
	case "$command" in
		(rehash | shell) eval "$(rbenv "sh-$command" "$@")" ;;
		(*) command rbenv "$command" "$@" ;;
	esac
}
rbenv_prompt_info () {
	return 1
}
rmdsstore () {
	find "${@:-.}" -type f -name .DS_Store -delete
}
ruby_prompt_info () {
	echo $(rvm_prompt_info || rbenv_prompt_info || chruby_prompt_info)
}
rubygems_detect_ruby_lib_gem_path () {
	\typeset ruby_path
	ruby_path="$( __rvm_which "${1:-ruby}" )"  || {
		rvm_error "Missing 'ruby' in 'rubygems_detect_ruby_lib_gem_path'."
		return 1
	}
	ruby_lib_gem_path="$(
    unset GEM_HOME GEM_PATH
    "$ruby_path" -rrubygems -e 'puts Gem.default_dir' 2>/dev/null
  )"  || ruby_lib_gem_path="" 
	[[ -n "$ruby_lib_gem_path" ]] || rubygems_detect_ruby_lib_gem_path_fallback || return $?
}
rubygems_detect_ruby_lib_gem_path_fallback () {
	rubygems_detect_ruby_lib_gem_path_from "rubylib" || rubygems_detect_ruby_lib_gem_path_from "lib" || return $?
	ruby_lib_gem_path+="/gems" 
	\typeset ruby_version
	ruby_version="$( __rvm_ruby_config_get ruby_version "$ruby_path")"  || ruby_version="" 
	if [[ -n "${ruby_version:-}" && -d "${ruby_lib_gem_path}/${ruby_version:-}" ]]
	then
		ruby_lib_gem_path+="$ruby_version" 
	elif [[ -d "${ruby_lib_gem_path}/shared" ]]
	then
		ruby_lib_gem_path+="shared" 
	else
		return 3
	fi
}
rubygems_detect_ruby_lib_gem_path_from () {
	ruby_lib_gem_path="$( __rvm_ruby_config_get ${1}prefix "$ruby_path" )"  || ruby_lib_gem_path="" 
	[[ -z "${ruby_lib_gem_path:-}" ]] || {
		ruby_lib_gem_path="$( __rvm_ruby_config_get ${1}dir  "$ruby_path" )"  || ruby_lib_gem_path="" 
		ruby_lib_gem_path="${ruby_lib_gem_path%/*}" 
	}
	[[ -n "${ruby_lib_gem_path:-}" ]] || return 1
	[[ -d "${ruby_lib_gem_path}/gems" ]] || return 2
}
run_gem_wrappers () {
	gem_install gem-wrappers > /dev/null && gem wrappers "$@" || return $?
}
rvm () {
	\typeset result current_result
	rvm_ruby_args=() 
	__rvm_teardown_if_broken
	__rvm_cli_posix_check || return $?
	__rvm_cli_load_rvmrc || return $?
	__rvm_cli_version_check "$@" || return $?
	__rvm_initialize
	__rvm_path_match_gem_home_check
	__rvm_setup
	__rvm_cli_autoupdate "$@" || return $?
	next_token="$1" 
	(( $# == 0 )) || shift
	__rvm_parse_args "$@"
	result=$? 
	: rvm_ruby_args:${#rvm_ruby_args[@]}:${rvm_ruby_args[*]}:
	(( ${rvm_trace_flag:-0} == 0 )) || set -o xtrace
	(( result )) || case "${rvm_action:=help}" in
		(use) if rvm_is_a_shell_function
			then
				__rvm_use && __rvm_use_ruby_warnings
			fi ;;
		(switch) if rvm_is_a_shell_function
			then
				__rvm_switch "${rvm_ruby_args[@]}"
			fi ;;
		(inspect | strings | version | remote_version) __rvm_${rvm_action} ;;
		(ls | list) "$rvm_scripts_path/list" "${rvm_ruby_args[@]}" ;;
		(debug) rvm_is_not_a_shell_function="${rvm_is_not_a_shell_function}" "$rvm_scripts_path/info" '' debug ;;
		(info) rvm_is_not_a_shell_function="${rvm_is_not_a_shell_function}" "$rvm_scripts_path/${rvm_action}" "${rvm_ruby_args[@]}" ;;
		(reset) source "$rvm_scripts_path/functions/${rvm_action}"
			__rvm_${rvm_action} ;;
		(update) printf "%b" "ERROR: rvm update has been removed. Try 'rvm get head' or see the 'rvm get' and rvm 'rubygems' CLI API instead\n" ;;
		(implode | seppuku) source "$rvm_scripts_path/functions/implode"
			__rvm_implode ;;
		(get) next_token="${1:-}" 
			(( $# == 0 )) || shift
			[[ "$next_token" == "${rvm_action}" ]] && shift
			__rvm_cli_rvm_get "${rvm_ruby_args[@]}" ;;
		(current) __rvm_env_string ;;
		(help | rtfm | env | list | monitor | notes | pkg | requirements) next_token="${1:-}" 
			(( $# == 0 )) || shift
			if (( $# )) && [[ "$next_token" == "${rvm_action}" ]]
			then
				shift
			fi
			"$rvm_scripts_path/${rvm_action}" "${rvm_ruby_args[@]}" ;;
		(cleanup | tools | snapshot | disk-usage | repair | alias | docs | rubygems | migrate | cron | group | wrapper) "$rvm_scripts_path/${rvm_action}" "${rvm_ruby_args[@]}" ;;
		(upgrade) __rvm_fix_selected_ruby __rvm_run_wrapper "$rvm_action" "$rvm_action" "${rvm_ruby_args[@]}" ;;
		(autolibs | osx-ssl-certs | fix-permissions) __rvm_run_wrapper "$rvm_action" "$rvm_action" "${rvm_ruby_args[@]}" ;;
		(do) old_rvm_ruby_string=${rvm_ruby_string:-} 
			unset rvm_ruby_string
			export rvm_ruby_strings rvm_in_flag
			result=0 
			if rvm_is_a_shell_function no_warning
			then
				"$rvm_scripts_path/set" "$rvm_action" "${rvm_ruby_args[@]}" || result=$? 
			else
				exec "$rvm_scripts_path/set" "$rvm_action" "${rvm_ruby_args[@]}" || result=$? 
			fi
			[[ -n "$old_rvm_ruby_string" ]] && rvm_ruby_string=$old_rvm_ruby_string 
			unset old_rvm_ruby_string ;;
		(rvmrc) __rvm_rvmrc_tools "${rvm_ruby_args[@]}" ;;
		(config-get) \typeset __ruby __var
			__ruby=$( __rvm_which ruby ) 
			for __var in "${rvm_ruby_args[@]}"
			do
				__rvm_ruby_config_get "${__var}" "${__ruby}"
			done ;;
		(gemset_use) if rvm_is_a_shell_function
			then
				__rvm_gemset_use
			fi ;;
		(gemset) export rvm_ruby_strings
			"$rvm_scripts_path/gemsets" "${rvm_ruby_args[@]}"
			result=$? 
			rvm_ruby_strings="" 
			if rvm_is_a_shell_function no_warning
			then
				if [[ ${rvm_delete_flag:-0} -eq 1 ]]
				then
					if [[ "${GEM_HOME:-""}" == "${GEM_HOME%%${rvm_gemset_separator:-@}*}${rvm_gemset_separator:-@}${rvm_gemset_name}" ]]
					then
						rvm_delete_flag=0 
						__rvm_use "@default"
					fi
					unset gem_prefix
				elif [[ "${rvm_ruby_args[*]}" == rename* ]]
				then
					\typeset _command _from _to
					read _command _from _to <<< "${rvm_ruby_args[*]}"
					if [[ "${GEM_HOME:-""}" == "${GEM_HOME%%${rvm_gemset_separator:-@}*}${rvm_gemset_separator:-@}${_from}" ]]
					then
						__rvm_use "@${_to}"
					fi
				fi
			fi ;;
		(reload) rvm_reload_flag=1  ;;
		(tests | specs) rvm_action="rake" 
			__rvm_do ;;
		(remove) export rvm_path
			if [[ -n "${rvm_ruby_strings}" ]]
			then
				__rvm_run_wrapper manage "$rvm_action" "${rvm_ruby_strings//*-- }"
			else
				__rvm_run_wrapper manage "$rvm_action"
			fi
			__rvm_use default ;;
		(fetch | uninstall | reinstall) export rvm_path
			if [[ -n "${rvm_ruby_strings}" ]]
			then
				__rvm_run_wrapper manage "$rvm_action" "${rvm_ruby_strings//*-- }"
			else
				__rvm_run_wrapper manage "$rvm_action"
			fi ;;
		(try_install | install) export rvm_path
			__rvm_cli_install_ruby "${rvm_ruby_strings}" ;;
		(automount) if [[ -n "$rvm_ruby_string" ]]
			then
				rvm_ruby_args=("$rvm_ruby_string" "${rvm_ruby_args[@]}") 
			fi
			"${rvm_scripts_path}/mount" "$rvm_action" "${rvm_ruby_args[@]}" ;;
		(mount | prepare) if [[ -n "$rvm_ruby_string" ]]
			then
				rvm_ruby_args=("$rvm_ruby_string" "${rvm_ruby_args[@]}") 
			fi
			"${rvm_scripts_path}/$rvm_action" "$rvm_action" "${rvm_ruby_args[@]}" ;;
		(export) __rvm_export "$rvm_export_args" ;;
		(unexport) __rvm_unset_exports ;;
		(error) false ;;
		(which) __rvm_which "${rvm_ruby_args[@]}" ;;
		(*) rvm_error "unknown action '$rvm_action'"
			false ;;
	esac
	current_result=$? 
	(( result )) || result=${current_result} 
	(( result )) || case "$rvm_action" in
		(reinstall | try_install | install) if [[ -n "${rvm_ruby_string}" ]]
				rvm_is_a_shell_function no_warning
			then
				if [[ -e "${rvm_environments_path}/default" ]]
				then
					rvm_verbose_flag=0 __rvm_use
				else
					rvm_verbose_flag=0 rvm_default_flag=1 __rvm_use
				fi
			fi ;;
	esac
	current_result=$? 
	(( result )) || result=${current_result} 
	\typeset __local_rvm_trace_flag
	__local_rvm_trace_flag=${rvm_trace_flag:-0} 
	__rvm_cli_autoreload
	if (( __local_rvm_trace_flag > 0 ))
	then
		set +o verbose
		set +o xtrace
		[[ -n "${ZSH_VERSION:-""}" ]] || set +o errtrace
	fi
	return ${result:-0}
}
rvm_debug () {
	(( ${rvm_debug_flag:-0} )) || return 0
	if rvm_pretty_print stderr
	then
		__rvm_replace_colors "<debug>$*</debug>\n" >&6
	else
		printf "%b" "$*\n" >&6
	fi
}
rvm_debug_stream () {
	if (( ${rvm_debug_flag:-0} == 0 && ${rvm_trace_flag:-0} == 0 ))
	then
		cat - > /dev/null
	elif rvm_pretty_print stdout
	then
		\command \cat - | __rvm_awk '{print "'"${rvm_debug_clr:-}"'"$0"'"${rvm_reset_clr:-}"'"}' >&6
	else
		\command \cat - >&6
	fi
}
rvm_error () {
	if rvm_pretty_print stderr
	then
		__rvm_replace_colors "<error>$*</error>\n" >&6
	else
		printf "%b" "$*\n" >&6
	fi
}
rvm_error_help () {
	rvm_error "$1"
	shift
	rvm_help "$@"
}
rvm_fail () {
	rvm_error "$1"
	exit "${2:-1}"
}
rvm_help () {
	"${rvm_scripts_path}/help" "$@"
}
rvm_install_gpg_setup () {
	{
		rvm_gpg_command="$( \which gpg2 2>/dev/null )"  && [[ ${rvm_gpg_command} != "/cygdrive/"* ]]
	} || {
		rvm_gpg_command="$( \which gpg 2>/dev/null )"  && [[ ${rvm_gpg_command} != "/cygdrive/"* ]]
	} || rvm_gpg_command="" 
	rvm_debug "Detected GPG program: '$rvm_gpg_command'"
	[[ -n "$rvm_gpg_command" ]] || return $?
}
rvm_is_a_shell_function () {
	\typeset _message
	if (( ${rvm_is_not_a_shell_function:-0} )) && [[ "${1:-}" != "no_warning" ]]
	then
		if rvm_pretty_print stderr
		then
			rvm_log ""
		fi
		if rvm_pretty_print stderr
		then
			rvm_error "${rvm_notify_clr:-}RVM is not a function, selecting rubies with '${rvm_error_clr:-}rvm use ...${rvm_notify_clr:-}' will not work."
		else
			rvm_error "RVM is not a function, selecting rubies with 'rvm use ...' will not work."
		fi
		if [[ -n "${SUDO_USER:-}" ]]
		then
			rvm_warn '
Please avoid using "sudo" in front of "rvm".
RVM knows when to use "sudo" and will use it only when it is necessary.
'
		else
			rvm_warn '
You need to change your terminal emulator preferences to allow login shell.
Sometimes it is required to use `/bin/bash --login` as the command.
Please visit https://rvm.io/integration/gnome-terminal/ for an example.
'
		fi
	fi
	return ${rvm_is_not_a_shell_function:-0}
}
rvm_log () {
	[[ ${rvm_quiet_flag} == 1 ]] && return
	printf "%b" "$*\n"
}
rvm_notify () {
	if rvm_pretty_print stdout
	then
		__rvm_replace_colors "<notify>$*</notify>\n"
	else
		printf "%b" "$*\n"
	fi
}
rvm_out () {
	printf "$*\n"
}
rvm_pretty_print () {
	case "${rvm_pretty_print_flag:=auto}" in
		(0|no) return 1 ;;
		(1|auto) case "${TERM:-dumb}" in
				(dumb|unknown) return 1 ;;
			esac
			case "$1" in
				(stdout) [[ -t 1 ]] || return 1 ;;
				(stderr) [[ -t 2 ]] || return 1 ;;
				([0-9]) [[ -t $1 ]] || return 1 ;;
				(any) [[ -t 1 || -t 2 ]] || return 1 ;;
				(*) [[ -t 1 && -t 2 ]] || return 1 ;;
			esac
			return 0 ;;
		(2|force) return 0 ;;
	esac
}
rvm_printf_to_stderr () {
	printf "$@" >&6
}
rvm_prompt_info () {
	[ -f $HOME/.rvm/bin/rvm-prompt ] || return 1
	local rvm_prompt
	rvm_prompt=$($HOME/.rvm/bin/rvm-prompt ${=ZSH_THEME_RVM_PROMPT_OPTIONS} 2>/dev/null) 
	[[ -z "${rvm_prompt}" ]] && return 1
	echo "${ZSH_THEME_RUBY_PROMPT_PREFIX}${rvm_prompt}${ZSH_THEME_RUBY_PROMPT_SUFFIX}"
}
rvm_verbose_log () {
	if (( ${rvm_verbose_flag:=0} == 1 ))
	then
		rvm_log "$@"
	fi
}
rvm_warn () {
	if rvm_pretty_print stderr
	then
		__rvm_replace_colors "<warn>$*</warn>\n" >&6
	else
		printf "%b" "$*\n" >&6
	fi
}
save_aliases () {
	alias >> .aliases
}
save_brew_packages () {
	echo -e "
    ---------------
    Saving Brew packages to `brew` file
    ---------------
    "
	brew list > brew
}
save_functions () {
	functions >> .functions
}
save_zshrc () {
	cp $HOME/.zshrc .zshrc
}
spectrum_bls () {
	for code in {000..255}
	do
		print -P -- "$code: %{$BG[$code]%}$ZSH_SPECTRUM_TEXT%{$reset_color%}"
	done
}
spectrum_ls () {
	for code in {000..255}
	do
		print -P -- "$code: %{$FG[$code]%}$ZSH_SPECTRUM_TEXT%{$reset_color%}"
	done
}
split_tab () {
	local command="cd \\\"$PWD\\\"; clear" 
	(( $# > 0 )) && command="${command}; $*" 
	local the_app=$(_omz_osx_get_frontmost_app) 
	if [[ "$the_app" == 'iTerm' ]]
	then
		osascript 2> /dev/null <<EOF
      tell application "iTerm" to activate

      tell application "System Events"
        tell process "iTerm"
          tell menu item "Split Horizontally With Current Profile" of menu "Shell" of menu bar item "Shell" of menu bar 1
            click
          end tell
        end tell
        keystroke "${command} \n"
      end tell
EOF
	elif [[ "$the_app" == 'iTerm2' ]]
	then
		osascript <<EOF
        tell application "iTerm2"
          tell current session of first window
            set newSession to (split horizontally with same profile)
            tell newSession
              write text "${command}"
              select
            end tell
          end tell
        end tell
EOF
	elif [[ "$the_app" == 'Hyper' ]]
	then
		osascript > /dev/null <<EOF
      tell application "System Events"
        tell process "Hyper"
          tell menu item "Split Horizontally" of menu "Shell" of menu bar 1
            click
          end tell
        end tell
        delay 1
        keystroke "${command} \n"
      end tell
EOF
	else
		echo "$0: unsupported terminal app: $the_app" >&2
		false
	fi
}
spotify () {
	USER_CONFIG_DEFAULTS="CLIENT_ID=\"\"\nCLIENT_SECRET=\"\"" 
	USER_CONFIG_FILE="${HOME}/.shpotify.cfg" 
	if ! [[ -f "${USER_CONFIG_FILE}" ]]
	then
		touch "${USER_CONFIG_FILE}"
		echo -e "${USER_CONFIG_DEFAULTS}" > "${USER_CONFIG_FILE}"
	fi
	source "${USER_CONFIG_FILE}"
	showAPIHelp () {
		echo
		echo "Connecting to Spotify's API:"
		echo
		echo "  This command line application needs to connect to Spotify's API in order to"
		echo "  find music by name. It is very likely you want this feature!"
		echo
		echo "  To get this to work, you need to sign up (or in) and create an 'Application' at:"
		echo "  https://developer.spotify.com/my-applications/#!/applications/create"
		echo
		echo "  Once you've created an application, find the 'Client ID' and 'Client Secret'"
		echo "  values, and enter them into your shpotify config file at '${USER_CONFIG_FILE}'"
		echo
		echo "  Be sure to quote your values and don't add any extra spaces!"
		echo "  When done, it should look like this (but with your own values):"
		echo '  CLIENT_ID="abc01de2fghijk345lmnop"'
		echo '  CLIENT_SECRET="qr6stu789vwxyz"'
	}
	showHelp () {
		echo "Usage:"
		echo
		echo "  `basename $0` <command>"
		echo
		echo "Commands:"
		echo
		echo "  play                         # Resumes playback where Spotify last left off."
		echo "  play <song name>             # Finds a song by name and plays it."
		echo "  play album <album name>      # Finds an album by name and plays it."
		echo "  play artist <artist name>    # Finds an artist by name and plays it."
		echo "  play list <playlist name>    # Finds a playlist by name and plays it."
		echo "  play uri <uri>               # Play songs from specific uri."
		echo
		echo "  next                         # Skips to the next song in a playlist."
		echo "  prev                         # Returns to the previous song in a playlist."
		echo "  replay                       # Replays the current track from the beginning."
		echo "  pos <time>                   # Jumps to a time (in secs) in the current song."
		echo "  pause                        # Pauses (or resumes) Spotify playback."
		echo "  stop                         # Stops playback."
		echo "  quit                         # Stops playback and quits Spotify."
		echo
		echo "  vol up                       # Increases the volume by 10%."
		echo "  vol down                     # Decreases the volume by 10%."
		echo "  vol <amount>                 # Sets the volume to an amount between 0 and 100."
		echo "  vol [show]                   # Shows the current Spotify volume."
		echo
		echo "  status                       # Shows the current player status."
		echo "  status artist                # Shows the currently playing artist."
		echo "  status album                 # Shows the currently playing album."
		echo "  status track                 # Shows the currently playing track."
		echo
		echo "  share                        # Displays the current song's Spotify URL and URI."
		echo "  share url                    # Displays the current song's Spotify URL and copies it to the clipboard."
		echo "  share uri                    # Displays the current song's Spotify URI and copies it to the clipboard."
		echo
		echo "  toggle shuffle               # Toggles shuffle playback mode."
		echo "  toggle repeat                # Toggles repeat playback mode."
		showAPIHelp
	}
	cecho () {
		bold=$(tput bold) 
		green=$(tput setaf 2) 
		reset=$(tput sgr0) 
		echo $bold$green"$1"$reset
	}
	showArtist () {
		echo `osascript -e 'tell application "Spotify" to artist of current track as string'`
	}
	showAlbum () {
		echo `osascript -e 'tell application "Spotify" to album of current track as string'`
	}
	showTrack () {
		echo `osascript -e 'tell application "Spotify" to name of current track as string'`
	}
	showStatus () {
		state=`osascript -e 'tell application "Spotify" to player state as string'` 
		cecho "Spotify is currently $state."
		duration=`osascript -e 'tell application "Spotify"
            set durSec to (duration of current track / 1000) as text
            set tM to (round (durSec / 60) rounding down) as text
            if length of ((durSec mod 60 div 1) as text) is greater than 1 then
                set tS to (durSec mod 60 div 1) as text
            else
                set tS to ("0" & (durSec mod 60 div 1)) as text
            end if
            set myTime to tM as text & ":" & tS as text
            end tell
            return myTime'` 
		position=`osascript -e 'tell application "Spotify"
            set pos to player position
            set nM to (round (pos / 60) rounding down) as text
            if length of ((round (pos mod 60) rounding down) as text) is greater than 1 then
                set nS to (round (pos mod 60) rounding down) as text
            else
                set nS to ("0" & (round (pos mod 60) rounding down)) as text
            end if
            set nowAt to nM as text & ":" & nS as text
            end tell
            return nowAt'` 
		echo -e $reset"Artist: $(showArtist)\nAlbum: $(showAlbum)\nTrack: $(showTrack) \nPosition: $position / $duration"
	}
	if [ $# = 0 ]
	then
		showHelp
	else
		if [ ! -d /Applications/Spotify.app ] && [ ! -d $HOME/Applications/Spotify.app ]
		then
			echo "The Spotify application must be installed."
			exit 1
		fi
		if [ $(osascript -e 'application "Spotify" is running') = "false" ]
		then
			osascript -e 'tell application "Spotify" to activate' || exit 1
			sleep 2
		fi
	fi
	while [ $# -gt 0 ]
	do
		arg=$1 
		case $arg in
			("play") if [ $# != 1 ]
				then
					array=($@) 
					len=${#array[@]} 
					SPOTIFY_SEARCH_API="https://api.spotify.com/v1/search" 
					SPOTIFY_TOKEN_URI="https://accounts.spotify.com/api/token" 
					if [ -z "${CLIENT_ID}" ]
					then
						cecho "Invalid Client ID, please update ${USER_CONFIG_FILE}"
						showAPIHelp
						exit 1
					fi
					if [ -z "${CLIENT_SECRET}" ]
					then
						cecho "Invalid Client Secret, please update ${USER_CONFIG_FILE}"
						showAPIHelp
						exit 1
					fi
					SHPOTIFY_CREDENTIALS=$(printf "${CLIENT_ID}:${CLIENT_SECRET}" | base64 | tr -d "\n"|tr -d '\r') 
					SPOTIFY_PLAY_URI="" 
					getAccessToken () {
						cecho "Connecting to Spotify's API"
						SPOTIFY_TOKEN_RESPONSE_DATA=$( \
                        curl "${SPOTIFY_TOKEN_URI}" \
                            --silent \
                            -X "POST" \
                            -H "Authorization: Basic ${SHPOTIFY_CREDENTIALS}" \
                            -d "grant_type=client_credentials" \
                    ) 
						if ! [[ "${SPOTIFY_TOKEN_RESPONSE_DATA}" =~ "access_token" ]]
						then
							cecho "Autorization failed, please check ${USER_CONFG_FILE}"
							cecho "${SPOTIFY_TOKEN_RESPONSE_DATA}"
							showAPIHelp
							exit 1
						fi
						SPOTIFY_ACCESS_TOKEN=$( \
                        printf "${SPOTIFY_TOKEN_RESPONSE_DATA}" \
                        | grep -E -o '"access_token":".*",' \
                        | sed 's/"access_token"://g' \
                        | sed 's/"//g' \
                        | sed 's/,.*//g' \
                    ) 
					}
					searchAndPlay () {
						type="$1" 
						Q="$2" 
						getAccessToken
						cecho "Searching ${type}s for: $Q"
						SPOTIFY_PLAY_URI=$( \
                        curl -s -G $SPOTIFY_SEARCH_API \
                            -H "Authorization: Bearer ${SPOTIFY_ACCESS_TOKEN}" \
                            -H "Accept: application/json" \
                            --data-urlencode "q=$Q" \
                            -d "type=$type&limit=1&offset=0" \
                        | grep -E -o "spotify:$type:[a-zA-Z0-9]+" -m 1
                    ) 
						echo "play uri: ${SPOTIFY_PLAY_URI}"
					}
					case $2 in
						("list") _args=${array[@]:2:$len} 
							Q=$_args 
							getAccessToken
							cecho "Searching playlists for: $Q"
							results=$( \
                            curl -s -G $SPOTIFY_SEARCH_API --data-urlencode "q=$Q" -d "type=playlist&limit=10&offset=0" -H "Accept: application/json" -H "Authorization: Bearer ${SPOTIFY_ACCESS_TOKEN}" \
                            | grep -E -o "spotify:playlist:[a-zA-Z0-9]+" -m 10 \
                        ) 
							count=$( \
                            echo "$results" | grep -c "spotify:playlist" \
                        ) 
							if [ "$count" -gt 0 ]
							then
								random=$(( $RANDOM % $count)) 
								SPOTIFY_PLAY_URI=$( \
                                echo "$results" | awk -v random="$random" '/spotify:playlist:[a-zA-Z0-9]+/{i++}i==random{print; exit}' \
                            ) 
							fi ;;
						("album" | "artist" | "track") _args=${array[@]:2:$len} 
							searchAndPlay $2 "$_args" ;;
						("uri") SPOTIFY_PLAY_URI=${array[@]:2:$len}  ;;
						(*) _args=${array[@]:1:$len} 
							searchAndPlay track "$_args" ;;
					esac
					if [ "$SPOTIFY_PLAY_URI" != "" ]
					then
						if [ "$2" = "uri" ]
						then
							cecho "Playing Spotify URI: $SPOTIFY_PLAY_URI"
						else
							cecho "Playing ($Q Search) -> Spotify URI: $SPOTIFY_PLAY_URI"
						fi
						osascript -e "tell application \"Spotify\" to play track \"$SPOTIFY_PLAY_URI\""
					else
						cecho "No results when searching for $Q"
					fi
				else
					cecho "Playing Spotify."
					osascript -e 'tell application "Spotify" to play'
				fi
				break ;;
			("pause") state=`osascript -e 'tell application "Spotify" to player state as string'` 
				if [ $state = "playing" ]
				then
					cecho "Pausing Spotify."
				else
					cecho "Playing Spotify."
				fi
				osascript -e 'tell application "Spotify" to playpause'
				break ;;
			("stop") state=`osascript -e 'tell application "Spotify" to player state as string'` 
				if [ $state = "playing" ]
				then
					cecho "Pausing Spotify."
					osascript -e 'tell application "Spotify" to playpause'
				else
					cecho "Spotify is already stopped."
				fi
				break ;;
			("quit") cecho "Quitting Spotify."
				osascript -e 'tell application "Spotify" to quit'
				exit 0 ;;
			("next") cecho "Going to next track."
				osascript -e 'tell application "Spotify" to next track'
				showStatus
				break ;;
			("prev") cecho "Going to previous track."
				osascript -e '
            tell application "Spotify"
                set player position to 0
                previous track
            end tell'
				showStatus
				break ;;
			("replay") cecho "Replaying current track."
				osascript -e 'tell application "Spotify" to set player position to 0'
				break ;;
			("vol") vol=`osascript -e 'tell application "Spotify" to sound volume as integer'` 
				if [[ $2 = "" || $2 = "show" ]]
				then
					cecho "Current Spotify volume level is $vol."
					break
				elif [ "$2" = "up" ]
				then
					if [ $vol -le 90 ]
					then
						newvol=$(( vol+10 )) 
						cecho "Increasing Spotify volume to $newvol."
					else
						newvol=100 
						cecho "Spotify volume level is at max."
					fi
				elif [ "$2" = "down" ]
				then
					if [ $vol -ge 10 ]
					then
						newvol=$(( vol-10 )) 
						cecho "Reducing Spotify volume to $newvol."
					else
						newvol=0 
						cecho "Spotify volume level is at min."
					fi
				elif [[ $2 =~ ^[0-9]+$ ]] && [[ $2 -ge 0 && $2 -le 100 ]]
				then
					newvol=$2 
					cecho "Setting Spotify volume level to $newvol"
				else
					echo "Improper use of 'vol' command"
					echo "The 'vol' command should be used as follows:"
					echo "  vol up                       # Increases the volume by 10%."
					echo "  vol down                     # Decreases the volume by 10%."
					echo "  vol [amount]                 # Sets the volume to an amount between 0 and 100."
					echo "  vol                          # Shows the current Spotify volume."
					exit 1
				fi
				osascript -e "tell application \"Spotify\" to set sound volume to $newvol"
				break ;;
			("toggle") if [ "$2" = "shuffle" ]
				then
					osascript -e 'tell application "Spotify" to set shuffling to not shuffling'
					curr=`osascript -e 'tell application "Spotify" to shuffling'` 
					cecho "Spotify shuffling set to $curr"
				elif [ "$2" = "repeat" ]
				then
					osascript -e 'tell application "Spotify" to set repeating to not repeating'
					curr=`osascript -e 'tell application "Spotify" to repeating'` 
					cecho "Spotify repeating set to $curr"
				fi
				break ;;
			("status") if [ $# != 1 ]
				then
					case $2 in
						("artist") showArtist
							break ;;
						("album") showAlbum
							break ;;
						("track") showTrack
							break ;;
					esac
				else
					showStatus
				fi
				break ;;
			("info") info=`osascript -e 'tell application "Spotify"
                set durSec to (duration of current track / 1000)
                set tM to (round (durSec / 60) rounding down) as text
                if length of ((durSec mod 60 div 1) as text) is greater than 1 then
                    set tS to (durSec mod 60 div 1) as text
                else
                    set tS to ("0" & (durSec mod 60 div 1)) as text
                end if
                set myTime to tM as text & "min " & tS as text & "s"
                set pos to player position
                set nM to (round (pos / 60) rounding down) as text
                if length of ((round (pos mod 60) rounding down) as text) is greater than 1 then
                    set nS to (round (pos mod 60) rounding down) as text
                else
                    set nS to ("0" & (round (pos mod 60) rounding down)) as text
                end if
                set nowAt to nM as text & "min " & nS as text & "s"
                set info to "" & "\nArtist:         " & artist of current track
                set info to info & "\nTrack:          " & name of current track
                set info to info & "\nAlbum Artist:   " & album artist of current track
                set info to info & "\nAlbum:          " & album of current track
                set info to info & "\nSeconds:        " & durSec
                set info to info & "\nSeconds played: " & pos
                set info to info & "\nDuration:       " & mytime
                set info to info & "\nNow at:         " & nowAt
                set info to info & "\nPlayed Count:   " & played count of current track
                set info to info & "\nTrack Number:   " & track number of current track
                set info to info & "\nPopularity:     " & popularity of current track
                set info to info & "\nId:             " & id of current track
                set info to info & "\nSpotify URL:    " & spotify url of current track
                set info to info & "\nArtwork:        " & artwork url of current track
                set info to info & "\nPlayer:         " & player state
                set info to info & "\nVolume:         " & sound volume
                set info to info & "\nShuffle:        " & shuffling
                set info to info & "\nRepeating:      " & repeating
            end tell
            return info'` 
				cecho "$info"
				break ;;
			("share") uri=`osascript -e 'tell application "Spotify" to spotify url of current track'` 
				remove='spotify:track:' 
				url=${uri#$remove} 
				url="https://open.spotify.com/track/$url" 
				if [ "$2" = "" ]
				then
					cecho "Spotify URL: $url"
					cecho "Spotify URI: $uri"
					echo "To copy the URL or URI to your clipboard, use:"
					echo "\`spotify share url\` or"
					echo "\`spotify share uri\` respectively."
				elif [ "$2" = "url" ]
				then
					cecho "Spotify URL: $url"
					echo -n $url | pbcopy
				elif [ "$2" = "uri" ]
				then
					cecho "Spotify URI: $uri"
					echo -n $uri | pbcopy
				fi
				break ;;
			("pos") cecho "Adjusting Spotify play position."
				osascript -e "tell application \"Spotify\" to set player position to $2"
				break ;;
			("help") showHelp
				break ;;
			(*) showHelp
				exit 1 ;;
		esac
	done
}
svn_prompt_info () {
	return 1
}
tab () {
	local command="cd \\\"$PWD\\\"; clear" 
	(( $# > 0 )) && command="${command}; $*" 
	local the_app=$(_omz_osx_get_frontmost_app) 
	if [[ "$the_app" == 'Terminal' ]]
	then
		osascript > /dev/null <<EOF
      tell application "System Events"
        tell process "Terminal" to keystroke "t" using command down
      end tell
      tell application "Terminal" to do script "${command}" in front window
EOF
	elif [[ "$the_app" == 'iTerm' ]]
	then
		osascript <<EOF
      tell application "iTerm"
        set current_terminal to current terminal
        tell current_terminal
          launch session "Default Session"
          set current_session to current session
          tell current_session
            write text "${command}"
          end tell
        end tell
      end tell
EOF
	elif [[ "$the_app" == 'iTerm2' ]]
	then
		osascript <<EOF
        tell application "iTerm2"
          tell current window
            create tab with default profile
            tell current session to write text "${command}"
          end tell
        end tell
EOF
	elif [[ "$the_app" == 'Hyper' ]]
	then
		osascript > /dev/null <<EOF
          tell application "System Events"
            tell process "Hyper" to keystroke "t" using command down
          end tell
          delay 1
          tell application "System Events"
              keystroke "${command}"
              key code 36  #(presses enter)
            end tell
EOF
	else
		echo "tab: unsupported terminal app: $the_app"
		false
	fi
}
take () {
	mkdir -p $@ && cd ${@:$#}
}
title () {
	emulate -L zsh
	setopt prompt_subst
	[[ "$EMACS" == *term* ]] && return
	: ${2=$1}
	case "$TERM" in
		(cygwin | xterm* | putty* | rxvt* | ansi) print -Pn "\e]2;$2:q\a"
			print -Pn "\e]1;$1:q\a" ;;
		(screen* | tmux*) print -Pn "\ek$1:q\e\\" ;;
		(*) if [[ "$TERM_PROGRAM" == "iTerm.app" ]]
			then
				print -Pn "\e]2;$2:q\a"
				print -Pn "\e]1;$1:q\a"
			else
				if [[ -n "$terminfo[fsl]" ]] && [[ -n "$terminfo[tsl]" ]]
				then
					echoti tsl
					print -Pn "$1"
					echoti fsl
				fi
			fi ;;
	esac
}
try_alias_value () {
	alias_value "$1" || echo "$1"
}
uninstall_oh_my_zsh () {
	env ZSH=$ZSH sh $ZSH/tools/uninstall.sh
}
up-line-or-beginning-search () {
	emulate -L zsh
	typeset -g __searching __savecursor
	if [[ $LBUFFER == *$'\n'* ]]
	then
		zle .up-line-or-history
		__searching='' 
	elif [[ -n $PREBUFFER ]] && zstyle -t ':zle:up-line-or-beginning-search' edit-buffer
	then
		zle .push-line-or-edit
	else
		[[ $LASTWIDGET = $__searching ]] && CURSOR=$__savecursor 
		__savecursor=$CURSOR 
		__searching=$WIDGET 
		zle .history-beginning-search-backward
		zstyle -T ':zle:up-line-or-beginning-search' leave-cursor && zle .end-of-line
	fi
}
upgrade_oh_my_zsh () {
	env ZSH=$ZSH sh $ZSH/tools/upgrade.sh
}
url-quote-magic () {
	setopt localoptions noksharrays extendedglob
	local qkey="${(q)KEYS}" 
	local -a reply match mbegin mend
	if [[ "$KEYS" != "$qkey" ]]
	then
		local lbuf="$LBUFFER$qkey" 
		if [[ "${(Q)LBUFFER}$KEYS" == "${(Q)lbuf}" ]]
		then
			local -a words
			words=("${(@Q)${(z)lbuf}}") 
			local urlseps urlmetas urlglobbers localschema otherschema
			if [[ "$words[-1]" == (#b)([^:]##):* ]]
			then
				zstyle -s ":url-quote-magic:$match[1]" url-seps urlseps ''
				zstyle -s ":url-quote-magic:$match[1]" url-metas urlmetas ''
			fi
			zstyle -s :url-quote-magic url-globbers urlglobbers '|'
			zstyle -s :urlglobber url-other-schema otherschema '|'
			if [[ "$words[1]" == ${~urlglobbers} ]]
			then
				zstyle -s :urlglobber url-local-schema localschema '|'
			else
				localschema=' ' 
			fi
			case "$words[-1]" in
				(*[\'\"]*)  ;;
				((${~localschema}):/(|/localhost)/*) [[ "$urlseps" == *"$KEYS"* ]] && LBUFFER="$LBUFFER\\"  ;;
				((${~otherschema}):*) [[ "$urlseps$urlmetas" == *"$KEYS"* ]] && LBUFFER="$LBUFFER\\"  ;;
			esac
		fi
	fi
	zle .self-insert
}
urlglobber () {
	local -a args globbed localschema otherschema reply
	local arg command="$1" 
	shift
	zstyle -s :urlglobber url-local-schema localschema '|'
	zstyle -s :urlglobber url-other-schema otherschema '|'
	for arg
	do
		case "${arg}" in
			((${~localschema}):/(|/localhost)/*) globbed=(${~${arg##ftp://(localhost|)}}) 
				args[$#args+1]=("${(M)arg##(${~localchema})://(localhost|)}${(@)^globbed}")  ;;
			((${~otherschema}):*) args[${#args}+1]="$arg"  ;;
			(*) args[${#args}+1]=(${~arg})  ;;
		esac
	done
	"$command" "${(@)args}"
}
verify_package_pgp () {
	if "${rvm_gpg_command}" --verify "$2" "$1"
	then
		rvm_notify "GPG verified '$1'"
	else
		\typeset _return=$?
		rvm_error "GPG signature verification failed for '$1' - '$3'! Try to install GPG v2 and then fetch the public key:

    ${SUDO_USER:+sudo }${rvm_gpg_command##*/} --keyserver hkp://pool.sks-keyservers.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB

or if it fails:

    command curl -sSL https://rvm.io/mpapis.asc | ${SUDO_USER:+sudo }${rvm_gpg_command##*/} --import -
    command curl -sSL https://rvm.io/pkuczynski.asc | ${SUDO_USER:+sudo }${rvm_gpg_command##*/} --import -

In case of further problems with validation please refer to https://rvm.io/rvm/security
"
		return ${_return}
	fi
}
vi_mode_prompt_info () {
	return 1
}
virtualenv_prompt_info () {
	return 1
}
vncviewer () {
	open vnc://$@
}
vsplit_tab () {
	local command="cd \\\"$PWD\\\"; clear" 
	(( $# > 0 )) && command="${command}; $*" 
	local the_app=$(_omz_osx_get_frontmost_app) 
	if [[ "$the_app" == 'iTerm' ]]
	then
		osascript <<EOF
      -- tell application "iTerm" to activate

      tell application "System Events"
        tell process "iTerm"
          tell menu item "Split Vertically With Current Profile" of menu "Shell" of menu bar item "Shell" of menu bar 1
            click
          end tell
        end tell
        keystroke "${command} \n"
      end tell
EOF
	elif [[ "$the_app" == 'iTerm2' ]]
	then
		osascript <<EOF
        tell application "iTerm2"
          tell current session of first window
            set newSession to (split vertically with same profile)
            tell newSession
              write text "${command}"
              select
            end tell
          end tell
        end tell
EOF
	elif [[ "$the_app" == 'Hyper' ]]
	then
		osascript > /dev/null <<EOF
      tell application "System Events"
        tell process "Hyper"
          tell menu item "Split Vertically" of menu "Shell" of menu bar 1
            click
          end tell
        end tell
        delay 1
        keystroke "${command} \n"
      end tell
EOF
	else
		echo "$0: unsupported terminal app: $the_app" >&2
		false
	fi
}
work_in_progress () {
	if $(git log -n 1 2>/dev/null | grep -q -c "\-\-wip\-\-")
	then
		echo "WIP!!"
	fi
}
zle-line-finish () {
	echoti rmkx
}
zle-line-init () {
	echoti smkx
}
zsh_stats () {
	fc -l 1 | awk '{CMD[$2]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl | head -n20
}
